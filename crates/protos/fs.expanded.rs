#[cfg(feature = "firestore")]
#[path = "google.firestore.v1.rs"]
pub mod v1 {
    /// A Firestore document.
    ///
    /// Must not exceed 1 MiB - 4 bytes.
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct Document {
        /// The resource name of the document, for example
        /// `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// The document's fields.
        ///
        /// The map keys represent field names.
        ///
        /// A simple field name contains only characters `a` to `z`, `A` to `Z`,
        /// `0` to `9`, or `_`, and must not start with `0` to `9`. For example,
        /// `foo_bar_17`.
        ///
        /// Field names matching the regular expression `__.*__` are reserved. Reserved
        /// field names are forbidden except in certain documented contexts. The map
        /// keys, represented as UTF-8, must not exceed 1,500 bytes and cannot be
        /// empty.
        ///
        /// Field paths may be used in other contexts to refer to structured fields
        /// defined here. For `map_value`, the field path is represented by the simple
        /// or quoted field names of the containing fields, delimited by `.`. For
        /// example, the structured field
        /// `"foo" : { map_value: { "x&y" : { string_value: "hello" }}}` would be
        /// represented by the field path `foo.x&y`.
        ///
        /// Within a field path, a quoted field name starts and ends with `` ` `` and
        /// may contain any character. Some characters, including `` ` ``, must be
        /// escaped using a `\`. For example, `` `x&y` `` represents `x&y` and
        /// `` `bak\`tik` `` represents `` bak`tik ``.
        #[prost(map = "string, message", tag = "2")]
        pub fields: ::std::collections::HashMap<::prost::alloc::string::String, Value>,
        /// Output only. The time at which the document was created.
        ///
        /// This value increases monotonically when a document is deleted then
        /// recreated. It can also be compared to values from other documents and
        /// the `read_time` of a query.
        #[prost(message, optional, tag = "3")]
        pub create_time: ::core::option::Option<super::super::protobuf::Timestamp>,
        /// Output only. The time at which the document was last changed.
        ///
        /// This value is initially set to the `create_time` then increases
        /// monotonically with each change to the document. It can also be
        /// compared to values from other documents and the `read_time` of a query.
        #[prost(message, optional, tag = "4")]
        pub update_time: ::core::option::Option<super::super::protobuf::Timestamp>,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for Document {
        #[inline]
        fn clone(&self) -> Document {
            Document {
                name: ::core::clone::Clone::clone(&self.name),
                fields: ::core::clone::Clone::clone(&self.fields),
                create_time: ::core::clone::Clone::clone(&self.create_time),
                update_time: ::core::clone::Clone::clone(&self.update_time),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for Document {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for Document {
        #[inline]
        fn eq(&self, other: &Document) -> bool {
            self.name == other.name && self.fields == other.fields
                && self.create_time == other.create_time
                && self.update_time == other.update_time
        }
    }
    impl ::prost::Message for Document {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.name != "" {
                ::prost::encoding::string::encode(1u32, &self.name, buf);
            }
            ::prost::encoding::hash_map::encode(
                ::prost::encoding::string::encode,
                ::prost::encoding::string::encoded_len,
                ::prost::encoding::message::encode,
                ::prost::encoding::message::encoded_len,
                2u32,
                &self.fields,
                buf,
            );
            if let Some(ref msg) = self.create_time {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
            if let Some(ref msg) = self.update_time {
                ::prost::encoding::message::encode(4u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "Document";
            match tag {
                1u32 => {
                    let mut value = &mut self.name;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "name");
                            error
                        })
                }
                2u32 => {
                    let mut value = &mut self.fields;
                    ::prost::encoding::hash_map::merge(
                            ::prost::encoding::string::merge,
                            ::prost::encoding::message::merge,
                            &mut value,
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "fields");
                            error
                        })
                }
                3u32 => {
                    let mut value = &mut self.create_time;
                    ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "create_time");
                            error
                        })
                }
                4u32 => {
                    let mut value = &mut self.update_time;
                    ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "update_time");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0
                + if self.name != "" {
                    ::prost::encoding::string::encoded_len(1u32, &self.name)
                } else {
                    0
                }
                + ::prost::encoding::hash_map::encoded_len(
                    ::prost::encoding::string::encoded_len,
                    ::prost::encoding::message::encoded_len,
                    2u32,
                    &self.fields,
                )
                + self
                    .create_time
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(3u32, msg))
                + self
                    .update_time
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(4u32, msg))
        }
        fn clear(&mut self) {
            self.name.clear();
            self.fields.clear();
            self.create_time = ::core::option::Option::None;
            self.update_time = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for Document {
        fn default() -> Self {
            Document {
                name: ::prost::alloc::string::String::new(),
                fields: ::core::default::Default::default(),
                create_time: ::core::default::Default::default(),
                update_time: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for Document {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("Document");
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.name)
                };
                builder.field("name", &wrapper)
            };
            let builder = {
                let wrapper = {
                    struct MapWrapper<'a, V: 'a>(
                        &'a ::std::collections::HashMap<
                            ::prost::alloc::string::String,
                            V,
                        >,
                    );
                    impl<'a, V> ::core::fmt::Debug for MapWrapper<'a, V>
                    where
                        V: ::core::fmt::Debug + 'a,
                    {
                        fn fmt(
                            &self,
                            f: &mut ::core::fmt::Formatter,
                        ) -> ::core::fmt::Result {
                            #[allow(non_snake_case)]
                            fn KeyWrapper<T>(v: T) -> T {
                                v
                            }
                            fn ValueWrapper<T>(v: T) -> T {
                                v
                            }
                            let mut builder = f.debug_map();
                            for (k, v) in self.0 {
                                builder.entry(&KeyWrapper(k), &ValueWrapper(v));
                            }
                            builder.finish()
                        }
                    }
                    MapWrapper(&self.fields)
                };
                builder.field("fields", &wrapper)
            };
            let builder = {
                let wrapper = &self.create_time;
                builder.field("create_time", &wrapper)
            };
            let builder = {
                let wrapper = &self.update_time;
                builder.field("update_time", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Document {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "name" => _serde::__private::Ok(__Field::__field0),
                            "fields" => _serde::__private::Ok(__Field::__field1),
                            "createTime" => _serde::__private::Ok(__Field::__field2),
                            "updateTime" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"name" => _serde::__private::Ok(__Field::__field0),
                            b"fields" => _serde::__private::Ok(__Field::__field1),
                            b"createTime" => _serde::__private::Ok(__Field::__field2),
                            b"updateTime" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Document>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Document;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Document",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::string::String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Document with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            ::std::collections::HashMap<
                                ::prost::alloc::string::String,
                                Value,
                            >,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Document with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<super::super::protobuf::Timestamp>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct Document with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<super::super::protobuf::Timestamp>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct Document with 4 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Document {
                            name: __field0,
                            fields: __field1,
                            create_time: __field2,
                            update_time: __field3,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::prost::alloc::string::String,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            ::std::collections::HashMap<
                                ::prost::alloc::string::String,
                                Value,
                            >,
                        > = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            ::core::option::Option<super::super::protobuf::Timestamp>,
                        > = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<
                            ::core::option::Option<super::super::protobuf::Timestamp>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::string::String,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("fields"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::std::collections::HashMap<
                                                ::prost::alloc::string::String,
                                                Value,
                                            >,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "createTime",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<super::super::protobuf::Timestamp>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "updateTime",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<super::super::protobuf::Timestamp>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("name")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("fields")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("createTime")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("updateTime")?
                            }
                        };
                        _serde::__private::Ok(Document {
                            name: __field0,
                            fields: __field1,
                            create_time: __field2,
                            update_time: __field3,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "name",
                    "fields",
                    "createTime",
                    "updateTime",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Document",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Document>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Document {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "Document",
                    false as usize + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "name",
                    &self.name,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "fields",
                    &self.fields,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "createTime",
                    &self.create_time,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "updateTime",
                    &self.update_time,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// A message that can hold any of the supported value types.
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct Value {
        /// Must have a value set.
        #[prost(
            oneof = "value::ValueType",
            tags = "11, 1, 2, 3, 10, 17, 18, 5, 8, 9, 6"
        )]
        pub value_type: ::core::option::Option<value::ValueType>,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for Value {
        #[inline]
        fn clone(&self) -> Value {
            Value {
                value_type: ::core::clone::Clone::clone(&self.value_type),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for Value {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for Value {
        #[inline]
        fn eq(&self, other: &Value) -> bool {
            self.value_type == other.value_type
        }
    }
    impl ::prost::Message for Value {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref oneof) = self.value_type {
                oneof.encode(buf)
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "Value";
            match tag {
                11u32 | 1u32 | 2u32 | 3u32 | 10u32 | 17u32 | 18u32 | 5u32 | 8u32 | 9u32
                | 6u32 => {
                    let mut value = &mut self.value_type;
                    value::ValueType::merge(value, tag, wire_type, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "value_type");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self.value_type.as_ref().map_or(0, value::ValueType::encoded_len)
        }
        fn clear(&mut self) {
            self.value_type = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for Value {
        fn default() -> Self {
            Value {
                value_type: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for Value {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("Value");
            let builder = {
                let wrapper = &self.value_type;
                builder.field("value_type", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Value {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "valueType" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"valueType" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Value>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Value;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Value",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<value::ValueType>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Value with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Value { value_type: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::core::option::Option<value::ValueType>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "valueType",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<value::ValueType>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("valueType")?
                            }
                        };
                        _serde::__private::Ok(Value { value_type: __field0 })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["valueType"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Value",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Value>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Value {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "Value",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "valueType",
                    &self.value_type,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// Nested message and enum types in `Value`.
    pub mod value {
        /// Must have a value set.
        #[serde(rename_all = "camelCase")]
        #[allow(clippy::derive_partial_eq_without_eq)]
        pub enum ValueType {
            /// A null value.
            #[prost(
                enumeration = "super::super::super::protobuf::NullValue",
                tag = "11"
            )]
            NullValue(i32),
            /// A boolean value.
            #[prost(bool, tag = "1")]
            BooleanValue(bool),
            /// An integer value.
            #[prost(int64, tag = "2")]
            IntegerValue(i64),
            /// A double value.
            #[prost(double, tag = "3")]
            DoubleValue(f64),
            /// A timestamp value.
            ///
            /// Precise only to microseconds. When stored, any additional precision is
            /// rounded down.
            #[prost(message, tag = "10")]
            TimestampValue(super::super::super::protobuf::Timestamp),
            /// A string value.
            ///
            /// The string, represented as UTF-8, must not exceed 1 MiB - 89 bytes.
            /// Only the first 1,500 bytes of the UTF-8 representation are considered by
            /// queries.
            #[prost(string, tag = "17")]
            StringValue(::prost::alloc::string::String),
            /// A bytes value.
            ///
            /// Must not exceed 1 MiB - 89 bytes.
            /// Only the first 1,500 bytes are considered by queries.
            #[prost(bytes, tag = "18")]
            BytesValue(::prost::alloc::vec::Vec<u8>),
            /// A reference to a document. For example:
            /// `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
            #[prost(string, tag = "5")]
            ReferenceValue(::prost::alloc::string::String),
            /// A geo point value representing a point on the surface of Earth.
            #[prost(message, tag = "8")]
            GeoPointValue(super::super::super::r#type::LatLng),
            /// An array value.
            ///
            /// Cannot directly contain another array value, though can contain an
            /// map which contains another array.
            #[prost(message, tag = "9")]
            ArrayValue(super::ArrayValue),
            /// A map value.
            #[prost(message, tag = "6")]
            MapValue(super::MapValue),
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::clone::Clone for ValueType {
            #[inline]
            fn clone(&self) -> ValueType {
                match self {
                    ValueType::NullValue(__self_0) => {
                        ValueType::NullValue(::core::clone::Clone::clone(__self_0))
                    }
                    ValueType::BooleanValue(__self_0) => {
                        ValueType::BooleanValue(::core::clone::Clone::clone(__self_0))
                    }
                    ValueType::IntegerValue(__self_0) => {
                        ValueType::IntegerValue(::core::clone::Clone::clone(__self_0))
                    }
                    ValueType::DoubleValue(__self_0) => {
                        ValueType::DoubleValue(::core::clone::Clone::clone(__self_0))
                    }
                    ValueType::TimestampValue(__self_0) => {
                        ValueType::TimestampValue(::core::clone::Clone::clone(__self_0))
                    }
                    ValueType::StringValue(__self_0) => {
                        ValueType::StringValue(::core::clone::Clone::clone(__self_0))
                    }
                    ValueType::BytesValue(__self_0) => {
                        ValueType::BytesValue(::core::clone::Clone::clone(__self_0))
                    }
                    ValueType::ReferenceValue(__self_0) => {
                        ValueType::ReferenceValue(::core::clone::Clone::clone(__self_0))
                    }
                    ValueType::GeoPointValue(__self_0) => {
                        ValueType::GeoPointValue(::core::clone::Clone::clone(__self_0))
                    }
                    ValueType::ArrayValue(__self_0) => {
                        ValueType::ArrayValue(::core::clone::Clone::clone(__self_0))
                    }
                    ValueType::MapValue(__self_0) => {
                        ValueType::MapValue(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::marker::StructuralPartialEq for ValueType {}
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::cmp::PartialEq for ValueType {
            #[inline]
            fn eq(&self, other: &ValueType) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
                    && match (self, other) {
                        (
                            ValueType::NullValue(__self_0),
                            ValueType::NullValue(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            ValueType::BooleanValue(__self_0),
                            ValueType::BooleanValue(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            ValueType::IntegerValue(__self_0),
                            ValueType::IntegerValue(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            ValueType::DoubleValue(__self_0),
                            ValueType::DoubleValue(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            ValueType::TimestampValue(__self_0),
                            ValueType::TimestampValue(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            ValueType::StringValue(__self_0),
                            ValueType::StringValue(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            ValueType::BytesValue(__self_0),
                            ValueType::BytesValue(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            ValueType::ReferenceValue(__self_0),
                            ValueType::ReferenceValue(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            ValueType::GeoPointValue(__self_0),
                            ValueType::GeoPointValue(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            ValueType::ArrayValue(__self_0),
                            ValueType::ArrayValue(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            ValueType::MapValue(__self_0),
                            ValueType::MapValue(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        impl ValueType {
            /// Encodes the message to a buffer.
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    ValueType::NullValue(ref value) => {
                        ::prost::encoding::int32::encode(11u32, &*value, buf);
                    }
                    ValueType::BooleanValue(ref value) => {
                        ::prost::encoding::bool::encode(1u32, &*value, buf);
                    }
                    ValueType::IntegerValue(ref value) => {
                        ::prost::encoding::int64::encode(2u32, &*value, buf);
                    }
                    ValueType::DoubleValue(ref value) => {
                        ::prost::encoding::double::encode(3u32, &*value, buf);
                    }
                    ValueType::TimestampValue(ref value) => {
                        ::prost::encoding::message::encode(10u32, &*value, buf);
                    }
                    ValueType::StringValue(ref value) => {
                        ::prost::encoding::string::encode(17u32, &*value, buf);
                    }
                    ValueType::BytesValue(ref value) => {
                        ::prost::encoding::bytes::encode(18u32, &*value, buf);
                    }
                    ValueType::ReferenceValue(ref value) => {
                        ::prost::encoding::string::encode(5u32, &*value, buf);
                    }
                    ValueType::GeoPointValue(ref value) => {
                        ::prost::encoding::message::encode(8u32, &*value, buf);
                    }
                    ValueType::ArrayValue(ref value) => {
                        ::prost::encoding::message::encode(9u32, &*value, buf);
                    }
                    ValueType::MapValue(ref value) => {
                        ::prost::encoding::message::encode(6u32, &*value, buf);
                    }
                }
            }
            /// Decodes an instance of the message from a buffer, and merges it into self.
            pub fn merge<B>(
                field: &mut ::core::option::Option<ValueType>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag {
                    11u32 => {
                        match field {
                            ::core::option::Option::Some(
                                ValueType::NullValue(ref mut value),
                            ) => {
                                ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            ValueType::NullValue(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    1u32 => {
                        match field {
                            ::core::option::Option::Some(
                                ValueType::BooleanValue(ref mut value),
                            ) => {
                                ::prost::encoding::bool::merge(wire_type, value, buf, ctx)
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::bool::merge(wire_type, value, buf, ctx)
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            ValueType::BooleanValue(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    2u32 => {
                        match field {
                            ::core::option::Option::Some(
                                ValueType::IntegerValue(ref mut value),
                            ) => {
                                ::prost::encoding::int64::merge(wire_type, value, buf, ctx)
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::int64::merge(wire_type, value, buf, ctx)
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            ValueType::IntegerValue(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    3u32 => {
                        match field {
                            ::core::option::Option::Some(
                                ValueType::DoubleValue(ref mut value),
                            ) => {
                                ::prost::encoding::double::merge(wire_type, value, buf, ctx)
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::double::merge(wire_type, value, buf, ctx)
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            ValueType::DoubleValue(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    10u32 => {
                        match field {
                            ::core::option::Option::Some(
                                ValueType::TimestampValue(ref mut value),
                            ) => {
                                ::prost::encoding::message::merge(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            ValueType::TimestampValue(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    17u32 => {
                        match field {
                            ::core::option::Option::Some(
                                ValueType::StringValue(ref mut value),
                            ) => {
                                ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            ValueType::StringValue(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    18u32 => {
                        match field {
                            ::core::option::Option::Some(
                                ValueType::BytesValue(ref mut value),
                            ) => {
                                ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            ValueType::BytesValue(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    5u32 => {
                        match field {
                            ::core::option::Option::Some(
                                ValueType::ReferenceValue(ref mut value),
                            ) => {
                                ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            ValueType::ReferenceValue(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    8u32 => {
                        match field {
                            ::core::option::Option::Some(
                                ValueType::GeoPointValue(ref mut value),
                            ) => {
                                ::prost::encoding::message::merge(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            ValueType::GeoPointValue(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    9u32 => {
                        match field {
                            ::core::option::Option::Some(
                                ValueType::ArrayValue(ref mut value),
                            ) => {
                                ::prost::encoding::message::merge(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            ValueType::ArrayValue(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    6u32 => {
                        match field {
                            ::core::option::Option::Some(
                                ValueType::MapValue(ref mut value),
                            ) => {
                                ::prost::encoding::message::merge(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            ValueType::MapValue(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    _ => {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "internal error: entered unreachable code: {0}",
                                format_args!("invalid ValueType tag: {0}", tag),
                            ),
                        );
                    }
                }
            }
            /// Returns the encoded length of the message without a length delimiter.
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    ValueType::NullValue(ref value) => {
                        ::prost::encoding::int32::encoded_len(11u32, &*value)
                    }
                    ValueType::BooleanValue(ref value) => {
                        ::prost::encoding::bool::encoded_len(1u32, &*value)
                    }
                    ValueType::IntegerValue(ref value) => {
                        ::prost::encoding::int64::encoded_len(2u32, &*value)
                    }
                    ValueType::DoubleValue(ref value) => {
                        ::prost::encoding::double::encoded_len(3u32, &*value)
                    }
                    ValueType::TimestampValue(ref value) => {
                        ::prost::encoding::message::encoded_len(10u32, &*value)
                    }
                    ValueType::StringValue(ref value) => {
                        ::prost::encoding::string::encoded_len(17u32, &*value)
                    }
                    ValueType::BytesValue(ref value) => {
                        ::prost::encoding::bytes::encoded_len(18u32, &*value)
                    }
                    ValueType::ReferenceValue(ref value) => {
                        ::prost::encoding::string::encoded_len(5u32, &*value)
                    }
                    ValueType::GeoPointValue(ref value) => {
                        ::prost::encoding::message::encoded_len(8u32, &*value)
                    }
                    ValueType::ArrayValue(ref value) => {
                        ::prost::encoding::message::encoded_len(9u32, &*value)
                    }
                    ValueType::MapValue(ref value) => {
                        ::prost::encoding::message::encoded_len(6u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for ValueType {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ValueType::NullValue(ref value) => {
                        let wrapper = {
                            struct ScalarWrapper<'a>(&'a i32);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    let res: ::core::result::Result<
                                        super::super::super::protobuf::NullValue,
                                        _,
                                    > = ::core::convert::TryFrom::try_from(*self.0);
                                    match res {
                                        Err(_) => ::core::fmt::Debug::fmt(&self.0, f),
                                        Ok(en) => ::core::fmt::Debug::fmt(&en, f),
                                    }
                                }
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("NullValue").field(&wrapper).finish()
                    }
                    ValueType::BooleanValue(ref value) => {
                        let wrapper = {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("BooleanValue").field(&wrapper).finish()
                    }
                    ValueType::IntegerValue(ref value) => {
                        let wrapper = {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("IntegerValue").field(&wrapper).finish()
                    }
                    ValueType::DoubleValue(ref value) => {
                        let wrapper = {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("DoubleValue").field(&wrapper).finish()
                    }
                    ValueType::TimestampValue(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TimestampValue").field(&wrapper).finish()
                    }
                    ValueType::StringValue(ref value) => {
                        let wrapper = {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("StringValue").field(&wrapper).finish()
                    }
                    ValueType::BytesValue(ref value) => {
                        let wrapper = {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("BytesValue").field(&wrapper).finish()
                    }
                    ValueType::ReferenceValue(ref value) => {
                        let wrapper = {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("ReferenceValue").field(&wrapper).finish()
                    }
                    ValueType::GeoPointValue(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("GeoPointValue").field(&wrapper).finish()
                    }
                    ValueType::ArrayValue(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ArrayValue").field(&wrapper).finish()
                    }
                    ValueType::MapValue(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("MapValue").field(&wrapper).finish()
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ValueType {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                        __field7,
                        __field8,
                        __field9,
                        __field10,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                7u64 => _serde::__private::Ok(__Field::__field7),
                                8u64 => _serde::__private::Ok(__Field::__field8),
                                9u64 => _serde::__private::Ok(__Field::__field9),
                                10u64 => _serde::__private::Ok(__Field::__field10),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 11",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "nullValue" => _serde::__private::Ok(__Field::__field0),
                                "booleanValue" => _serde::__private::Ok(__Field::__field1),
                                "integerValue" => _serde::__private::Ok(__Field::__field2),
                                "doubleValue" => _serde::__private::Ok(__Field::__field3),
                                "timestampValue" => _serde::__private::Ok(__Field::__field4),
                                "stringValue" => _serde::__private::Ok(__Field::__field5),
                                "bytesValue" => _serde::__private::Ok(__Field::__field6),
                                "referenceValue" => _serde::__private::Ok(__Field::__field7),
                                "geoPointValue" => _serde::__private::Ok(__Field::__field8),
                                "arrayValue" => _serde::__private::Ok(__Field::__field9),
                                "mapValue" => _serde::__private::Ok(__Field::__field10),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"nullValue" => _serde::__private::Ok(__Field::__field0),
                                b"booleanValue" => _serde::__private::Ok(__Field::__field1),
                                b"integerValue" => _serde::__private::Ok(__Field::__field2),
                                b"doubleValue" => _serde::__private::Ok(__Field::__field3),
                                b"timestampValue" => {
                                    _serde::__private::Ok(__Field::__field4)
                                }
                                b"stringValue" => _serde::__private::Ok(__Field::__field5),
                                b"bytesValue" => _serde::__private::Ok(__Field::__field6),
                                b"referenceValue" => {
                                    _serde::__private::Ok(__Field::__field7)
                                }
                                b"geoPointValue" => _serde::__private::Ok(__Field::__field8),
                                b"arrayValue" => _serde::__private::Ok(__Field::__field9),
                                b"mapValue" => _serde::__private::Ok(__Field::__field10),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ValueType>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ValueType;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum ValueType",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            i32,
                                        >(__variant),
                                        ValueType::NullValue,
                                    )
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            bool,
                                        >(__variant),
                                        ValueType::BooleanValue,
                                    )
                                }
                                (__Field::__field2, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            i64,
                                        >(__variant),
                                        ValueType::IntegerValue,
                                    )
                                }
                                (__Field::__field3, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            f64,
                                        >(__variant),
                                        ValueType::DoubleValue,
                                    )
                                }
                                (__Field::__field4, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            super::super::super::protobuf::Timestamp,
                                        >(__variant),
                                        ValueType::TimestampValue,
                                    )
                                }
                                (__Field::__field5, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            ::prost::alloc::string::String,
                                        >(__variant),
                                        ValueType::StringValue,
                                    )
                                }
                                (__Field::__field6, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            ::prost::alloc::vec::Vec<u8>,
                                        >(__variant),
                                        ValueType::BytesValue,
                                    )
                                }
                                (__Field::__field7, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            ::prost::alloc::string::String,
                                        >(__variant),
                                        ValueType::ReferenceValue,
                                    )
                                }
                                (__Field::__field8, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            super::super::super::r#type::LatLng,
                                        >(__variant),
                                        ValueType::GeoPointValue,
                                    )
                                }
                                (__Field::__field9, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            super::ArrayValue,
                                        >(__variant),
                                        ValueType::ArrayValue,
                                    )
                                }
                                (__Field::__field10, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            super::MapValue,
                                        >(__variant),
                                        ValueType::MapValue,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "nullValue",
                        "booleanValue",
                        "integerValue",
                        "doubleValue",
                        "timestampValue",
                        "stringValue",
                        "bytesValue",
                        "referenceValue",
                        "geoPointValue",
                        "arrayValue",
                        "mapValue",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "ValueType",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ValueType>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ValueType {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        ValueType::NullValue(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "ValueType",
                                0u32,
                                "nullValue",
                                __field0,
                            )
                        }
                        ValueType::BooleanValue(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "ValueType",
                                1u32,
                                "booleanValue",
                                __field0,
                            )
                        }
                        ValueType::IntegerValue(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "ValueType",
                                2u32,
                                "integerValue",
                                __field0,
                            )
                        }
                        ValueType::DoubleValue(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "ValueType",
                                3u32,
                                "doubleValue",
                                __field0,
                            )
                        }
                        ValueType::TimestampValue(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "ValueType",
                                4u32,
                                "timestampValue",
                                __field0,
                            )
                        }
                        ValueType::StringValue(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "ValueType",
                                5u32,
                                "stringValue",
                                __field0,
                            )
                        }
                        ValueType::BytesValue(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "ValueType",
                                6u32,
                                "bytesValue",
                                __field0,
                            )
                        }
                        ValueType::ReferenceValue(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "ValueType",
                                7u32,
                                "referenceValue",
                                __field0,
                            )
                        }
                        ValueType::GeoPointValue(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "ValueType",
                                8u32,
                                "geoPointValue",
                                __field0,
                            )
                        }
                        ValueType::ArrayValue(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "ValueType",
                                9u32,
                                "arrayValue",
                                __field0,
                            )
                        }
                        ValueType::MapValue(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "ValueType",
                                10u32,
                                "mapValue",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
    }
    /// An array value.
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct ArrayValue {
        /// Values in the array.
        #[prost(message, repeated, tag = "1")]
        pub values: ::prost::alloc::vec::Vec<Value>,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for ArrayValue {
        #[inline]
        fn clone(&self) -> ArrayValue {
            ArrayValue {
                values: ::core::clone::Clone::clone(&self.values),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for ArrayValue {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for ArrayValue {
        #[inline]
        fn eq(&self, other: &ArrayValue) -> bool {
            self.values == other.values
        }
    }
    impl ::prost::Message for ArrayValue {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            for msg in &self.values {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ArrayValue";
            match tag {
                1u32 => {
                    let mut value = &mut self.values;
                    ::prost::encoding::message::merge_repeated(
                            wire_type,
                            value,
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "values");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + ::prost::encoding::message::encoded_len_repeated(1u32, &self.values)
        }
        fn clear(&mut self) {
            self.values.clear();
        }
    }
    impl ::core::default::Default for ArrayValue {
        fn default() -> Self {
            ArrayValue {
                values: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for ArrayValue {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ArrayValue");
            let builder = {
                let wrapper = &self.values;
                builder.field("values", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ArrayValue {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "values" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"values" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ArrayValue>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ArrayValue;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ArrayValue",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::vec::Vec<Value>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ArrayValue with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ArrayValue { values: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::prost::alloc::vec::Vec<Value>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("values"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::vec::Vec<Value>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("values")?
                            }
                        };
                        _serde::__private::Ok(ArrayValue { values: __field0 })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["values"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ArrayValue",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ArrayValue>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ArrayValue {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ArrayValue",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "values",
                    &self.values,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// A map value.
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct MapValue {
        /// The map's fields.
        ///
        /// The map keys represent field names. Field names matching the regular
        /// expression `__.*__` are reserved. Reserved field names are forbidden except
        /// in certain documented contexts. The map keys, represented as UTF-8, must
        /// not exceed 1,500 bytes and cannot be empty.
        #[prost(map = "string, message", tag = "1")]
        pub fields: ::std::collections::HashMap<::prost::alloc::string::String, Value>,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for MapValue {
        #[inline]
        fn clone(&self) -> MapValue {
            MapValue {
                fields: ::core::clone::Clone::clone(&self.fields),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for MapValue {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for MapValue {
        #[inline]
        fn eq(&self, other: &MapValue) -> bool {
            self.fields == other.fields
        }
    }
    impl ::prost::Message for MapValue {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            ::prost::encoding::hash_map::encode(
                ::prost::encoding::string::encode,
                ::prost::encoding::string::encoded_len,
                ::prost::encoding::message::encode,
                ::prost::encoding::message::encoded_len,
                1u32,
                &self.fields,
                buf,
            );
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "MapValue";
            match tag {
                1u32 => {
                    let mut value = &mut self.fields;
                    ::prost::encoding::hash_map::merge(
                            ::prost::encoding::string::merge,
                            ::prost::encoding::message::merge,
                            &mut value,
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "fields");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0
                + ::prost::encoding::hash_map::encoded_len(
                    ::prost::encoding::string::encoded_len,
                    ::prost::encoding::message::encoded_len,
                    1u32,
                    &self.fields,
                )
        }
        fn clear(&mut self) {
            self.fields.clear();
        }
    }
    impl ::core::default::Default for MapValue {
        fn default() -> Self {
            MapValue {
                fields: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for MapValue {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("MapValue");
            let builder = {
                let wrapper = {
                    struct MapWrapper<'a, V: 'a>(
                        &'a ::std::collections::HashMap<
                            ::prost::alloc::string::String,
                            V,
                        >,
                    );
                    impl<'a, V> ::core::fmt::Debug for MapWrapper<'a, V>
                    where
                        V: ::core::fmt::Debug + 'a,
                    {
                        fn fmt(
                            &self,
                            f: &mut ::core::fmt::Formatter,
                        ) -> ::core::fmt::Result {
                            #[allow(non_snake_case)]
                            fn KeyWrapper<T>(v: T) -> T {
                                v
                            }
                            fn ValueWrapper<T>(v: T) -> T {
                                v
                            }
                            let mut builder = f.debug_map();
                            for (k, v) in self.0 {
                                builder.entry(&KeyWrapper(k), &ValueWrapper(v));
                            }
                            builder.finish()
                        }
                    }
                    MapWrapper(&self.fields)
                };
                builder.field("fields", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for MapValue {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "fields" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"fields" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<MapValue>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = MapValue;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct MapValue",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::std::collections::HashMap<
                                ::prost::alloc::string::String,
                                Value,
                            >,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct MapValue with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(MapValue { fields: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::std::collections::HashMap<
                                ::prost::alloc::string::String,
                                Value,
                            >,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("fields"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::std::collections::HashMap<
                                                ::prost::alloc::string::String,
                                                Value,
                                            >,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("fields")?
                            }
                        };
                        _serde::__private::Ok(MapValue { fields: __field0 })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["fields"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "MapValue",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<MapValue>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for MapValue {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "MapValue",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "fields",
                    &self.fields,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// The result of a single bucket from a Firestore aggregation query.
    ///
    /// The keys of `aggregate_fields` are the same for all results in an aggregation
    /// query, unlike document queries which can have different fields present for
    /// each result.
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct AggregationResult {
        /// The result of the aggregation functions, ex: `COUNT(*) AS total_docs`.
        ///
        /// The key is the
        /// [alias][google.firestore.v1.StructuredAggregationQuery.Aggregation.alias]
        /// assigned to the aggregation function on input and the size of this map
        /// equals the number of aggregation functions in the query.
        #[prost(map = "string, message", tag = "2")]
        pub aggregate_fields: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            Value,
        >,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for AggregationResult {
        #[inline]
        fn clone(&self) -> AggregationResult {
            AggregationResult {
                aggregate_fields: ::core::clone::Clone::clone(&self.aggregate_fields),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for AggregationResult {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for AggregationResult {
        #[inline]
        fn eq(&self, other: &AggregationResult) -> bool {
            self.aggregate_fields == other.aggregate_fields
        }
    }
    impl ::prost::Message for AggregationResult {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            ::prost::encoding::hash_map::encode(
                ::prost::encoding::string::encode,
                ::prost::encoding::string::encoded_len,
                ::prost::encoding::message::encode,
                ::prost::encoding::message::encoded_len,
                2u32,
                &self.aggregate_fields,
                buf,
            );
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "AggregationResult";
            match tag {
                2u32 => {
                    let mut value = &mut self.aggregate_fields;
                    ::prost::encoding::hash_map::merge(
                            ::prost::encoding::string::merge,
                            ::prost::encoding::message::merge,
                            &mut value,
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "aggregate_fields");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0
                + ::prost::encoding::hash_map::encoded_len(
                    ::prost::encoding::string::encoded_len,
                    ::prost::encoding::message::encoded_len,
                    2u32,
                    &self.aggregate_fields,
                )
        }
        fn clear(&mut self) {
            self.aggregate_fields.clear();
        }
    }
    impl ::core::default::Default for AggregationResult {
        fn default() -> Self {
            AggregationResult {
                aggregate_fields: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for AggregationResult {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("AggregationResult");
            let builder = {
                let wrapper = {
                    struct MapWrapper<'a, V: 'a>(
                        &'a ::std::collections::HashMap<
                            ::prost::alloc::string::String,
                            V,
                        >,
                    );
                    impl<'a, V> ::core::fmt::Debug for MapWrapper<'a, V>
                    where
                        V: ::core::fmt::Debug + 'a,
                    {
                        fn fmt(
                            &self,
                            f: &mut ::core::fmt::Formatter,
                        ) -> ::core::fmt::Result {
                            #[allow(non_snake_case)]
                            fn KeyWrapper<T>(v: T) -> T {
                                v
                            }
                            fn ValueWrapper<T>(v: T) -> T {
                                v
                            }
                            let mut builder = f.debug_map();
                            for (k, v) in self.0 {
                                builder.entry(&KeyWrapper(k), &ValueWrapper(v));
                            }
                            builder.finish()
                        }
                    }
                    MapWrapper(&self.aggregate_fields)
                };
                builder.field("aggregate_fields", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for AggregationResult {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "aggregateFields" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"aggregateFields" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<AggregationResult>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = AggregationResult;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct AggregationResult",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::std::collections::HashMap<
                                ::prost::alloc::string::String,
                                Value,
                            >,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct AggregationResult with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(AggregationResult {
                            aggregate_fields: __field0,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::std::collections::HashMap<
                                ::prost::alloc::string::String,
                                Value,
                            >,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "aggregateFields",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::std::collections::HashMap<
                                                ::prost::alloc::string::String,
                                                Value,
                                            >,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("aggregateFields")?
                            }
                        };
                        _serde::__private::Ok(AggregationResult {
                            aggregate_fields: __field0,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["aggregateFields"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "AggregationResult",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<AggregationResult>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for AggregationResult {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "AggregationResult",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "aggregateFields",
                    &self.aggregate_fields,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// A set of field paths on a document.
    /// Used to restrict a get or update operation on a document to a subset of its
    /// fields.
    /// This is different from standard field masks, as this is always scoped to a
    /// [Document][google.firestore.v1.Document], and takes in account the dynamic
    /// nature of [Value][google.firestore.v1.Value].
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct DocumentMask {
        /// The list of field paths in the mask. See
        /// [Document.fields][google.firestore.v1.Document.fields] for a field path
        /// syntax reference.
        #[prost(string, repeated, tag = "1")]
        pub field_paths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for DocumentMask {
        #[inline]
        fn clone(&self) -> DocumentMask {
            DocumentMask {
                field_paths: ::core::clone::Clone::clone(&self.field_paths),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for DocumentMask {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for DocumentMask {
        #[inline]
        fn eq(&self, other: &DocumentMask) -> bool {
            self.field_paths == other.field_paths
        }
    }
    impl ::prost::Message for DocumentMask {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            ::prost::encoding::string::encode_repeated(1u32, &self.field_paths, buf);
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "DocumentMask";
            match tag {
                1u32 => {
                    let mut value = &mut self.field_paths;
                    ::prost::encoding::string::merge_repeated(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "field_paths");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + ::prost::encoding::string::encoded_len_repeated(1u32, &self.field_paths)
        }
        fn clear(&mut self) {
            self.field_paths.clear();
        }
    }
    impl ::core::default::Default for DocumentMask {
        fn default() -> Self {
            DocumentMask {
                field_paths: ::prost::alloc::vec::Vec::new(),
            }
        }
    }
    impl ::core::fmt::Debug for DocumentMask {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("DocumentMask");
            let builder = {
                let wrapper = {
                    struct ScalarWrapper<'a>(
                        &'a ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                    );
                    impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                        fn fmt(
                            &self,
                            f: &mut ::core::fmt::Formatter,
                        ) -> ::core::fmt::Result {
                            let mut vec_builder = f.debug_list();
                            for v in self.0 {
                                #[allow(non_snake_case)]
                                fn Inner<T>(v: T) -> T {
                                    v
                                }
                                vec_builder.entry(&Inner(v));
                            }
                            vec_builder.finish()
                        }
                    }
                    ScalarWrapper(&self.field_paths)
                };
                builder.field("field_paths", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for DocumentMask {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "fieldPaths" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"fieldPaths" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<DocumentMask>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = DocumentMask;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct DocumentMask",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct DocumentMask with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(DocumentMask {
                            field_paths: __field0,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "fieldPaths",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("fieldPaths")?
                            }
                        };
                        _serde::__private::Ok(DocumentMask {
                            field_paths: __field0,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["fieldPaths"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "DocumentMask",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<DocumentMask>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for DocumentMask {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "DocumentMask",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "fieldPaths",
                    &self.field_paths,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// A precondition on a document, used for conditional operations.
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct Precondition {
        /// The type of precondition.
        #[prost(oneof = "precondition::ConditionType", tags = "1, 2")]
        pub condition_type: ::core::option::Option<precondition::ConditionType>,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for Precondition {
        #[inline]
        fn clone(&self) -> Precondition {
            Precondition {
                condition_type: ::core::clone::Clone::clone(&self.condition_type),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for Precondition {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for Precondition {
        #[inline]
        fn eq(&self, other: &Precondition) -> bool {
            self.condition_type == other.condition_type
        }
    }
    impl ::prost::Message for Precondition {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref oneof) = self.condition_type {
                oneof.encode(buf)
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "Precondition";
            match tag {
                1u32 | 2u32 => {
                    let mut value = &mut self.condition_type;
                    precondition::ConditionType::merge(value, tag, wire_type, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "condition_type");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0
                + self
                    .condition_type
                    .as_ref()
                    .map_or(0, precondition::ConditionType::encoded_len)
        }
        fn clear(&mut self) {
            self.condition_type = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for Precondition {
        fn default() -> Self {
            Precondition {
                condition_type: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for Precondition {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("Precondition");
            let builder = {
                let wrapper = &self.condition_type;
                builder.field("condition_type", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Precondition {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "conditionType" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"conditionType" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Precondition>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Precondition;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Precondition",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<precondition::ConditionType>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Precondition with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Precondition {
                            condition_type: __field0,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::core::option::Option<precondition::ConditionType>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "conditionType",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<precondition::ConditionType>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("conditionType")?
                            }
                        };
                        _serde::__private::Ok(Precondition {
                            condition_type: __field0,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["conditionType"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Precondition",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Precondition>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Precondition {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "Precondition",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "conditionType",
                    &self.condition_type,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// Nested message and enum types in `Precondition`.
    pub mod precondition {
        /// The type of precondition.
        #[serde(rename_all = "camelCase")]
        #[allow(clippy::derive_partial_eq_without_eq)]
        pub enum ConditionType {
            /// When set to `true`, the target document must exist.
            /// When set to `false`, the target document must not exist.
            #[prost(bool, tag = "1")]
            Exists(bool),
            /// When set, the target document must exist and have been last updated at
            /// that time. Timestamp must be microsecond aligned.
            #[prost(message, tag = "2")]
            UpdateTime(super::super::super::protobuf::Timestamp),
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::clone::Clone for ConditionType {
            #[inline]
            fn clone(&self) -> ConditionType {
                match self {
                    ConditionType::Exists(__self_0) => {
                        ConditionType::Exists(::core::clone::Clone::clone(__self_0))
                    }
                    ConditionType::UpdateTime(__self_0) => {
                        ConditionType::UpdateTime(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::marker::StructuralPartialEq for ConditionType {}
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::cmp::PartialEq for ConditionType {
            #[inline]
            fn eq(&self, other: &ConditionType) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
                    && match (self, other) {
                        (
                            ConditionType::Exists(__self_0),
                            ConditionType::Exists(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            ConditionType::UpdateTime(__self_0),
                            ConditionType::UpdateTime(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        impl ConditionType {
            /// Encodes the message to a buffer.
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    ConditionType::Exists(ref value) => {
                        ::prost::encoding::bool::encode(1u32, &*value, buf);
                    }
                    ConditionType::UpdateTime(ref value) => {
                        ::prost::encoding::message::encode(2u32, &*value, buf);
                    }
                }
            }
            /// Decodes an instance of the message from a buffer, and merges it into self.
            pub fn merge<B>(
                field: &mut ::core::option::Option<ConditionType>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag {
                    1u32 => {
                        match field {
                            ::core::option::Option::Some(
                                ConditionType::Exists(ref mut value),
                            ) => {
                                ::prost::encoding::bool::merge(wire_type, value, buf, ctx)
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::bool::merge(wire_type, value, buf, ctx)
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            ConditionType::Exists(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    2u32 => {
                        match field {
                            ::core::option::Option::Some(
                                ConditionType::UpdateTime(ref mut value),
                            ) => {
                                ::prost::encoding::message::merge(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            ConditionType::UpdateTime(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    _ => {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "internal error: entered unreachable code: {0}",
                                format_args!("invalid ConditionType tag: {0}", tag),
                            ),
                        );
                    }
                }
            }
            /// Returns the encoded length of the message without a length delimiter.
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    ConditionType::Exists(ref value) => {
                        ::prost::encoding::bool::encoded_len(1u32, &*value)
                    }
                    ConditionType::UpdateTime(ref value) => {
                        ::prost::encoding::message::encoded_len(2u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for ConditionType {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ConditionType::Exists(ref value) => {
                        let wrapper = {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("Exists").field(&wrapper).finish()
                    }
                    ConditionType::UpdateTime(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("UpdateTime").field(&wrapper).finish()
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ConditionType {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 2",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "exists" => _serde::__private::Ok(__Field::__field0),
                                "updateTime" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"exists" => _serde::__private::Ok(__Field::__field0),
                                b"updateTime" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ConditionType>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ConditionType;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum ConditionType",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            bool,
                                        >(__variant),
                                        ConditionType::Exists,
                                    )
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            super::super::super::protobuf::Timestamp,
                                        >(__variant),
                                        ConditionType::UpdateTime,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &["exists", "updateTime"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "ConditionType",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ConditionType>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ConditionType {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        ConditionType::Exists(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "ConditionType",
                                0u32,
                                "exists",
                                __field0,
                            )
                        }
                        ConditionType::UpdateTime(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "ConditionType",
                                1u32,
                                "updateTime",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
    }
    /// Options for creating a new transaction.
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct TransactionOptions {
        /// The mode of the transaction.
        #[prost(oneof = "transaction_options::Mode", tags = "2, 3")]
        pub mode: ::core::option::Option<transaction_options::Mode>,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for TransactionOptions {
        #[inline]
        fn clone(&self) -> TransactionOptions {
            TransactionOptions {
                mode: ::core::clone::Clone::clone(&self.mode),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for TransactionOptions {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for TransactionOptions {
        #[inline]
        fn eq(&self, other: &TransactionOptions) -> bool {
            self.mode == other.mode
        }
    }
    impl ::prost::Message for TransactionOptions {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref oneof) = self.mode {
                oneof.encode(buf)
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TransactionOptions";
            match tag {
                2u32 | 3u32 => {
                    let mut value = &mut self.mode;
                    transaction_options::Mode::merge(value, tag, wire_type, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "mode");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self.mode.as_ref().map_or(0, transaction_options::Mode::encoded_len)
        }
        fn clear(&mut self) {
            self.mode = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for TransactionOptions {
        fn default() -> Self {
            TransactionOptions {
                mode: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for TransactionOptions {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TransactionOptions");
            let builder = {
                let wrapper = &self.mode;
                builder.field("mode", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TransactionOptions {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "mode" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"mode" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TransactionOptions>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TransactionOptions;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct TransactionOptions",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<transaction_options::Mode>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct TransactionOptions with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(TransactionOptions {
                            mode: __field0,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::core::option::Option<transaction_options::Mode>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("mode"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<transaction_options::Mode>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("mode")?
                            }
                        };
                        _serde::__private::Ok(TransactionOptions {
                            mode: __field0,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["mode"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TransactionOptions",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TransactionOptions>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TransactionOptions {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "TransactionOptions",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "mode",
                    &self.mode,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// Nested message and enum types in `TransactionOptions`.
    pub mod transaction_options {
        /// Options for a transaction that can be used to read and write documents.
        ///
        /// Firestore does not allow 3rd party auth requests to create read-write.
        /// transactions.
        #[serde(rename_all = "camelCase")]
        #[allow(clippy::derive_partial_eq_without_eq)]
        pub struct ReadWrite {
            /// An optional transaction to retry.
            #[prost(bytes = "vec", tag = "1")]
            pub retry_transaction: ::prost::alloc::vec::Vec<u8>,
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::clone::Clone for ReadWrite {
            #[inline]
            fn clone(&self) -> ReadWrite {
                ReadWrite {
                    retry_transaction: ::core::clone::Clone::clone(
                        &self.retry_transaction,
                    ),
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::marker::StructuralPartialEq for ReadWrite {}
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::cmp::PartialEq for ReadWrite {
            #[inline]
            fn eq(&self, other: &ReadWrite) -> bool {
                self.retry_transaction == other.retry_transaction
            }
        }
        impl ::prost::Message for ReadWrite {
            #[allow(unused_variables)]
            fn encode_raw<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                if self.retry_transaction != b"" as &[u8] {
                    ::prost::encoding::bytes::encode(1u32, &self.retry_transaction, buf);
                }
            }
            #[allow(unused_variables)]
            fn merge_field<B>(
                &mut self,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                const STRUCT_NAME: &'static str = "ReadWrite";
                match tag {
                    1u32 => {
                        let mut value = &mut self.retry_transaction;
                        ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                            .map_err(|mut error| {
                                error.push(STRUCT_NAME, "retry_transaction");
                                error
                            })
                    }
                    _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0
                    + if self.retry_transaction != b"" as &[u8] {
                        ::prost::encoding::bytes::encoded_len(
                            1u32,
                            &self.retry_transaction,
                        )
                    } else {
                        0
                    }
            }
            fn clear(&mut self) {
                self.retry_transaction.clear();
            }
        }
        impl ::core::default::Default for ReadWrite {
            fn default() -> Self {
                ReadWrite {
                    retry_transaction: ::core::default::Default::default(),
                }
            }
        }
        impl ::core::fmt::Debug for ReadWrite {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let mut builder = f.debug_struct("ReadWrite");
                let builder = {
                    let wrapper = {
                        #[allow(non_snake_case)]
                        fn ScalarWrapper<T>(v: T) -> T {
                            v
                        }
                        ScalarWrapper(&self.retry_transaction)
                    };
                    builder.field("retry_transaction", &wrapper)
                };
                builder.finish()
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ReadWrite {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "retryTransaction" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"retryTransaction" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ReadWrite>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ReadWrite;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ReadWrite",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                ::prost::alloc::vec::Vec<u8>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct ReadWrite with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(ReadWrite {
                                retry_transaction: __field0,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                ::prost::alloc::vec::Vec<u8>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "retryTransaction",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ::prost::alloc::vec::Vec<u8>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("retryTransaction")?
                                }
                            };
                            _serde::__private::Ok(ReadWrite {
                                retry_transaction: __field0,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["retryTransaction"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "ReadWrite",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ReadWrite>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ReadWrite {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "ReadWrite",
                        false as usize + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "retryTransaction",
                        &self.retry_transaction,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        /// Options for a transaction that can only be used to read documents.
        #[serde(rename_all = "camelCase")]
        #[allow(clippy::derive_partial_eq_without_eq)]
        pub struct ReadOnly {
            /// The consistency mode for this transaction. If not set, defaults to strong
            /// consistency.
            #[prost(oneof = "read_only::ConsistencySelector", tags = "2")]
            pub consistency_selector: ::core::option::Option<
                read_only::ConsistencySelector,
            >,
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::clone::Clone for ReadOnly {
            #[inline]
            fn clone(&self) -> ReadOnly {
                ReadOnly {
                    consistency_selector: ::core::clone::Clone::clone(
                        &self.consistency_selector,
                    ),
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::marker::StructuralPartialEq for ReadOnly {}
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::cmp::PartialEq for ReadOnly {
            #[inline]
            fn eq(&self, other: &ReadOnly) -> bool {
                self.consistency_selector == other.consistency_selector
            }
        }
        impl ::prost::Message for ReadOnly {
            #[allow(unused_variables)]
            fn encode_raw<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                if let Some(ref oneof) = self.consistency_selector {
                    oneof.encode(buf)
                }
            }
            #[allow(unused_variables)]
            fn merge_field<B>(
                &mut self,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                const STRUCT_NAME: &'static str = "ReadOnly";
                match tag {
                    2u32 => {
                        let mut value = &mut self.consistency_selector;
                        read_only::ConsistencySelector::merge(
                                value,
                                tag,
                                wire_type,
                                buf,
                                ctx,
                            )
                            .map_err(|mut error| {
                                error.push(STRUCT_NAME, "consistency_selector");
                                error
                            })
                    }
                    _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0
                    + self
                        .consistency_selector
                        .as_ref()
                        .map_or(0, read_only::ConsistencySelector::encoded_len)
            }
            fn clear(&mut self) {
                self.consistency_selector = ::core::option::Option::None;
            }
        }
        impl ::core::default::Default for ReadOnly {
            fn default() -> Self {
                ReadOnly {
                    consistency_selector: ::core::default::Default::default(),
                }
            }
        }
        impl ::core::fmt::Debug for ReadOnly {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let mut builder = f.debug_struct("ReadOnly");
                let builder = {
                    let wrapper = &self.consistency_selector;
                    builder.field("consistency_selector", &wrapper)
                };
                builder.finish()
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ReadOnly {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "consistencySelector" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"consistencySelector" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ReadOnly>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ReadOnly;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ReadOnly",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                ::core::option::Option<read_only::ConsistencySelector>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct ReadOnly with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(ReadOnly {
                                consistency_selector: __field0,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                ::core::option::Option<read_only::ConsistencySelector>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "consistencySelector",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ::core::option::Option<read_only::ConsistencySelector>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("consistencySelector")?
                                }
                            };
                            _serde::__private::Ok(ReadOnly {
                                consistency_selector: __field0,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["consistencySelector"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "ReadOnly",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ReadOnly>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ReadOnly {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "ReadOnly",
                        false as usize + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "consistencySelector",
                        &self.consistency_selector,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        /// Nested message and enum types in `ReadOnly`.
        pub mod read_only {
            /// The consistency mode for this transaction. If not set, defaults to strong
            /// consistency.
            #[serde(rename_all = "camelCase")]
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub enum ConsistencySelector {
                /// Reads documents at the given time.
                ///
                /// This must be a microsecond precision timestamp within the past one
                /// hour, or if Point-in-Time Recovery is enabled, can additionally be a
                /// whole minute timestamp within the past 7 days.
                #[prost(message, tag = "2")]
                ReadTime(super::super::super::super::protobuf::Timestamp),
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for ConsistencySelector {
                #[inline]
                fn clone(&self) -> ConsistencySelector {
                    match self {
                        ConsistencySelector::ReadTime(__self_0) => {
                            ConsistencySelector::ReadTime(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::marker::StructuralPartialEq for ConsistencySelector {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for ConsistencySelector {
                #[inline]
                fn eq(&self, other: &ConsistencySelector) -> bool {
                    match (self, other) {
                        (
                            ConsistencySelector::ReadTime(__self_0),
                            ConsistencySelector::ReadTime(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                    }
                }
            }
            impl ConsistencySelector {
                /// Encodes the message to a buffer.
                pub fn encode<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    match *self {
                        ConsistencySelector::ReadTime(ref value) => {
                            ::prost::encoding::message::encode(2u32, &*value, buf);
                        }
                    }
                }
                /// Decodes an instance of the message from a buffer, and merges it into self.
                pub fn merge<B>(
                    field: &mut ::core::option::Option<ConsistencySelector>,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    match tag {
                        2u32 => {
                            match field {
                                ::core::option::Option::Some(
                                    ConsistencySelector::ReadTime(ref mut value),
                                ) => {
                                    ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                }
                                _ => {
                                    let mut owned_value = ::core::default::Default::default();
                                    let value = &mut owned_value;
                                    ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                        .map(|_| {
                                            *field = ::core::option::Option::Some(
                                                ConsistencySelector::ReadTime(owned_value),
                                            );
                                        })
                                }
                            }
                        }
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "internal error: entered unreachable code: {0}",
                                    format_args!("invalid ConsistencySelector tag: {0}", tag),
                                ),
                            );
                        }
                    }
                }
                /// Returns the encoded length of the message without a length delimiter.
                #[inline]
                pub fn encoded_len(&self) -> usize {
                    match *self {
                        ConsistencySelector::ReadTime(ref value) => {
                            ::prost::encoding::message::encoded_len(2u32, &*value)
                        }
                    }
                }
            }
            impl ::core::fmt::Debug for ConsistencySelector {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        ConsistencySelector::ReadTime(ref value) => {
                            let wrapper = &*value;
                            f.debug_tuple("ReadTime").field(&wrapper).finish()
                        }
                    }
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for ConsistencySelector {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "variant identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 1",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "readTime" => _serde::__private::Ok(__Field::__field0),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"readTime" => _serde::__private::Ok(__Field::__field0),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<ConsistencySelector>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = ConsistencySelector;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "enum ConsistencySelector",
                                )
                            }
                            fn visit_enum<__A>(
                                self,
                                __data: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::EnumAccess<'de>,
                            {
                                match _serde::de::EnumAccess::variant(__data)? {
                                    (__Field::__field0, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                super::super::super::super::protobuf::Timestamp,
                                            >(__variant),
                                            ConsistencySelector::ReadTime,
                                        )
                                    }
                                }
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] = &["readTime"];
                        _serde::Deserializer::deserialize_enum(
                            __deserializer,
                            "ConsistencySelector",
                            VARIANTS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    ConsistencySelector,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for ConsistencySelector {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        match *self {
                            ConsistencySelector::ReadTime(ref __field0) => {
                                _serde::Serializer::serialize_newtype_variant(
                                    __serializer,
                                    "ConsistencySelector",
                                    0u32,
                                    "readTime",
                                    __field0,
                                )
                            }
                        }
                    }
                }
            };
        }
        /// The mode of the transaction.
        #[serde(rename_all = "camelCase")]
        #[allow(clippy::derive_partial_eq_without_eq)]
        pub enum Mode {
            /// The transaction can only be used for read operations.
            #[prost(message, tag = "2")]
            ReadOnly(ReadOnly),
            /// The transaction can be used for both read and write operations.
            #[prost(message, tag = "3")]
            ReadWrite(ReadWrite),
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::clone::Clone for Mode {
            #[inline]
            fn clone(&self) -> Mode {
                match self {
                    Mode::ReadOnly(__self_0) => {
                        Mode::ReadOnly(::core::clone::Clone::clone(__self_0))
                    }
                    Mode::ReadWrite(__self_0) => {
                        Mode::ReadWrite(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::marker::StructuralPartialEq for Mode {}
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::cmp::PartialEq for Mode {
            #[inline]
            fn eq(&self, other: &Mode) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
                    && match (self, other) {
                        (Mode::ReadOnly(__self_0), Mode::ReadOnly(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Mode::ReadWrite(__self_0), Mode::ReadWrite(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        impl Mode {
            /// Encodes the message to a buffer.
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    Mode::ReadOnly(ref value) => {
                        ::prost::encoding::message::encode(2u32, &*value, buf);
                    }
                    Mode::ReadWrite(ref value) => {
                        ::prost::encoding::message::encode(3u32, &*value, buf);
                    }
                }
            }
            /// Decodes an instance of the message from a buffer, and merges it into self.
            pub fn merge<B>(
                field: &mut ::core::option::Option<Mode>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag {
                    2u32 => {
                        match field {
                            ::core::option::Option::Some(
                                Mode::ReadOnly(ref mut value),
                            ) => {
                                ::prost::encoding::message::merge(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            Mode::ReadOnly(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    3u32 => {
                        match field {
                            ::core::option::Option::Some(
                                Mode::ReadWrite(ref mut value),
                            ) => {
                                ::prost::encoding::message::merge(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            Mode::ReadWrite(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    _ => {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "internal error: entered unreachable code: {0}",
                                format_args!("invalid Mode tag: {0}", tag),
                            ),
                        );
                    }
                }
            }
            /// Returns the encoded length of the message without a length delimiter.
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    Mode::ReadOnly(ref value) => {
                        ::prost::encoding::message::encoded_len(2u32, &*value)
                    }
                    Mode::ReadWrite(ref value) => {
                        ::prost::encoding::message::encoded_len(3u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for Mode {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Mode::ReadOnly(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ReadOnly").field(&wrapper).finish()
                    }
                    Mode::ReadWrite(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ReadWrite").field(&wrapper).finish()
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Mode {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 2",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "readOnly" => _serde::__private::Ok(__Field::__field0),
                                "readWrite" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"readOnly" => _serde::__private::Ok(__Field::__field0),
                                b"readWrite" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Mode>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Mode;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum Mode",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            ReadOnly,
                                        >(__variant),
                                        Mode::ReadOnly,
                                    )
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            ReadWrite,
                                        >(__variant),
                                        Mode::ReadWrite,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &["readOnly", "readWrite"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "Mode",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Mode>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Mode {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        Mode::ReadOnly(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "Mode",
                                0u32,
                                "readOnly",
                                __field0,
                            )
                        }
                        Mode::ReadWrite(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "Mode",
                                1u32,
                                "readWrite",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
    }
    /// A Firestore query.
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct StructuredQuery {
        /// Optional sub-set of the fields to return.
        ///
        /// This acts as a [DocumentMask][google.firestore.v1.DocumentMask] over the
        /// documents returned from a query. When not set, assumes that the caller
        /// wants all fields returned.
        #[prost(message, optional, tag = "1")]
        pub select: ::core::option::Option<structured_query::Projection>,
        /// The collections to query.
        #[prost(message, repeated, tag = "2")]
        pub from: ::prost::alloc::vec::Vec<structured_query::CollectionSelector>,
        /// The filter to apply.
        #[prost(message, optional, tag = "3")]
        pub r#where: ::core::option::Option<structured_query::Filter>,
        /// The order to apply to the query results.
        ///
        /// Firestore allows callers to provide a full ordering, a partial ordering, or
        /// no ordering at all. In all cases, Firestore guarantees a stable ordering
        /// through the following rules:
        ///
        ///   * The `order_by` is required to reference all fields used with an
        ///     inequality filter.
        ///   * All fields that are required to be in the `order_by` but are not already
        ///     present are appended in lexicographical ordering of the field name.
        ///   * If an order on `__name__` is not specified, it is appended by default.
        ///
        /// Fields are appended with the same sort direction as the last order
        /// specified, or 'ASCENDING' if no order was specified. For example:
        ///
        ///   * `ORDER BY a` becomes `ORDER BY a ASC, __name__ ASC`
        ///   * `ORDER BY a DESC` becomes `ORDER BY a DESC, __name__ DESC`
        ///   * `WHERE a > 1` becomes `WHERE a > 1 ORDER BY a ASC, __name__ ASC`
        ///   * `WHERE __name__ > ... AND a > 1` becomes
        ///      `WHERE __name__ > ... AND a > 1 ORDER BY a ASC, __name__ ASC`
        #[prost(message, repeated, tag = "4")]
        pub order_by: ::prost::alloc::vec::Vec<structured_query::Order>,
        /// A potential prefix of a position in the result set to start the query at.
        ///
        /// The ordering of the result set is based on the `ORDER BY` clause of the
        /// original query.
        ///
        /// ```
        /// SELECT * FROM k WHERE a = 1 AND b > 2 ORDER BY b ASC, __name__ ASC;
        /// ```
        ///
        /// This query's results are ordered by `(b ASC, __name__ ASC)`.
        ///
        /// Cursors can reference either the full ordering or a prefix of the location,
        /// though it cannot reference more fields than what are in the provided
        /// `ORDER BY`.
        ///
        /// Continuing off the example above, attaching the following start cursors
        /// will have varying impact:
        ///
        /// - `START BEFORE (2, /k/123)`: start the query right before `a = 1 AND
        ///     b > 2 AND __name__ > /k/123`.
        /// - `START AFTER (10)`: start the query right after `a = 1 AND b > 10`.
        ///
        /// Unlike `OFFSET` which requires scanning over the first N results to skip,
        /// a start cursor allows the query to begin at a logical position. This
        /// position is not required to match an actual result, it will scan forward
        /// from this position to find the next document.
        ///
        /// Requires:
        ///
        /// * The number of values cannot be greater than the number of fields
        ///    specified in the `ORDER BY` clause.
        #[prost(message, optional, tag = "7")]
        pub start_at: ::core::option::Option<Cursor>,
        /// A potential prefix of a position in the result set to end the query at.
        ///
        /// This is similar to `START_AT` but with it controlling the end position
        /// rather than the start position.
        ///
        /// Requires:
        ///
        /// * The number of values cannot be greater than the number of fields
        ///    specified in the `ORDER BY` clause.
        #[prost(message, optional, tag = "8")]
        pub end_at: ::core::option::Option<Cursor>,
        /// The number of documents to skip before returning the first result.
        ///
        /// This applies after the constraints specified by the `WHERE`, `START AT`, &
        /// `END AT` but before the `LIMIT` clause.
        ///
        /// Requires:
        ///
        /// * The value must be greater than or equal to zero if specified.
        #[prost(int32, tag = "6")]
        pub offset: i32,
        /// The maximum number of results to return.
        ///
        /// Applies after all other constraints.
        ///
        /// Requires:
        ///
        /// * The value must be greater than or equal to zero if specified.
        #[prost(message, optional, tag = "5")]
        pub limit: ::core::option::Option<super::super::protobuf::Int32Value>,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for StructuredQuery {
        #[inline]
        fn clone(&self) -> StructuredQuery {
            StructuredQuery {
                select: ::core::clone::Clone::clone(&self.select),
                from: ::core::clone::Clone::clone(&self.from),
                r#where: ::core::clone::Clone::clone(&self.r#where),
                order_by: ::core::clone::Clone::clone(&self.order_by),
                start_at: ::core::clone::Clone::clone(&self.start_at),
                end_at: ::core::clone::Clone::clone(&self.end_at),
                offset: ::core::clone::Clone::clone(&self.offset),
                limit: ::core::clone::Clone::clone(&self.limit),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for StructuredQuery {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for StructuredQuery {
        #[inline]
        fn eq(&self, other: &StructuredQuery) -> bool {
            self.select == other.select && self.from == other.from
                && self.r#where == other.r#where && self.order_by == other.order_by
                && self.start_at == other.start_at && self.end_at == other.end_at
                && self.offset == other.offset && self.limit == other.limit
        }
    }
    impl ::prost::Message for StructuredQuery {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.select {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            for msg in &self.from {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            if let Some(ref msg) = self.r#where {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
            for msg in &self.order_by {
                ::prost::encoding::message::encode(4u32, msg, buf);
            }
            if let Some(ref msg) = self.limit {
                ::prost::encoding::message::encode(5u32, msg, buf);
            }
            if self.offset != 0i32 {
                ::prost::encoding::int32::encode(6u32, &self.offset, buf);
            }
            if let Some(ref msg) = self.start_at {
                ::prost::encoding::message::encode(7u32, msg, buf);
            }
            if let Some(ref msg) = self.end_at {
                ::prost::encoding::message::encode(8u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "StructuredQuery";
            match tag {
                1u32 => {
                    let mut value = &mut self.select;
                    ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "select");
                            error
                        })
                }
                2u32 => {
                    let mut value = &mut self.from;
                    ::prost::encoding::message::merge_repeated(
                            wire_type,
                            value,
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "from");
                            error
                        })
                }
                3u32 => {
                    let mut value = &mut self.r#where;
                    ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "r#where");
                            error
                        })
                }
                4u32 => {
                    let mut value = &mut self.order_by;
                    ::prost::encoding::message::merge_repeated(
                            wire_type,
                            value,
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "order_by");
                            error
                        })
                }
                5u32 => {
                    let mut value = &mut self.limit;
                    ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "limit");
                            error
                        })
                }
                6u32 => {
                    let mut value = &mut self.offset;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "offset");
                            error
                        })
                }
                7u32 => {
                    let mut value = &mut self.start_at;
                    ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "start_at");
                            error
                        })
                }
                8u32 => {
                    let mut value = &mut self.end_at;
                    ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "end_at");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0
                + self
                    .select
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + ::prost::encoding::message::encoded_len_repeated(2u32, &self.from)
                + self
                    .r#where
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(3u32, msg))
                + ::prost::encoding::message::encoded_len_repeated(4u32, &self.order_by)
                + self
                    .limit
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(5u32, msg))
                + if self.offset != 0i32 {
                    ::prost::encoding::int32::encoded_len(6u32, &self.offset)
                } else {
                    0
                }
                + self
                    .start_at
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(7u32, msg))
                + self
                    .end_at
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(8u32, msg))
        }
        fn clear(&mut self) {
            self.select = ::core::option::Option::None;
            self.from.clear();
            self.r#where = ::core::option::Option::None;
            self.order_by.clear();
            self.limit = ::core::option::Option::None;
            self.offset = 0i32;
            self.start_at = ::core::option::Option::None;
            self.end_at = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for StructuredQuery {
        fn default() -> Self {
            StructuredQuery {
                select: ::core::default::Default::default(),
                from: ::core::default::Default::default(),
                r#where: ::core::default::Default::default(),
                order_by: ::core::default::Default::default(),
                limit: ::core::default::Default::default(),
                offset: 0i32,
                start_at: ::core::default::Default::default(),
                end_at: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for StructuredQuery {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("StructuredQuery");
            let builder = {
                let wrapper = &self.select;
                builder.field("select", &wrapper)
            };
            let builder = {
                let wrapper = &self.from;
                builder.field("from", &wrapper)
            };
            let builder = {
                let wrapper = &self.r#where;
                builder.field("r#where", &wrapper)
            };
            let builder = {
                let wrapper = &self.order_by;
                builder.field("order_by", &wrapper)
            };
            let builder = {
                let wrapper = &self.start_at;
                builder.field("start_at", &wrapper)
            };
            let builder = {
                let wrapper = &self.end_at;
                builder.field("end_at", &wrapper)
            };
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.offset)
                };
                builder.field("offset", &wrapper)
            };
            let builder = {
                let wrapper = &self.limit;
                builder.field("limit", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for StructuredQuery {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "select" => _serde::__private::Ok(__Field::__field0),
                            "from" => _serde::__private::Ok(__Field::__field1),
                            "where" => _serde::__private::Ok(__Field::__field2),
                            "orderBy" => _serde::__private::Ok(__Field::__field3),
                            "startAt" => _serde::__private::Ok(__Field::__field4),
                            "endAt" => _serde::__private::Ok(__Field::__field5),
                            "offset" => _serde::__private::Ok(__Field::__field6),
                            "limit" => _serde::__private::Ok(__Field::__field7),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"select" => _serde::__private::Ok(__Field::__field0),
                            b"from" => _serde::__private::Ok(__Field::__field1),
                            b"where" => _serde::__private::Ok(__Field::__field2),
                            b"orderBy" => _serde::__private::Ok(__Field::__field3),
                            b"startAt" => _serde::__private::Ok(__Field::__field4),
                            b"endAt" => _serde::__private::Ok(__Field::__field5),
                            b"offset" => _serde::__private::Ok(__Field::__field6),
                            b"limit" => _serde::__private::Ok(__Field::__field7),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<StructuredQuery>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = StructuredQuery;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct StructuredQuery",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<structured_query::Projection>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct StructuredQuery with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::vec::Vec<
                                structured_query::CollectionSelector,
                            >,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct StructuredQuery with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<structured_query::Filter>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct StructuredQuery with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::vec::Vec<structured_query::Order>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct StructuredQuery with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<Cursor>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct StructuredQuery with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<Cursor>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct StructuredQuery with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            i32,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct StructuredQuery with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field7 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<super::super::protobuf::Int32Value>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct StructuredQuery with 8 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(StructuredQuery {
                            select: __field0,
                            from: __field1,
                            r#where: __field2,
                            order_by: __field3,
                            start_at: __field4,
                            end_at: __field5,
                            offset: __field6,
                            limit: __field7,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::core::option::Option<structured_query::Projection>,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            ::prost::alloc::vec::Vec<
                                structured_query::CollectionSelector,
                            >,
                        > = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            ::core::option::Option<structured_query::Filter>,
                        > = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<
                            ::prost::alloc::vec::Vec<structured_query::Order>,
                        > = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<
                            ::core::option::Option<Cursor>,
                        > = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<
                            ::core::option::Option<Cursor>,
                        > = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<i32> = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<
                            ::core::option::Option<super::super::protobuf::Int32Value>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("select"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<structured_query::Projection>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("from"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::vec::Vec<
                                                structured_query::CollectionSelector,
                                            >,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("where"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<structured_query::Filter>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "orderBy",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::vec::Vec<structured_query::Order>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "startAt",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<Cursor>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("endAt"),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<Cursor>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("offset"),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i32>(&mut __map)?,
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("limit"),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<super::super::protobuf::Int32Value>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("select")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("from")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("where")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("orderBy")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("startAt")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("endAt")?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("offset")?
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("limit")?
                            }
                        };
                        _serde::__private::Ok(StructuredQuery {
                            select: __field0,
                            from: __field1,
                            r#where: __field2,
                            order_by: __field3,
                            start_at: __field4,
                            end_at: __field5,
                            offset: __field6,
                            limit: __field7,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "select",
                    "from",
                    "where",
                    "orderBy",
                    "startAt",
                    "endAt",
                    "offset",
                    "limit",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "StructuredQuery",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<StructuredQuery>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for StructuredQuery {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "StructuredQuery",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "select",
                    &self.select,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "from",
                    &self.from,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "where",
                    &self.r#where,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "orderBy",
                    &self.order_by,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "startAt",
                    &self.start_at,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "endAt",
                    &self.end_at,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "offset",
                    &self.offset,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "limit",
                    &self.limit,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// Nested message and enum types in `StructuredQuery`.
    pub mod structured_query {
        /// A selection of a collection, such as `messages as m1`.
        #[serde(rename_all = "camelCase")]
        #[allow(clippy::derive_partial_eq_without_eq)]
        pub struct CollectionSelector {
            /// The collection ID.
            /// When set, selects only collections with this ID.
            #[prost(string, tag = "2")]
            pub collection_id: ::prost::alloc::string::String,
            /// When false, selects only collections that are immediate children of
            /// the `parent` specified in the containing `RunQueryRequest`.
            /// When true, selects all descendant collections.
            #[prost(bool, tag = "3")]
            pub all_descendants: bool,
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::clone::Clone for CollectionSelector {
            #[inline]
            fn clone(&self) -> CollectionSelector {
                CollectionSelector {
                    collection_id: ::core::clone::Clone::clone(&self.collection_id),
                    all_descendants: ::core::clone::Clone::clone(&self.all_descendants),
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::marker::StructuralPartialEq for CollectionSelector {}
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::cmp::PartialEq for CollectionSelector {
            #[inline]
            fn eq(&self, other: &CollectionSelector) -> bool {
                self.collection_id == other.collection_id
                    && self.all_descendants == other.all_descendants
            }
        }
        impl ::prost::Message for CollectionSelector {
            #[allow(unused_variables)]
            fn encode_raw<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                if self.collection_id != "" {
                    ::prost::encoding::string::encode(2u32, &self.collection_id, buf);
                }
                if self.all_descendants != false {
                    ::prost::encoding::bool::encode(3u32, &self.all_descendants, buf);
                }
            }
            #[allow(unused_variables)]
            fn merge_field<B>(
                &mut self,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                const STRUCT_NAME: &'static str = "CollectionSelector";
                match tag {
                    2u32 => {
                        let mut value = &mut self.collection_id;
                        ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                            .map_err(|mut error| {
                                error.push(STRUCT_NAME, "collection_id");
                                error
                            })
                    }
                    3u32 => {
                        let mut value = &mut self.all_descendants;
                        ::prost::encoding::bool::merge(wire_type, value, buf, ctx)
                            .map_err(|mut error| {
                                error.push(STRUCT_NAME, "all_descendants");
                                error
                            })
                    }
                    _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0
                    + if self.collection_id != "" {
                        ::prost::encoding::string::encoded_len(2u32, &self.collection_id)
                    } else {
                        0
                    }
                    + if self.all_descendants != false {
                        ::prost::encoding::bool::encoded_len(3u32, &self.all_descendants)
                    } else {
                        0
                    }
            }
            fn clear(&mut self) {
                self.collection_id.clear();
                self.all_descendants = false;
            }
        }
        impl ::core::default::Default for CollectionSelector {
            fn default() -> Self {
                CollectionSelector {
                    collection_id: ::prost::alloc::string::String::new(),
                    all_descendants: false,
                }
            }
        }
        impl ::core::fmt::Debug for CollectionSelector {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let mut builder = f.debug_struct("CollectionSelector");
                let builder = {
                    let wrapper = {
                        #[allow(non_snake_case)]
                        fn ScalarWrapper<T>(v: T) -> T {
                            v
                        }
                        ScalarWrapper(&self.collection_id)
                    };
                    builder.field("collection_id", &wrapper)
                };
                let builder = {
                    let wrapper = {
                        #[allow(non_snake_case)]
                        fn ScalarWrapper<T>(v: T) -> T {
                            v
                        }
                        ScalarWrapper(&self.all_descendants)
                    };
                    builder.field("all_descendants", &wrapper)
                };
                builder.finish()
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for CollectionSelector {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "collectionId" => _serde::__private::Ok(__Field::__field0),
                                "allDescendants" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"collectionId" => _serde::__private::Ok(__Field::__field0),
                                b"allDescendants" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<CollectionSelector>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = CollectionSelector;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct CollectionSelector",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                ::prost::alloc::string::String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct CollectionSelector with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                bool,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct CollectionSelector with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(CollectionSelector {
                                collection_id: __field0,
                                all_descendants: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                ::prost::alloc::string::String,
                            > = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<bool> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "collectionId",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ::prost::alloc::string::String,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "allDescendants",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("collectionId")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("allDescendants")?
                                }
                            };
                            _serde::__private::Ok(CollectionSelector {
                                collection_id: __field0,
                                all_descendants: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "collectionId",
                        "allDescendants",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "CollectionSelector",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<CollectionSelector>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for CollectionSelector {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "CollectionSelector",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "collectionId",
                        &self.collection_id,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "allDescendants",
                        &self.all_descendants,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        /// A filter.
        #[serde(rename_all = "camelCase")]
        #[allow(clippy::derive_partial_eq_without_eq)]
        pub struct Filter {
            /// The type of filter.
            #[prost(oneof = "filter::FilterType", tags = "1, 2, 3")]
            pub filter_type: ::core::option::Option<filter::FilterType>,
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::clone::Clone for Filter {
            #[inline]
            fn clone(&self) -> Filter {
                Filter {
                    filter_type: ::core::clone::Clone::clone(&self.filter_type),
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::marker::StructuralPartialEq for Filter {}
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::cmp::PartialEq for Filter {
            #[inline]
            fn eq(&self, other: &Filter) -> bool {
                self.filter_type == other.filter_type
            }
        }
        impl ::prost::Message for Filter {
            #[allow(unused_variables)]
            fn encode_raw<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                if let Some(ref oneof) = self.filter_type {
                    oneof.encode(buf)
                }
            }
            #[allow(unused_variables)]
            fn merge_field<B>(
                &mut self,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                const STRUCT_NAME: &'static str = "Filter";
                match tag {
                    1u32 | 2u32 | 3u32 => {
                        let mut value = &mut self.filter_type;
                        filter::FilterType::merge(value, tag, wire_type, buf, ctx)
                            .map_err(|mut error| {
                                error.push(STRUCT_NAME, "filter_type");
                                error
                            })
                    }
                    _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0 + self.filter_type.as_ref().map_or(0, filter::FilterType::encoded_len)
            }
            fn clear(&mut self) {
                self.filter_type = ::core::option::Option::None;
            }
        }
        impl ::core::default::Default for Filter {
            fn default() -> Self {
                Filter {
                    filter_type: ::core::default::Default::default(),
                }
            }
        }
        impl ::core::fmt::Debug for Filter {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let mut builder = f.debug_struct("Filter");
                let builder = {
                    let wrapper = &self.filter_type;
                    builder.field("filter_type", &wrapper)
                };
                builder.finish()
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Filter {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "filterType" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"filterType" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Filter>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Filter;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Filter",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                ::core::option::Option<filter::FilterType>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Filter with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Filter { filter_type: __field0 })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                ::core::option::Option<filter::FilterType>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "filterType",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ::core::option::Option<filter::FilterType>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("filterType")?
                                }
                            };
                            _serde::__private::Ok(Filter { filter_type: __field0 })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["filterType"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Filter",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Filter>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Filter {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "Filter",
                        false as usize + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "filterType",
                        &self.filter_type,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        /// Nested message and enum types in `Filter`.
        pub mod filter {
            /// The type of filter.
            #[serde(rename_all = "camelCase")]
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub enum FilterType {
                /// A composite filter.
                #[prost(message, tag = "1")]
                CompositeFilter(super::CompositeFilter),
                /// A filter on a document field.
                #[prost(message, tag = "2")]
                FieldFilter(super::FieldFilter),
                /// A filter that takes exactly one argument.
                #[prost(message, tag = "3")]
                UnaryFilter(super::UnaryFilter),
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for FilterType {
                #[inline]
                fn clone(&self) -> FilterType {
                    match self {
                        FilterType::CompositeFilter(__self_0) => {
                            FilterType::CompositeFilter(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        FilterType::FieldFilter(__self_0) => {
                            FilterType::FieldFilter(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        FilterType::UnaryFilter(__self_0) => {
                            FilterType::UnaryFilter(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::marker::StructuralPartialEq for FilterType {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for FilterType {
                #[inline]
                fn eq(&self, other: &FilterType) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                        && match (self, other) {
                            (
                                FilterType::CompositeFilter(__self_0),
                                FilterType::CompositeFilter(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                FilterType::FieldFilter(__self_0),
                                FilterType::FieldFilter(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                FilterType::UnaryFilter(__self_0),
                                FilterType::UnaryFilter(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            _ => unsafe { ::core::intrinsics::unreachable() }
                        }
                }
            }
            impl FilterType {
                /// Encodes the message to a buffer.
                pub fn encode<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    match *self {
                        FilterType::CompositeFilter(ref value) => {
                            ::prost::encoding::message::encode(1u32, &*value, buf);
                        }
                        FilterType::FieldFilter(ref value) => {
                            ::prost::encoding::message::encode(2u32, &*value, buf);
                        }
                        FilterType::UnaryFilter(ref value) => {
                            ::prost::encoding::message::encode(3u32, &*value, buf);
                        }
                    }
                }
                /// Decodes an instance of the message from a buffer, and merges it into self.
                pub fn merge<B>(
                    field: &mut ::core::option::Option<FilterType>,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    match tag {
                        1u32 => {
                            match field {
                                ::core::option::Option::Some(
                                    FilterType::CompositeFilter(ref mut value),
                                ) => {
                                    ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                }
                                _ => {
                                    let mut owned_value = ::core::default::Default::default();
                                    let value = &mut owned_value;
                                    ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                        .map(|_| {
                                            *field = ::core::option::Option::Some(
                                                FilterType::CompositeFilter(owned_value),
                                            );
                                        })
                                }
                            }
                        }
                        2u32 => {
                            match field {
                                ::core::option::Option::Some(
                                    FilterType::FieldFilter(ref mut value),
                                ) => {
                                    ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                }
                                _ => {
                                    let mut owned_value = ::core::default::Default::default();
                                    let value = &mut owned_value;
                                    ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                        .map(|_| {
                                            *field = ::core::option::Option::Some(
                                                FilterType::FieldFilter(owned_value),
                                            );
                                        })
                                }
                            }
                        }
                        3u32 => {
                            match field {
                                ::core::option::Option::Some(
                                    FilterType::UnaryFilter(ref mut value),
                                ) => {
                                    ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                }
                                _ => {
                                    let mut owned_value = ::core::default::Default::default();
                                    let value = &mut owned_value;
                                    ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                        .map(|_| {
                                            *field = ::core::option::Option::Some(
                                                FilterType::UnaryFilter(owned_value),
                                            );
                                        })
                                }
                            }
                        }
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "internal error: entered unreachable code: {0}",
                                    format_args!("invalid FilterType tag: {0}", tag),
                                ),
                            );
                        }
                    }
                }
                /// Returns the encoded length of the message without a length delimiter.
                #[inline]
                pub fn encoded_len(&self) -> usize {
                    match *self {
                        FilterType::CompositeFilter(ref value) => {
                            ::prost::encoding::message::encoded_len(1u32, &*value)
                        }
                        FilterType::FieldFilter(ref value) => {
                            ::prost::encoding::message::encoded_len(2u32, &*value)
                        }
                        FilterType::UnaryFilter(ref value) => {
                            ::prost::encoding::message::encoded_len(3u32, &*value)
                        }
                    }
                }
            }
            impl ::core::fmt::Debug for FilterType {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        FilterType::CompositeFilter(ref value) => {
                            let wrapper = &*value;
                            f.debug_tuple("CompositeFilter").field(&wrapper).finish()
                        }
                        FilterType::FieldFilter(ref value) => {
                            let wrapper = &*value;
                            f.debug_tuple("FieldFilter").field(&wrapper).finish()
                        }
                        FilterType::UnaryFilter(ref value) => {
                            let wrapper = &*value;
                            f.debug_tuple("UnaryFilter").field(&wrapper).finish()
                        }
                    }
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for FilterType {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "variant identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 3",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "compositeFilter" => {
                                        _serde::__private::Ok(__Field::__field0)
                                    }
                                    "fieldFilter" => _serde::__private::Ok(__Field::__field1),
                                    "unaryFilter" => _serde::__private::Ok(__Field::__field2),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"compositeFilter" => {
                                        _serde::__private::Ok(__Field::__field0)
                                    }
                                    b"fieldFilter" => _serde::__private::Ok(__Field::__field1),
                                    b"unaryFilter" => _serde::__private::Ok(__Field::__field2),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<FilterType>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = FilterType;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "enum FilterType",
                                )
                            }
                            fn visit_enum<__A>(
                                self,
                                __data: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::EnumAccess<'de>,
                            {
                                match _serde::de::EnumAccess::variant(__data)? {
                                    (__Field::__field0, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                super::CompositeFilter,
                                            >(__variant),
                                            FilterType::CompositeFilter,
                                        )
                                    }
                                    (__Field::__field1, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                super::FieldFilter,
                                            >(__variant),
                                            FilterType::FieldFilter,
                                        )
                                    }
                                    (__Field::__field2, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                super::UnaryFilter,
                                            >(__variant),
                                            FilterType::UnaryFilter,
                                        )
                                    }
                                }
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] = &[
                            "compositeFilter",
                            "fieldFilter",
                            "unaryFilter",
                        ];
                        _serde::Deserializer::deserialize_enum(
                            __deserializer,
                            "FilterType",
                            VARIANTS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<FilterType>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for FilterType {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        match *self {
                            FilterType::CompositeFilter(ref __field0) => {
                                _serde::Serializer::serialize_newtype_variant(
                                    __serializer,
                                    "FilterType",
                                    0u32,
                                    "compositeFilter",
                                    __field0,
                                )
                            }
                            FilterType::FieldFilter(ref __field0) => {
                                _serde::Serializer::serialize_newtype_variant(
                                    __serializer,
                                    "FilterType",
                                    1u32,
                                    "fieldFilter",
                                    __field0,
                                )
                            }
                            FilterType::UnaryFilter(ref __field0) => {
                                _serde::Serializer::serialize_newtype_variant(
                                    __serializer,
                                    "FilterType",
                                    2u32,
                                    "unaryFilter",
                                    __field0,
                                )
                            }
                        }
                    }
                }
            };
        }
        /// A filter that merges multiple other filters using the given operator.
        #[serde(rename_all = "camelCase")]
        #[allow(clippy::derive_partial_eq_without_eq)]
        pub struct CompositeFilter {
            /// The operator for combining multiple filters.
            #[prost(enumeration = "composite_filter::Operator", tag = "1")]
            pub op: i32,
            /// The list of filters to combine.
            ///
            /// Requires:
            ///
            /// * At least one filter is present.
            #[prost(message, repeated, tag = "2")]
            pub filters: ::prost::alloc::vec::Vec<Filter>,
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::clone::Clone for CompositeFilter {
            #[inline]
            fn clone(&self) -> CompositeFilter {
                CompositeFilter {
                    op: ::core::clone::Clone::clone(&self.op),
                    filters: ::core::clone::Clone::clone(&self.filters),
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::marker::StructuralPartialEq for CompositeFilter {}
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::cmp::PartialEq for CompositeFilter {
            #[inline]
            fn eq(&self, other: &CompositeFilter) -> bool {
                self.op == other.op && self.filters == other.filters
            }
        }
        impl ::prost::Message for CompositeFilter {
            #[allow(unused_variables)]
            fn encode_raw<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                if self.op != composite_filter::Operator::default() as i32 {
                    ::prost::encoding::int32::encode(1u32, &self.op, buf);
                }
                for msg in &self.filters {
                    ::prost::encoding::message::encode(2u32, msg, buf);
                }
            }
            #[allow(unused_variables)]
            fn merge_field<B>(
                &mut self,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                const STRUCT_NAME: &'static str = "CompositeFilter";
                match tag {
                    1u32 => {
                        let mut value = &mut self.op;
                        ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                            .map_err(|mut error| {
                                error.push(STRUCT_NAME, "op");
                                error
                            })
                    }
                    2u32 => {
                        let mut value = &mut self.filters;
                        ::prost::encoding::message::merge_repeated(
                                wire_type,
                                value,
                                buf,
                                ctx,
                            )
                            .map_err(|mut error| {
                                error.push(STRUCT_NAME, "filters");
                                error
                            })
                    }
                    _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0
                    + if self.op != composite_filter::Operator::default() as i32 {
                        ::prost::encoding::int32::encoded_len(1u32, &self.op)
                    } else {
                        0
                    }
                    + ::prost::encoding::message::encoded_len_repeated(
                        2u32,
                        &self.filters,
                    )
            }
            fn clear(&mut self) {
                self.op = composite_filter::Operator::default() as i32;
                self.filters.clear();
            }
        }
        impl ::core::default::Default for CompositeFilter {
            fn default() -> Self {
                CompositeFilter {
                    op: composite_filter::Operator::default() as i32,
                    filters: ::core::default::Default::default(),
                }
            }
        }
        impl ::core::fmt::Debug for CompositeFilter {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let mut builder = f.debug_struct("CompositeFilter");
                let builder = {
                    let wrapper = {
                        struct ScalarWrapper<'a>(&'a i32);
                        impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                            fn fmt(
                                &self,
                                f: &mut ::core::fmt::Formatter,
                            ) -> ::core::fmt::Result {
                                let res: ::core::result::Result<
                                    composite_filter::Operator,
                                    _,
                                > = ::core::convert::TryFrom::try_from(*self.0);
                                match res {
                                    Err(_) => ::core::fmt::Debug::fmt(&self.0, f),
                                    Ok(en) => ::core::fmt::Debug::fmt(&en, f),
                                }
                            }
                        }
                        ScalarWrapper(&self.op)
                    };
                    builder.field("op", &wrapper)
                };
                let builder = {
                    let wrapper = &self.filters;
                    builder.field("filters", &wrapper)
                };
                builder.finish()
            }
        }
        #[allow(dead_code)]
        impl CompositeFilter {
            ///Returns the enum value of `op`, or the default if the field is set to an invalid enum value.
            pub fn op(&self) -> composite_filter::Operator {
                ::core::convert::TryFrom::try_from(self.op)
                    .unwrap_or(composite_filter::Operator::default())
            }
            ///Sets `op` to the provided enum value.
            pub fn set_op(&mut self, value: composite_filter::Operator) {
                self.op = value as i32;
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for CompositeFilter {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "op" => _serde::__private::Ok(__Field::__field0),
                                "filters" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"op" => _serde::__private::Ok(__Field::__field0),
                                b"filters" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<CompositeFilter>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = CompositeFilter;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct CompositeFilter",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                i32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct CompositeFilter with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                ::prost::alloc::vec::Vec<Filter>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct CompositeFilter with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(CompositeFilter {
                                op: __field0,
                                filters: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<i32> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                ::prost::alloc::vec::Vec<Filter>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("op"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<i32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "filters",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ::prost::alloc::vec::Vec<Filter>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("op")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("filters")?
                                }
                            };
                            _serde::__private::Ok(CompositeFilter {
                                op: __field0,
                                filters: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["op", "filters"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "CompositeFilter",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<CompositeFilter>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for CompositeFilter {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "CompositeFilter",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "op",
                        &self.op,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "filters",
                        &self.filters,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        /// Nested message and enum types in `CompositeFilter`.
        pub mod composite_filter {
            /// A composite filter operator.
            #[serde(rename_all = "camelCase")]
            #[repr(i32)]
            pub enum Operator {
                /// Unspecified. This value must not be used.
                Unspecified = 0,
                /// Documents are required to satisfy all of the combined filters.
                And = 1,
                /// Documents are required to satisfy at least one of the combined filters.
                Or = 2,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Operator {
                #[inline]
                fn clone(&self) -> Operator {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Operator {}
            #[automatically_derived]
            impl ::core::fmt::Debug for Operator {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            Operator::Unspecified => "Unspecified",
                            Operator::And => "And",
                            Operator::Or => "Or",
                        },
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Operator {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Operator {
                #[inline]
                fn eq(&self, other: &Operator) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for Operator {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            #[automatically_derived]
            impl ::core::hash::Hash for Operator {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    ::core::hash::Hash::hash(&__self_tag, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for Operator {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &Operator,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for Operator {
                #[inline]
                fn cmp(&self, other: &Operator) -> ::core::cmp::Ordering {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag)
                }
            }
            impl Operator {
                ///Returns `true` if `value` is a variant of `Operator`.
                pub fn is_valid(value: i32) -> bool {
                    match value {
                        0 => true,
                        1 => true,
                        2 => true,
                        _ => false,
                    }
                }
                #[deprecated = "Use the TryFrom<i32> implementation instead"]
                ///Converts an `i32` to a `Operator`, or `None` if `value` is not a valid variant.
                pub fn from_i32(value: i32) -> ::core::option::Option<Operator> {
                    match value {
                        0 => ::core::option::Option::Some(Operator::Unspecified),
                        1 => ::core::option::Option::Some(Operator::And),
                        2 => ::core::option::Option::Some(Operator::Or),
                        _ => ::core::option::Option::None,
                    }
                }
            }
            impl ::core::default::Default for Operator {
                fn default() -> Operator {
                    Operator::Unspecified
                }
            }
            impl ::core::convert::From<Operator> for i32 {
                fn from(value: Operator) -> i32 {
                    value as i32
                }
            }
            impl ::core::convert::TryFrom<i32> for Operator {
                type Error = ::prost::DecodeError;
                fn try_from(
                    value: i32,
                ) -> ::core::result::Result<Operator, ::prost::DecodeError> {
                    match value {
                        0 => ::core::result::Result::Ok(Operator::Unspecified),
                        1 => ::core::result::Result::Ok(Operator::And),
                        2 => ::core::result::Result::Ok(Operator::Or),
                        _ => {
                            ::core::result::Result::Err(
                                ::prost::DecodeError::new("invalid enumeration value"),
                            )
                        }
                    }
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for Operator {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "variant identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 3",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "unspecified" => _serde::__private::Ok(__Field::__field0),
                                    "and" => _serde::__private::Ok(__Field::__field1),
                                    "or" => _serde::__private::Ok(__Field::__field2),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"unspecified" => _serde::__private::Ok(__Field::__field0),
                                    b"and" => _serde::__private::Ok(__Field::__field1),
                                    b"or" => _serde::__private::Ok(__Field::__field2),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<Operator>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Operator;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "enum Operator",
                                )
                            }
                            fn visit_enum<__A>(
                                self,
                                __data: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::EnumAccess<'de>,
                            {
                                match _serde::de::EnumAccess::variant(__data)? {
                                    (__Field::__field0, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(Operator::Unspecified)
                                    }
                                    (__Field::__field1, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(Operator::And)
                                    }
                                    (__Field::__field2, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(Operator::Or)
                                    }
                                }
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] = &[
                            "unspecified",
                            "and",
                            "or",
                        ];
                        _serde::Deserializer::deserialize_enum(
                            __deserializer,
                            "Operator",
                            VARIANTS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Operator>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for Operator {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        match *self {
                            Operator::Unspecified => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "Operator",
                                    0u32,
                                    "unspecified",
                                )
                            }
                            Operator::And => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "Operator",
                                    1u32,
                                    "and",
                                )
                            }
                            Operator::Or => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "Operator",
                                    2u32,
                                    "or",
                                )
                            }
                        }
                    }
                }
            };
            impl Operator {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Operator::Unspecified => "OPERATOR_UNSPECIFIED",
                        Operator::And => "AND",
                        Operator::Or => "OR",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "OPERATOR_UNSPECIFIED" => Some(Self::Unspecified),
                        "AND" => Some(Self::And),
                        "OR" => Some(Self::Or),
                        _ => None,
                    }
                }
            }
        }
        /// A filter on a specific field.
        #[serde(rename_all = "camelCase")]
        #[allow(clippy::derive_partial_eq_without_eq)]
        pub struct FieldFilter {
            /// The field to filter by.
            #[prost(message, optional, tag = "1")]
            pub field: ::core::option::Option<FieldReference>,
            /// The operator to filter by.
            #[prost(enumeration = "field_filter::Operator", tag = "2")]
            pub op: i32,
            /// The value to compare to.
            #[prost(message, optional, tag = "3")]
            pub value: ::core::option::Option<super::Value>,
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::clone::Clone for FieldFilter {
            #[inline]
            fn clone(&self) -> FieldFilter {
                FieldFilter {
                    field: ::core::clone::Clone::clone(&self.field),
                    op: ::core::clone::Clone::clone(&self.op),
                    value: ::core::clone::Clone::clone(&self.value),
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::marker::StructuralPartialEq for FieldFilter {}
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::cmp::PartialEq for FieldFilter {
            #[inline]
            fn eq(&self, other: &FieldFilter) -> bool {
                self.field == other.field && self.op == other.op
                    && self.value == other.value
            }
        }
        impl ::prost::Message for FieldFilter {
            #[allow(unused_variables)]
            fn encode_raw<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                if let Some(ref msg) = self.field {
                    ::prost::encoding::message::encode(1u32, msg, buf);
                }
                if self.op != field_filter::Operator::default() as i32 {
                    ::prost::encoding::int32::encode(2u32, &self.op, buf);
                }
                if let Some(ref msg) = self.value {
                    ::prost::encoding::message::encode(3u32, msg, buf);
                }
            }
            #[allow(unused_variables)]
            fn merge_field<B>(
                &mut self,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                const STRUCT_NAME: &'static str = "FieldFilter";
                match tag {
                    1u32 => {
                        let mut value = &mut self.field;
                        ::prost::encoding::message::merge(
                                wire_type,
                                value.get_or_insert_with(::core::default::Default::default),
                                buf,
                                ctx,
                            )
                            .map_err(|mut error| {
                                error.push(STRUCT_NAME, "field");
                                error
                            })
                    }
                    2u32 => {
                        let mut value = &mut self.op;
                        ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                            .map_err(|mut error| {
                                error.push(STRUCT_NAME, "op");
                                error
                            })
                    }
                    3u32 => {
                        let mut value = &mut self.value;
                        ::prost::encoding::message::merge(
                                wire_type,
                                value.get_or_insert_with(::core::default::Default::default),
                                buf,
                                ctx,
                            )
                            .map_err(|mut error| {
                                error.push(STRUCT_NAME, "value");
                                error
                            })
                    }
                    _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0
                    + self
                        .field
                        .as_ref()
                        .map_or(
                            0,
                            |msg| ::prost::encoding::message::encoded_len(1u32, msg),
                        )
                    + if self.op != field_filter::Operator::default() as i32 {
                        ::prost::encoding::int32::encoded_len(2u32, &self.op)
                    } else {
                        0
                    }
                    + self
                        .value
                        .as_ref()
                        .map_or(
                            0,
                            |msg| ::prost::encoding::message::encoded_len(3u32, msg),
                        )
            }
            fn clear(&mut self) {
                self.field = ::core::option::Option::None;
                self.op = field_filter::Operator::default() as i32;
                self.value = ::core::option::Option::None;
            }
        }
        impl ::core::default::Default for FieldFilter {
            fn default() -> Self {
                FieldFilter {
                    field: ::core::default::Default::default(),
                    op: field_filter::Operator::default() as i32,
                    value: ::core::default::Default::default(),
                }
            }
        }
        impl ::core::fmt::Debug for FieldFilter {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let mut builder = f.debug_struct("FieldFilter");
                let builder = {
                    let wrapper = &self.field;
                    builder.field("field", &wrapper)
                };
                let builder = {
                    let wrapper = {
                        struct ScalarWrapper<'a>(&'a i32);
                        impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                            fn fmt(
                                &self,
                                f: &mut ::core::fmt::Formatter,
                            ) -> ::core::fmt::Result {
                                let res: ::core::result::Result<
                                    field_filter::Operator,
                                    _,
                                > = ::core::convert::TryFrom::try_from(*self.0);
                                match res {
                                    Err(_) => ::core::fmt::Debug::fmt(&self.0, f),
                                    Ok(en) => ::core::fmt::Debug::fmt(&en, f),
                                }
                            }
                        }
                        ScalarWrapper(&self.op)
                    };
                    builder.field("op", &wrapper)
                };
                let builder = {
                    let wrapper = &self.value;
                    builder.field("value", &wrapper)
                };
                builder.finish()
            }
        }
        #[allow(dead_code)]
        impl FieldFilter {
            ///Returns the enum value of `op`, or the default if the field is set to an invalid enum value.
            pub fn op(&self) -> field_filter::Operator {
                ::core::convert::TryFrom::try_from(self.op)
                    .unwrap_or(field_filter::Operator::default())
            }
            ///Sets `op` to the provided enum value.
            pub fn set_op(&mut self, value: field_filter::Operator) {
                self.op = value as i32;
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for FieldFilter {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "field" => _serde::__private::Ok(__Field::__field0),
                                "op" => _serde::__private::Ok(__Field::__field1),
                                "value" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"field" => _serde::__private::Ok(__Field::__field0),
                                b"op" => _serde::__private::Ok(__Field::__field1),
                                b"value" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<FieldFilter>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = FieldFilter;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct FieldFilter",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                ::core::option::Option<FieldReference>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct FieldFilter with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                i32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct FieldFilter with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                ::core::option::Option<super::Value>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct FieldFilter with 3 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(FieldFilter {
                                field: __field0,
                                op: __field1,
                                value: __field2,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                ::core::option::Option<FieldReference>,
                            > = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<i32> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<
                                ::core::option::Option<super::Value>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("field"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ::core::option::Option<FieldReference>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("op"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<i32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("value"),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ::core::option::Option<super::Value>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("field")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("op")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("value")?
                                }
                            };
                            _serde::__private::Ok(FieldFilter {
                                field: __field0,
                                op: __field1,
                                value: __field2,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["field", "op", "value"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "FieldFilter",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<FieldFilter>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for FieldFilter {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "FieldFilter",
                        false as usize + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "field",
                        &self.field,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "op",
                        &self.op,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "value",
                        &self.value,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        /// Nested message and enum types in `FieldFilter`.
        pub mod field_filter {
            /// A field filter operator.
            #[serde(rename_all = "camelCase")]
            #[repr(i32)]
            pub enum Operator {
                /// Unspecified. This value must not be used.
                Unspecified = 0,
                /// The given `field` is less than the given `value`.
                ///
                /// Requires:
                ///
                /// * That `field` come first in `order_by`.
                LessThan = 1,
                /// The given `field` is less than or equal to the given `value`.
                ///
                /// Requires:
                ///
                /// * That `field` come first in `order_by`.
                LessThanOrEqual = 2,
                /// The given `field` is greater than the given `value`.
                ///
                /// Requires:
                ///
                /// * That `field` come first in `order_by`.
                GreaterThan = 3,
                /// The given `field` is greater than or equal to the given `value`.
                ///
                /// Requires:
                ///
                /// * That `field` come first in `order_by`.
                GreaterThanOrEqual = 4,
                /// The given `field` is equal to the given `value`.
                Equal = 5,
                /// The given `field` is not equal to the given `value`.
                ///
                /// Requires:
                ///
                /// * No other `NOT_EQUAL`, `NOT_IN`, `IS_NOT_NULL`, or `IS_NOT_NAN`.
                /// * That `field` comes first in the `order_by`.
                NotEqual = 6,
                /// The given `field` is an array that contains the given `value`.
                ArrayContains = 7,
                /// The given `field` is equal to at least one value in the given array.
                ///
                /// Requires:
                ///
                /// * That `value` is a non-empty `ArrayValue`, subject to disjunction
                ///    limits.
                /// * No `NOT_IN` filters in the same query.
                In = 8,
                /// The given `field` is an array that contains any of the values in the
                /// given array.
                ///
                /// Requires:
                ///
                /// * That `value` is a non-empty `ArrayValue`, subject to disjunction
                ///    limits.
                /// * No other `ARRAY_CONTAINS_ANY` filters within the same disjunction.
                /// * No `NOT_IN` filters in the same query.
                ArrayContainsAny = 9,
                /// The value of the `field` is not in the given array.
                ///
                /// Requires:
                ///
                /// * That `value` is a non-empty `ArrayValue` with at most 10 values.
                /// * No other `OR`, `IN`, `ARRAY_CONTAINS_ANY`, `NOT_IN`, `NOT_EQUAL`,
                ///    `IS_NOT_NULL`, or `IS_NOT_NAN`.
                /// * That `field` comes first in the `order_by`.
                NotIn = 10,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Operator {
                #[inline]
                fn clone(&self) -> Operator {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Operator {}
            #[automatically_derived]
            impl ::core::fmt::Debug for Operator {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            Operator::Unspecified => "Unspecified",
                            Operator::LessThan => "LessThan",
                            Operator::LessThanOrEqual => "LessThanOrEqual",
                            Operator::GreaterThan => "GreaterThan",
                            Operator::GreaterThanOrEqual => "GreaterThanOrEqual",
                            Operator::Equal => "Equal",
                            Operator::NotEqual => "NotEqual",
                            Operator::ArrayContains => "ArrayContains",
                            Operator::In => "In",
                            Operator::ArrayContainsAny => "ArrayContainsAny",
                            Operator::NotIn => "NotIn",
                        },
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Operator {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Operator {
                #[inline]
                fn eq(&self, other: &Operator) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for Operator {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            #[automatically_derived]
            impl ::core::hash::Hash for Operator {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    ::core::hash::Hash::hash(&__self_tag, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for Operator {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &Operator,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for Operator {
                #[inline]
                fn cmp(&self, other: &Operator) -> ::core::cmp::Ordering {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag)
                }
            }
            impl Operator {
                ///Returns `true` if `value` is a variant of `Operator`.
                pub fn is_valid(value: i32) -> bool {
                    match value {
                        0 => true,
                        1 => true,
                        2 => true,
                        3 => true,
                        4 => true,
                        5 => true,
                        6 => true,
                        7 => true,
                        8 => true,
                        9 => true,
                        10 => true,
                        _ => false,
                    }
                }
                #[deprecated = "Use the TryFrom<i32> implementation instead"]
                ///Converts an `i32` to a `Operator`, or `None` if `value` is not a valid variant.
                pub fn from_i32(value: i32) -> ::core::option::Option<Operator> {
                    match value {
                        0 => ::core::option::Option::Some(Operator::Unspecified),
                        1 => ::core::option::Option::Some(Operator::LessThan),
                        2 => ::core::option::Option::Some(Operator::LessThanOrEqual),
                        3 => ::core::option::Option::Some(Operator::GreaterThan),
                        4 => ::core::option::Option::Some(Operator::GreaterThanOrEqual),
                        5 => ::core::option::Option::Some(Operator::Equal),
                        6 => ::core::option::Option::Some(Operator::NotEqual),
                        7 => ::core::option::Option::Some(Operator::ArrayContains),
                        8 => ::core::option::Option::Some(Operator::In),
                        9 => ::core::option::Option::Some(Operator::ArrayContainsAny),
                        10 => ::core::option::Option::Some(Operator::NotIn),
                        _ => ::core::option::Option::None,
                    }
                }
            }
            impl ::core::default::Default for Operator {
                fn default() -> Operator {
                    Operator::Unspecified
                }
            }
            impl ::core::convert::From<Operator> for i32 {
                fn from(value: Operator) -> i32 {
                    value as i32
                }
            }
            impl ::core::convert::TryFrom<i32> for Operator {
                type Error = ::prost::DecodeError;
                fn try_from(
                    value: i32,
                ) -> ::core::result::Result<Operator, ::prost::DecodeError> {
                    match value {
                        0 => ::core::result::Result::Ok(Operator::Unspecified),
                        1 => ::core::result::Result::Ok(Operator::LessThan),
                        2 => ::core::result::Result::Ok(Operator::LessThanOrEqual),
                        3 => ::core::result::Result::Ok(Operator::GreaterThan),
                        4 => ::core::result::Result::Ok(Operator::GreaterThanOrEqual),
                        5 => ::core::result::Result::Ok(Operator::Equal),
                        6 => ::core::result::Result::Ok(Operator::NotEqual),
                        7 => ::core::result::Result::Ok(Operator::ArrayContains),
                        8 => ::core::result::Result::Ok(Operator::In),
                        9 => ::core::result::Result::Ok(Operator::ArrayContainsAny),
                        10 => ::core::result::Result::Ok(Operator::NotIn),
                        _ => {
                            ::core::result::Result::Err(
                                ::prost::DecodeError::new("invalid enumeration value"),
                            )
                        }
                    }
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for Operator {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                            __field5,
                            __field6,
                            __field7,
                            __field8,
                            __field9,
                            __field10,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "variant identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    4u64 => _serde::__private::Ok(__Field::__field4),
                                    5u64 => _serde::__private::Ok(__Field::__field5),
                                    6u64 => _serde::__private::Ok(__Field::__field6),
                                    7u64 => _serde::__private::Ok(__Field::__field7),
                                    8u64 => _serde::__private::Ok(__Field::__field8),
                                    9u64 => _serde::__private::Ok(__Field::__field9),
                                    10u64 => _serde::__private::Ok(__Field::__field10),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 11",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "unspecified" => _serde::__private::Ok(__Field::__field0),
                                    "lessThan" => _serde::__private::Ok(__Field::__field1),
                                    "lessThanOrEqual" => {
                                        _serde::__private::Ok(__Field::__field2)
                                    }
                                    "greaterThan" => _serde::__private::Ok(__Field::__field3),
                                    "greaterThanOrEqual" => {
                                        _serde::__private::Ok(__Field::__field4)
                                    }
                                    "equal" => _serde::__private::Ok(__Field::__field5),
                                    "notEqual" => _serde::__private::Ok(__Field::__field6),
                                    "arrayContains" => _serde::__private::Ok(__Field::__field7),
                                    "in" => _serde::__private::Ok(__Field::__field8),
                                    "arrayContainsAny" => {
                                        _serde::__private::Ok(__Field::__field9)
                                    }
                                    "notIn" => _serde::__private::Ok(__Field::__field10),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"unspecified" => _serde::__private::Ok(__Field::__field0),
                                    b"lessThan" => _serde::__private::Ok(__Field::__field1),
                                    b"lessThanOrEqual" => {
                                        _serde::__private::Ok(__Field::__field2)
                                    }
                                    b"greaterThan" => _serde::__private::Ok(__Field::__field3),
                                    b"greaterThanOrEqual" => {
                                        _serde::__private::Ok(__Field::__field4)
                                    }
                                    b"equal" => _serde::__private::Ok(__Field::__field5),
                                    b"notEqual" => _serde::__private::Ok(__Field::__field6),
                                    b"arrayContains" => _serde::__private::Ok(__Field::__field7),
                                    b"in" => _serde::__private::Ok(__Field::__field8),
                                    b"arrayContainsAny" => {
                                        _serde::__private::Ok(__Field::__field9)
                                    }
                                    b"notIn" => _serde::__private::Ok(__Field::__field10),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<Operator>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Operator;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "enum Operator",
                                )
                            }
                            fn visit_enum<__A>(
                                self,
                                __data: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::EnumAccess<'de>,
                            {
                                match _serde::de::EnumAccess::variant(__data)? {
                                    (__Field::__field0, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(Operator::Unspecified)
                                    }
                                    (__Field::__field1, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(Operator::LessThan)
                                    }
                                    (__Field::__field2, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(Operator::LessThanOrEqual)
                                    }
                                    (__Field::__field3, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(Operator::GreaterThan)
                                    }
                                    (__Field::__field4, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(Operator::GreaterThanOrEqual)
                                    }
                                    (__Field::__field5, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(Operator::Equal)
                                    }
                                    (__Field::__field6, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(Operator::NotEqual)
                                    }
                                    (__Field::__field7, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(Operator::ArrayContains)
                                    }
                                    (__Field::__field8, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(Operator::In)
                                    }
                                    (__Field::__field9, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(Operator::ArrayContainsAny)
                                    }
                                    (__Field::__field10, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(Operator::NotIn)
                                    }
                                }
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] = &[
                            "unspecified",
                            "lessThan",
                            "lessThanOrEqual",
                            "greaterThan",
                            "greaterThanOrEqual",
                            "equal",
                            "notEqual",
                            "arrayContains",
                            "in",
                            "arrayContainsAny",
                            "notIn",
                        ];
                        _serde::Deserializer::deserialize_enum(
                            __deserializer,
                            "Operator",
                            VARIANTS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Operator>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for Operator {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        match *self {
                            Operator::Unspecified => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "Operator",
                                    0u32,
                                    "unspecified",
                                )
                            }
                            Operator::LessThan => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "Operator",
                                    1u32,
                                    "lessThan",
                                )
                            }
                            Operator::LessThanOrEqual => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "Operator",
                                    2u32,
                                    "lessThanOrEqual",
                                )
                            }
                            Operator::GreaterThan => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "Operator",
                                    3u32,
                                    "greaterThan",
                                )
                            }
                            Operator::GreaterThanOrEqual => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "Operator",
                                    4u32,
                                    "greaterThanOrEqual",
                                )
                            }
                            Operator::Equal => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "Operator",
                                    5u32,
                                    "equal",
                                )
                            }
                            Operator::NotEqual => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "Operator",
                                    6u32,
                                    "notEqual",
                                )
                            }
                            Operator::ArrayContains => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "Operator",
                                    7u32,
                                    "arrayContains",
                                )
                            }
                            Operator::In => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "Operator",
                                    8u32,
                                    "in",
                                )
                            }
                            Operator::ArrayContainsAny => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "Operator",
                                    9u32,
                                    "arrayContainsAny",
                                )
                            }
                            Operator::NotIn => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "Operator",
                                    10u32,
                                    "notIn",
                                )
                            }
                        }
                    }
                }
            };
            impl Operator {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Operator::Unspecified => "OPERATOR_UNSPECIFIED",
                        Operator::LessThan => "LESS_THAN",
                        Operator::LessThanOrEqual => "LESS_THAN_OR_EQUAL",
                        Operator::GreaterThan => "GREATER_THAN",
                        Operator::GreaterThanOrEqual => "GREATER_THAN_OR_EQUAL",
                        Operator::Equal => "EQUAL",
                        Operator::NotEqual => "NOT_EQUAL",
                        Operator::ArrayContains => "ARRAY_CONTAINS",
                        Operator::In => "IN",
                        Operator::ArrayContainsAny => "ARRAY_CONTAINS_ANY",
                        Operator::NotIn => "NOT_IN",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "OPERATOR_UNSPECIFIED" => Some(Self::Unspecified),
                        "LESS_THAN" => Some(Self::LessThan),
                        "LESS_THAN_OR_EQUAL" => Some(Self::LessThanOrEqual),
                        "GREATER_THAN" => Some(Self::GreaterThan),
                        "GREATER_THAN_OR_EQUAL" => Some(Self::GreaterThanOrEqual),
                        "EQUAL" => Some(Self::Equal),
                        "NOT_EQUAL" => Some(Self::NotEqual),
                        "ARRAY_CONTAINS" => Some(Self::ArrayContains),
                        "IN" => Some(Self::In),
                        "ARRAY_CONTAINS_ANY" => Some(Self::ArrayContainsAny),
                        "NOT_IN" => Some(Self::NotIn),
                        _ => None,
                    }
                }
            }
        }
        /// A filter with a single operand.
        #[serde(rename_all = "camelCase")]
        #[allow(clippy::derive_partial_eq_without_eq)]
        pub struct UnaryFilter {
            /// The unary operator to apply.
            #[prost(enumeration = "unary_filter::Operator", tag = "1")]
            pub op: i32,
            /// The argument to the filter.
            #[prost(oneof = "unary_filter::OperandType", tags = "2")]
            pub operand_type: ::core::option::Option<unary_filter::OperandType>,
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::clone::Clone for UnaryFilter {
            #[inline]
            fn clone(&self) -> UnaryFilter {
                UnaryFilter {
                    op: ::core::clone::Clone::clone(&self.op),
                    operand_type: ::core::clone::Clone::clone(&self.operand_type),
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::marker::StructuralPartialEq for UnaryFilter {}
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::cmp::PartialEq for UnaryFilter {
            #[inline]
            fn eq(&self, other: &UnaryFilter) -> bool {
                self.op == other.op && self.operand_type == other.operand_type
            }
        }
        impl ::prost::Message for UnaryFilter {
            #[allow(unused_variables)]
            fn encode_raw<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                if self.op != unary_filter::Operator::default() as i32 {
                    ::prost::encoding::int32::encode(1u32, &self.op, buf);
                }
                if let Some(ref oneof) = self.operand_type {
                    oneof.encode(buf)
                }
            }
            #[allow(unused_variables)]
            fn merge_field<B>(
                &mut self,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                const STRUCT_NAME: &'static str = "UnaryFilter";
                match tag {
                    1u32 => {
                        let mut value = &mut self.op;
                        ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                            .map_err(|mut error| {
                                error.push(STRUCT_NAME, "op");
                                error
                            })
                    }
                    2u32 => {
                        let mut value = &mut self.operand_type;
                        unary_filter::OperandType::merge(value, tag, wire_type, buf, ctx)
                            .map_err(|mut error| {
                                error.push(STRUCT_NAME, "operand_type");
                                error
                            })
                    }
                    _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0
                    + if self.op != unary_filter::Operator::default() as i32 {
                        ::prost::encoding::int32::encoded_len(1u32, &self.op)
                    } else {
                        0
                    }
                    + self
                        .operand_type
                        .as_ref()
                        .map_or(0, unary_filter::OperandType::encoded_len)
            }
            fn clear(&mut self) {
                self.op = unary_filter::Operator::default() as i32;
                self.operand_type = ::core::option::Option::None;
            }
        }
        impl ::core::default::Default for UnaryFilter {
            fn default() -> Self {
                UnaryFilter {
                    op: unary_filter::Operator::default() as i32,
                    operand_type: ::core::default::Default::default(),
                }
            }
        }
        impl ::core::fmt::Debug for UnaryFilter {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let mut builder = f.debug_struct("UnaryFilter");
                let builder = {
                    let wrapper = {
                        struct ScalarWrapper<'a>(&'a i32);
                        impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                            fn fmt(
                                &self,
                                f: &mut ::core::fmt::Formatter,
                            ) -> ::core::fmt::Result {
                                let res: ::core::result::Result<
                                    unary_filter::Operator,
                                    _,
                                > = ::core::convert::TryFrom::try_from(*self.0);
                                match res {
                                    Err(_) => ::core::fmt::Debug::fmt(&self.0, f),
                                    Ok(en) => ::core::fmt::Debug::fmt(&en, f),
                                }
                            }
                        }
                        ScalarWrapper(&self.op)
                    };
                    builder.field("op", &wrapper)
                };
                let builder = {
                    let wrapper = &self.operand_type;
                    builder.field("operand_type", &wrapper)
                };
                builder.finish()
            }
        }
        #[allow(dead_code)]
        impl UnaryFilter {
            ///Returns the enum value of `op`, or the default if the field is set to an invalid enum value.
            pub fn op(&self) -> unary_filter::Operator {
                ::core::convert::TryFrom::try_from(self.op)
                    .unwrap_or(unary_filter::Operator::default())
            }
            ///Sets `op` to the provided enum value.
            pub fn set_op(&mut self, value: unary_filter::Operator) {
                self.op = value as i32;
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for UnaryFilter {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "op" => _serde::__private::Ok(__Field::__field0),
                                "operandType" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"op" => _serde::__private::Ok(__Field::__field0),
                                b"operandType" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<UnaryFilter>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = UnaryFilter;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct UnaryFilter",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                i32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct UnaryFilter with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                ::core::option::Option<unary_filter::OperandType>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct UnaryFilter with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(UnaryFilter {
                                op: __field0,
                                operand_type: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<i32> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                ::core::option::Option<unary_filter::OperandType>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("op"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<i32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "operandType",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ::core::option::Option<unary_filter::OperandType>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("op")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("operandType")?
                                }
                            };
                            _serde::__private::Ok(UnaryFilter {
                                op: __field0,
                                operand_type: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["op", "operandType"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "UnaryFilter",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<UnaryFilter>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for UnaryFilter {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "UnaryFilter",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "op",
                        &self.op,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "operandType",
                        &self.operand_type,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        /// Nested message and enum types in `UnaryFilter`.
        pub mod unary_filter {
            /// A unary operator.
            #[serde(rename_all = "camelCase")]
            #[repr(i32)]
            pub enum Operator {
                /// Unspecified. This value must not be used.
                Unspecified = 0,
                /// The given `field` is equal to `NaN`.
                IsNan = 2,
                /// The given `field` is equal to `NULL`.
                IsNull = 3,
                /// The given `field` is not equal to `NaN`.
                ///
                /// Requires:
                ///
                /// * No other `NOT_EQUAL`, `NOT_IN`, `IS_NOT_NULL`, or `IS_NOT_NAN`.
                /// * That `field` comes first in the `order_by`.
                IsNotNan = 4,
                /// The given `field` is not equal to `NULL`.
                ///
                /// Requires:
                ///
                /// * A single `NOT_EQUAL`, `NOT_IN`, `IS_NOT_NULL`, or `IS_NOT_NAN`.
                /// * That `field` comes first in the `order_by`.
                IsNotNull = 5,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Operator {
                #[inline]
                fn clone(&self) -> Operator {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Operator {}
            #[automatically_derived]
            impl ::core::fmt::Debug for Operator {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            Operator::Unspecified => "Unspecified",
                            Operator::IsNan => "IsNan",
                            Operator::IsNull => "IsNull",
                            Operator::IsNotNan => "IsNotNan",
                            Operator::IsNotNull => "IsNotNull",
                        },
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Operator {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Operator {
                #[inline]
                fn eq(&self, other: &Operator) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for Operator {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            #[automatically_derived]
            impl ::core::hash::Hash for Operator {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    ::core::hash::Hash::hash(&__self_tag, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for Operator {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &Operator,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for Operator {
                #[inline]
                fn cmp(&self, other: &Operator) -> ::core::cmp::Ordering {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag)
                }
            }
            impl Operator {
                ///Returns `true` if `value` is a variant of `Operator`.
                pub fn is_valid(value: i32) -> bool {
                    match value {
                        0 => true,
                        2 => true,
                        3 => true,
                        4 => true,
                        5 => true,
                        _ => false,
                    }
                }
                #[deprecated = "Use the TryFrom<i32> implementation instead"]
                ///Converts an `i32` to a `Operator`, or `None` if `value` is not a valid variant.
                pub fn from_i32(value: i32) -> ::core::option::Option<Operator> {
                    match value {
                        0 => ::core::option::Option::Some(Operator::Unspecified),
                        2 => ::core::option::Option::Some(Operator::IsNan),
                        3 => ::core::option::Option::Some(Operator::IsNull),
                        4 => ::core::option::Option::Some(Operator::IsNotNan),
                        5 => ::core::option::Option::Some(Operator::IsNotNull),
                        _ => ::core::option::Option::None,
                    }
                }
            }
            impl ::core::default::Default for Operator {
                fn default() -> Operator {
                    Operator::Unspecified
                }
            }
            impl ::core::convert::From<Operator> for i32 {
                fn from(value: Operator) -> i32 {
                    value as i32
                }
            }
            impl ::core::convert::TryFrom<i32> for Operator {
                type Error = ::prost::DecodeError;
                fn try_from(
                    value: i32,
                ) -> ::core::result::Result<Operator, ::prost::DecodeError> {
                    match value {
                        0 => ::core::result::Result::Ok(Operator::Unspecified),
                        2 => ::core::result::Result::Ok(Operator::IsNan),
                        3 => ::core::result::Result::Ok(Operator::IsNull),
                        4 => ::core::result::Result::Ok(Operator::IsNotNan),
                        5 => ::core::result::Result::Ok(Operator::IsNotNull),
                        _ => {
                            ::core::result::Result::Err(
                                ::prost::DecodeError::new("invalid enumeration value"),
                            )
                        }
                    }
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for Operator {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "variant identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    4u64 => _serde::__private::Ok(__Field::__field4),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 5",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "unspecified" => _serde::__private::Ok(__Field::__field0),
                                    "isNan" => _serde::__private::Ok(__Field::__field1),
                                    "isNull" => _serde::__private::Ok(__Field::__field2),
                                    "isNotNan" => _serde::__private::Ok(__Field::__field3),
                                    "isNotNull" => _serde::__private::Ok(__Field::__field4),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"unspecified" => _serde::__private::Ok(__Field::__field0),
                                    b"isNan" => _serde::__private::Ok(__Field::__field1),
                                    b"isNull" => _serde::__private::Ok(__Field::__field2),
                                    b"isNotNan" => _serde::__private::Ok(__Field::__field3),
                                    b"isNotNull" => _serde::__private::Ok(__Field::__field4),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<Operator>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Operator;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "enum Operator",
                                )
                            }
                            fn visit_enum<__A>(
                                self,
                                __data: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::EnumAccess<'de>,
                            {
                                match _serde::de::EnumAccess::variant(__data)? {
                                    (__Field::__field0, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(Operator::Unspecified)
                                    }
                                    (__Field::__field1, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(Operator::IsNan)
                                    }
                                    (__Field::__field2, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(Operator::IsNull)
                                    }
                                    (__Field::__field3, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(Operator::IsNotNan)
                                    }
                                    (__Field::__field4, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(Operator::IsNotNull)
                                    }
                                }
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] = &[
                            "unspecified",
                            "isNan",
                            "isNull",
                            "isNotNan",
                            "isNotNull",
                        ];
                        _serde::Deserializer::deserialize_enum(
                            __deserializer,
                            "Operator",
                            VARIANTS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Operator>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for Operator {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        match *self {
                            Operator::Unspecified => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "Operator",
                                    0u32,
                                    "unspecified",
                                )
                            }
                            Operator::IsNan => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "Operator",
                                    1u32,
                                    "isNan",
                                )
                            }
                            Operator::IsNull => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "Operator",
                                    2u32,
                                    "isNull",
                                )
                            }
                            Operator::IsNotNan => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "Operator",
                                    3u32,
                                    "isNotNan",
                                )
                            }
                            Operator::IsNotNull => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "Operator",
                                    4u32,
                                    "isNotNull",
                                )
                            }
                        }
                    }
                }
            };
            impl Operator {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Operator::Unspecified => "OPERATOR_UNSPECIFIED",
                        Operator::IsNan => "IS_NAN",
                        Operator::IsNull => "IS_NULL",
                        Operator::IsNotNan => "IS_NOT_NAN",
                        Operator::IsNotNull => "IS_NOT_NULL",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "OPERATOR_UNSPECIFIED" => Some(Self::Unspecified),
                        "IS_NAN" => Some(Self::IsNan),
                        "IS_NULL" => Some(Self::IsNull),
                        "IS_NOT_NAN" => Some(Self::IsNotNan),
                        "IS_NOT_NULL" => Some(Self::IsNotNull),
                        _ => None,
                    }
                }
            }
            /// The argument to the filter.
            #[serde(rename_all = "camelCase")]
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub enum OperandType {
                /// The field to which to apply the operator.
                #[prost(message, tag = "2")]
                Field(super::FieldReference),
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for OperandType {
                #[inline]
                fn clone(&self) -> OperandType {
                    match self {
                        OperandType::Field(__self_0) => {
                            OperandType::Field(::core::clone::Clone::clone(__self_0))
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::marker::StructuralPartialEq for OperandType {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for OperandType {
                #[inline]
                fn eq(&self, other: &OperandType) -> bool {
                    match (self, other) {
                        (OperandType::Field(__self_0), OperandType::Field(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                    }
                }
            }
            impl OperandType {
                /// Encodes the message to a buffer.
                pub fn encode<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    match *self {
                        OperandType::Field(ref value) => {
                            ::prost::encoding::message::encode(2u32, &*value, buf);
                        }
                    }
                }
                /// Decodes an instance of the message from a buffer, and merges it into self.
                pub fn merge<B>(
                    field: &mut ::core::option::Option<OperandType>,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    match tag {
                        2u32 => {
                            match field {
                                ::core::option::Option::Some(
                                    OperandType::Field(ref mut value),
                                ) => {
                                    ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                }
                                _ => {
                                    let mut owned_value = ::core::default::Default::default();
                                    let value = &mut owned_value;
                                    ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                        .map(|_| {
                                            *field = ::core::option::Option::Some(
                                                OperandType::Field(owned_value),
                                            );
                                        })
                                }
                            }
                        }
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "internal error: entered unreachable code: {0}",
                                    format_args!("invalid OperandType tag: {0}", tag),
                                ),
                            );
                        }
                    }
                }
                /// Returns the encoded length of the message without a length delimiter.
                #[inline]
                pub fn encoded_len(&self) -> usize {
                    match *self {
                        OperandType::Field(ref value) => {
                            ::prost::encoding::message::encoded_len(2u32, &*value)
                        }
                    }
                }
            }
            impl ::core::fmt::Debug for OperandType {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        OperandType::Field(ref value) => {
                            let wrapper = &*value;
                            f.debug_tuple("Field").field(&wrapper).finish()
                        }
                    }
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for OperandType {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "variant identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 1",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "field" => _serde::__private::Ok(__Field::__field0),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"field" => _serde::__private::Ok(__Field::__field0),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<OperandType>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = OperandType;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "enum OperandType",
                                )
                            }
                            fn visit_enum<__A>(
                                self,
                                __data: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::EnumAccess<'de>,
                            {
                                match _serde::de::EnumAccess::variant(__data)? {
                                    (__Field::__field0, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                super::FieldReference,
                                            >(__variant),
                                            OperandType::Field,
                                        )
                                    }
                                }
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] = &["field"];
                        _serde::Deserializer::deserialize_enum(
                            __deserializer,
                            "OperandType",
                            VARIANTS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<OperandType>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for OperandType {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        match *self {
                            OperandType::Field(ref __field0) => {
                                _serde::Serializer::serialize_newtype_variant(
                                    __serializer,
                                    "OperandType",
                                    0u32,
                                    "field",
                                    __field0,
                                )
                            }
                        }
                    }
                }
            };
        }
        /// An order on a field.
        #[serde(rename_all = "camelCase")]
        #[allow(clippy::derive_partial_eq_without_eq)]
        pub struct Order {
            /// The field to order by.
            #[prost(message, optional, tag = "1")]
            pub field: ::core::option::Option<FieldReference>,
            /// The direction to order by. Defaults to `ASCENDING`.
            #[prost(enumeration = "Direction", tag = "2")]
            pub direction: i32,
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::clone::Clone for Order {
            #[inline]
            fn clone(&self) -> Order {
                Order {
                    field: ::core::clone::Clone::clone(&self.field),
                    direction: ::core::clone::Clone::clone(&self.direction),
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::marker::StructuralPartialEq for Order {}
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::cmp::PartialEq for Order {
            #[inline]
            fn eq(&self, other: &Order) -> bool {
                self.field == other.field && self.direction == other.direction
            }
        }
        impl ::prost::Message for Order {
            #[allow(unused_variables)]
            fn encode_raw<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                if let Some(ref msg) = self.field {
                    ::prost::encoding::message::encode(1u32, msg, buf);
                }
                if self.direction != Direction::default() as i32 {
                    ::prost::encoding::int32::encode(2u32, &self.direction, buf);
                }
            }
            #[allow(unused_variables)]
            fn merge_field<B>(
                &mut self,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                const STRUCT_NAME: &'static str = "Order";
                match tag {
                    1u32 => {
                        let mut value = &mut self.field;
                        ::prost::encoding::message::merge(
                                wire_type,
                                value.get_or_insert_with(::core::default::Default::default),
                                buf,
                                ctx,
                            )
                            .map_err(|mut error| {
                                error.push(STRUCT_NAME, "field");
                                error
                            })
                    }
                    2u32 => {
                        let mut value = &mut self.direction;
                        ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                            .map_err(|mut error| {
                                error.push(STRUCT_NAME, "direction");
                                error
                            })
                    }
                    _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0
                    + self
                        .field
                        .as_ref()
                        .map_or(
                            0,
                            |msg| ::prost::encoding::message::encoded_len(1u32, msg),
                        )
                    + if self.direction != Direction::default() as i32 {
                        ::prost::encoding::int32::encoded_len(2u32, &self.direction)
                    } else {
                        0
                    }
            }
            fn clear(&mut self) {
                self.field = ::core::option::Option::None;
                self.direction = Direction::default() as i32;
            }
        }
        impl ::core::default::Default for Order {
            fn default() -> Self {
                Order {
                    field: ::core::default::Default::default(),
                    direction: Direction::default() as i32,
                }
            }
        }
        impl ::core::fmt::Debug for Order {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let mut builder = f.debug_struct("Order");
                let builder = {
                    let wrapper = &self.field;
                    builder.field("field", &wrapper)
                };
                let builder = {
                    let wrapper = {
                        struct ScalarWrapper<'a>(&'a i32);
                        impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                            fn fmt(
                                &self,
                                f: &mut ::core::fmt::Formatter,
                            ) -> ::core::fmt::Result {
                                let res: ::core::result::Result<Direction, _> = ::core::convert::TryFrom::try_from(
                                    *self.0,
                                );
                                match res {
                                    Err(_) => ::core::fmt::Debug::fmt(&self.0, f),
                                    Ok(en) => ::core::fmt::Debug::fmt(&en, f),
                                }
                            }
                        }
                        ScalarWrapper(&self.direction)
                    };
                    builder.field("direction", &wrapper)
                };
                builder.finish()
            }
        }
        #[allow(dead_code)]
        impl Order {
            ///Returns the enum value of `direction`, or the default if the field is set to an invalid enum value.
            pub fn direction(&self) -> Direction {
                ::core::convert::TryFrom::try_from(self.direction)
                    .unwrap_or(Direction::default())
            }
            ///Sets `direction` to the provided enum value.
            pub fn set_direction(&mut self, value: Direction) {
                self.direction = value as i32;
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Order {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "field" => _serde::__private::Ok(__Field::__field0),
                                "direction" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"field" => _serde::__private::Ok(__Field::__field0),
                                b"direction" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Order>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Order;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Order",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                ::core::option::Option<FieldReference>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Order with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                i32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Order with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Order {
                                field: __field0,
                                direction: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                ::core::option::Option<FieldReference>,
                            > = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<i32> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("field"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ::core::option::Option<FieldReference>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "direction",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<i32>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("field")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("direction")?
                                }
                            };
                            _serde::__private::Ok(Order {
                                field: __field0,
                                direction: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["field", "direction"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Order",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Order>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Order {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "Order",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "field",
                        &self.field,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "direction",
                        &self.direction,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        /// A reference to a field in a document, ex: `stats.operations`.
        #[serde(rename_all = "camelCase")]
        #[allow(clippy::derive_partial_eq_without_eq)]
        pub struct FieldReference {
            /// A reference to a field in a document.
            ///
            /// Requires:
            ///
            /// * MUST be a dot-delimited (`.`) string of segments, where each segment
            /// conforms to [document field name][google.firestore.v1.Document.fields]
            /// limitations.
            #[prost(string, tag = "2")]
            pub field_path: ::prost::alloc::string::String,
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::clone::Clone for FieldReference {
            #[inline]
            fn clone(&self) -> FieldReference {
                FieldReference {
                    field_path: ::core::clone::Clone::clone(&self.field_path),
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::marker::StructuralPartialEq for FieldReference {}
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::cmp::PartialEq for FieldReference {
            #[inline]
            fn eq(&self, other: &FieldReference) -> bool {
                self.field_path == other.field_path
            }
        }
        impl ::prost::Message for FieldReference {
            #[allow(unused_variables)]
            fn encode_raw<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                if self.field_path != "" {
                    ::prost::encoding::string::encode(2u32, &self.field_path, buf);
                }
            }
            #[allow(unused_variables)]
            fn merge_field<B>(
                &mut self,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                const STRUCT_NAME: &'static str = "FieldReference";
                match tag {
                    2u32 => {
                        let mut value = &mut self.field_path;
                        ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                            .map_err(|mut error| {
                                error.push(STRUCT_NAME, "field_path");
                                error
                            })
                    }
                    _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0
                    + if self.field_path != "" {
                        ::prost::encoding::string::encoded_len(2u32, &self.field_path)
                    } else {
                        0
                    }
            }
            fn clear(&mut self) {
                self.field_path.clear();
            }
        }
        impl ::core::default::Default for FieldReference {
            fn default() -> Self {
                FieldReference {
                    field_path: ::prost::alloc::string::String::new(),
                }
            }
        }
        impl ::core::fmt::Debug for FieldReference {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let mut builder = f.debug_struct("FieldReference");
                let builder = {
                    let wrapper = {
                        #[allow(non_snake_case)]
                        fn ScalarWrapper<T>(v: T) -> T {
                            v
                        }
                        ScalarWrapper(&self.field_path)
                    };
                    builder.field("field_path", &wrapper)
                };
                builder.finish()
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for FieldReference {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "fieldPath" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"fieldPath" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<FieldReference>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = FieldReference;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct FieldReference",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                ::prost::alloc::string::String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct FieldReference with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(FieldReference {
                                field_path: __field0,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                ::prost::alloc::string::String,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "fieldPath",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ::prost::alloc::string::String,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("fieldPath")?
                                }
                            };
                            _serde::__private::Ok(FieldReference {
                                field_path: __field0,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["fieldPath"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "FieldReference",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<FieldReference>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for FieldReference {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "FieldReference",
                        false as usize + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "fieldPath",
                        &self.field_path,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        /// The projection of document's fields to return.
        #[serde(rename_all = "camelCase")]
        #[allow(clippy::derive_partial_eq_without_eq)]
        pub struct Projection {
            /// The fields to return.
            ///
            /// If empty, all fields are returned. To only return the name
            /// of the document, use `\['__name__'\]`.
            #[prost(message, repeated, tag = "2")]
            pub fields: ::prost::alloc::vec::Vec<FieldReference>,
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::clone::Clone for Projection {
            #[inline]
            fn clone(&self) -> Projection {
                Projection {
                    fields: ::core::clone::Clone::clone(&self.fields),
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::marker::StructuralPartialEq for Projection {}
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::cmp::PartialEq for Projection {
            #[inline]
            fn eq(&self, other: &Projection) -> bool {
                self.fields == other.fields
            }
        }
        impl ::prost::Message for Projection {
            #[allow(unused_variables)]
            fn encode_raw<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                for msg in &self.fields {
                    ::prost::encoding::message::encode(2u32, msg, buf);
                }
            }
            #[allow(unused_variables)]
            fn merge_field<B>(
                &mut self,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                const STRUCT_NAME: &'static str = "Projection";
                match tag {
                    2u32 => {
                        let mut value = &mut self.fields;
                        ::prost::encoding::message::merge_repeated(
                                wire_type,
                                value,
                                buf,
                                ctx,
                            )
                            .map_err(|mut error| {
                                error.push(STRUCT_NAME, "fields");
                                error
                            })
                    }
                    _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0 + ::prost::encoding::message::encoded_len_repeated(2u32, &self.fields)
            }
            fn clear(&mut self) {
                self.fields.clear();
            }
        }
        impl ::core::default::Default for Projection {
            fn default() -> Self {
                Projection {
                    fields: ::core::default::Default::default(),
                }
            }
        }
        impl ::core::fmt::Debug for Projection {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let mut builder = f.debug_struct("Projection");
                let builder = {
                    let wrapper = &self.fields;
                    builder.field("fields", &wrapper)
                };
                builder.finish()
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Projection {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "fields" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"fields" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Projection>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Projection;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Projection",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                ::prost::alloc::vec::Vec<FieldReference>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Projection with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Projection { fields: __field0 })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                ::prost::alloc::vec::Vec<FieldReference>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("fields"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ::prost::alloc::vec::Vec<FieldReference>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("fields")?
                                }
                            };
                            _serde::__private::Ok(Projection { fields: __field0 })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["fields"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Projection",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Projection>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Projection {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "Projection",
                        false as usize + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "fields",
                        &self.fields,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        /// A sort direction.
        #[serde(rename_all = "camelCase")]
        #[repr(i32)]
        pub enum Direction {
            /// Unspecified.
            Unspecified = 0,
            /// Ascending.
            Ascending = 1,
            /// Descending.
            Descending = 2,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Direction {
            #[inline]
            fn clone(&self) -> Direction {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Direction {}
        #[automatically_derived]
        impl ::core::fmt::Debug for Direction {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        Direction::Unspecified => "Unspecified",
                        Direction::Ascending => "Ascending",
                        Direction::Descending => "Descending",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Direction {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Direction {
            #[inline]
            fn eq(&self, other: &Direction) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for Direction {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for Direction {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_tag, state)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for Direction {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Direction,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for Direction {
            #[inline]
            fn cmp(&self, other: &Direction) -> ::core::cmp::Ordering {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag)
            }
        }
        impl Direction {
            ///Returns `true` if `value` is a variant of `Direction`.
            pub fn is_valid(value: i32) -> bool {
                match value {
                    0 => true,
                    1 => true,
                    2 => true,
                    _ => false,
                }
            }
            #[deprecated = "Use the TryFrom<i32> implementation instead"]
            ///Converts an `i32` to a `Direction`, or `None` if `value` is not a valid variant.
            pub fn from_i32(value: i32) -> ::core::option::Option<Direction> {
                match value {
                    0 => ::core::option::Option::Some(Direction::Unspecified),
                    1 => ::core::option::Option::Some(Direction::Ascending),
                    2 => ::core::option::Option::Some(Direction::Descending),
                    _ => ::core::option::Option::None,
                }
            }
        }
        impl ::core::default::Default for Direction {
            fn default() -> Direction {
                Direction::Unspecified
            }
        }
        impl ::core::convert::From<Direction> for i32 {
            fn from(value: Direction) -> i32 {
                value as i32
            }
        }
        impl ::core::convert::TryFrom<i32> for Direction {
            type Error = ::prost::DecodeError;
            fn try_from(
                value: i32,
            ) -> ::core::result::Result<Direction, ::prost::DecodeError> {
                match value {
                    0 => ::core::result::Result::Ok(Direction::Unspecified),
                    1 => ::core::result::Result::Ok(Direction::Ascending),
                    2 => ::core::result::Result::Ok(Direction::Descending),
                    _ => {
                        ::core::result::Result::Err(
                            ::prost::DecodeError::new("invalid enumeration value"),
                        )
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Direction {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 3",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "unspecified" => _serde::__private::Ok(__Field::__field0),
                                "ascending" => _serde::__private::Ok(__Field::__field1),
                                "descending" => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"unspecified" => _serde::__private::Ok(__Field::__field0),
                                b"ascending" => _serde::__private::Ok(__Field::__field1),
                                b"descending" => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Direction>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Direction;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum Direction",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(Direction::Unspecified)
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(Direction::Ascending)
                                }
                                (__Field::__field2, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(Direction::Descending)
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "unspecified",
                        "ascending",
                        "descending",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "Direction",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Direction>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Direction {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        Direction::Unspecified => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "Direction",
                                0u32,
                                "unspecified",
                            )
                        }
                        Direction::Ascending => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "Direction",
                                1u32,
                                "ascending",
                            )
                        }
                        Direction::Descending => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "Direction",
                                2u32,
                                "descending",
                            )
                        }
                    }
                }
            }
        };
        impl Direction {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Direction::Unspecified => "DIRECTION_UNSPECIFIED",
                    Direction::Ascending => "ASCENDING",
                    Direction::Descending => "DESCENDING",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "DIRECTION_UNSPECIFIED" => Some(Self::Unspecified),
                    "ASCENDING" => Some(Self::Ascending),
                    "DESCENDING" => Some(Self::Descending),
                    _ => None,
                }
            }
        }
    }
    /// Firestore query for running an aggregation over a
    /// [StructuredQuery][google.firestore.v1.StructuredQuery].
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct StructuredAggregationQuery {
        /// Optional. Series of aggregations to apply over the results of the
        /// `structured_query`.
        ///
        /// Requires:
        ///
        /// * A minimum of one and maximum of five aggregations per query.
        #[prost(message, repeated, tag = "3")]
        pub aggregations: ::prost::alloc::vec::Vec<
            structured_aggregation_query::Aggregation,
        >,
        /// The base query to aggregate over.
        #[prost(oneof = "structured_aggregation_query::QueryType", tags = "1")]
        pub query_type: ::core::option::Option<structured_aggregation_query::QueryType>,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for StructuredAggregationQuery {
        #[inline]
        fn clone(&self) -> StructuredAggregationQuery {
            StructuredAggregationQuery {
                aggregations: ::core::clone::Clone::clone(&self.aggregations),
                query_type: ::core::clone::Clone::clone(&self.query_type),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for StructuredAggregationQuery {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for StructuredAggregationQuery {
        #[inline]
        fn eq(&self, other: &StructuredAggregationQuery) -> bool {
            self.aggregations == other.aggregations
                && self.query_type == other.query_type
        }
    }
    impl ::prost::Message for StructuredAggregationQuery {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref oneof) = self.query_type {
                oneof.encode(buf)
            }
            for msg in &self.aggregations {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "StructuredAggregationQuery";
            match tag {
                1u32 => {
                    let mut value = &mut self.query_type;
                    structured_aggregation_query::QueryType::merge(
                            value,
                            tag,
                            wire_type,
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "query_type");
                            error
                        })
                }
                3u32 => {
                    let mut value = &mut self.aggregations;
                    ::prost::encoding::message::merge_repeated(
                            wire_type,
                            value,
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "aggregations");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0
                + self
                    .query_type
                    .as_ref()
                    .map_or(0, structured_aggregation_query::QueryType::encoded_len)
                + ::prost::encoding::message::encoded_len_repeated(
                    3u32,
                    &self.aggregations,
                )
        }
        fn clear(&mut self) {
            self.query_type = ::core::option::Option::None;
            self.aggregations.clear();
        }
    }
    impl ::core::default::Default for StructuredAggregationQuery {
        fn default() -> Self {
            StructuredAggregationQuery {
                query_type: ::core::default::Default::default(),
                aggregations: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for StructuredAggregationQuery {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("StructuredAggregationQuery");
            let builder = {
                let wrapper = &self.aggregations;
                builder.field("aggregations", &wrapper)
            };
            let builder = {
                let wrapper = &self.query_type;
                builder.field("query_type", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for StructuredAggregationQuery {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "aggregations" => _serde::__private::Ok(__Field::__field0),
                            "queryType" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"aggregations" => _serde::__private::Ok(__Field::__field0),
                            b"queryType" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<StructuredAggregationQuery>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = StructuredAggregationQuery;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct StructuredAggregationQuery",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::vec::Vec<
                                structured_aggregation_query::Aggregation,
                            >,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct StructuredAggregationQuery with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<
                                structured_aggregation_query::QueryType,
                            >,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct StructuredAggregationQuery with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(StructuredAggregationQuery {
                            aggregations: __field0,
                            query_type: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::prost::alloc::vec::Vec<
                                structured_aggregation_query::Aggregation,
                            >,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            ::core::option::Option<
                                structured_aggregation_query::QueryType,
                            >,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "aggregations",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::vec::Vec<
                                                structured_aggregation_query::Aggregation,
                                            >,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "queryType",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<
                                                structured_aggregation_query::QueryType,
                                            >,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("aggregations")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("queryType")?
                            }
                        };
                        _serde::__private::Ok(StructuredAggregationQuery {
                            aggregations: __field0,
                            query_type: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["aggregations", "queryType"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "StructuredAggregationQuery",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            StructuredAggregationQuery,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for StructuredAggregationQuery {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "StructuredAggregationQuery",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "aggregations",
                    &self.aggregations,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "queryType",
                    &self.query_type,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// Nested message and enum types in `StructuredAggregationQuery`.
    pub mod structured_aggregation_query {
        /// Defines an aggregation that produces a single result.
        #[serde(rename_all = "camelCase")]
        #[allow(clippy::derive_partial_eq_without_eq)]
        pub struct Aggregation {
            /// Optional. Optional name of the field to store the result of the
            /// aggregation into.
            ///
            /// If not provided, Firestore will pick a default name following the format
            /// `field_<incremental_id++>`. For example:
            ///
            /// ```
            /// AGGREGATE
            ///    COUNT_UP_TO(1) AS count_up_to_1,
            ///    COUNT_UP_TO(2),
            ///    COUNT_UP_TO(3) AS count_up_to_3,
            ///    COUNT(*)
            /// OVER (
            ///    ...
            /// );
            /// ```
            ///
            /// becomes:
            ///
            /// ```
            /// AGGREGATE
            ///    COUNT_UP_TO(1) AS count_up_to_1,
            ///    COUNT_UP_TO(2) AS field_1,
            ///    COUNT_UP_TO(3) AS count_up_to_3,
            ///    COUNT(*) AS field_2
            /// OVER (
            ///    ...
            /// );
            /// ```
            ///
            /// Requires:
            ///
            /// * Must be unique across all aggregation aliases.
            /// * Conform to [document field name][google.firestore.v1.Document.fields]
            /// limitations.
            #[prost(string, tag = "7")]
            pub alias: ::prost::alloc::string::String,
            /// The type of aggregation to perform, required.
            #[prost(oneof = "aggregation::Operator", tags = "1, 2, 3")]
            pub operator: ::core::option::Option<aggregation::Operator>,
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::clone::Clone for Aggregation {
            #[inline]
            fn clone(&self) -> Aggregation {
                Aggregation {
                    alias: ::core::clone::Clone::clone(&self.alias),
                    operator: ::core::clone::Clone::clone(&self.operator),
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::marker::StructuralPartialEq for Aggregation {}
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::cmp::PartialEq for Aggregation {
            #[inline]
            fn eq(&self, other: &Aggregation) -> bool {
                self.alias == other.alias && self.operator == other.operator
            }
        }
        impl ::prost::Message for Aggregation {
            #[allow(unused_variables)]
            fn encode_raw<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                if let Some(ref oneof) = self.operator {
                    oneof.encode(buf)
                }
                if self.alias != "" {
                    ::prost::encoding::string::encode(7u32, &self.alias, buf);
                }
            }
            #[allow(unused_variables)]
            fn merge_field<B>(
                &mut self,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                const STRUCT_NAME: &'static str = "Aggregation";
                match tag {
                    1u32 | 2u32 | 3u32 => {
                        let mut value = &mut self.operator;
                        aggregation::Operator::merge(value, tag, wire_type, buf, ctx)
                            .map_err(|mut error| {
                                error.push(STRUCT_NAME, "operator");
                                error
                            })
                    }
                    7u32 => {
                        let mut value = &mut self.alias;
                        ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                            .map_err(|mut error| {
                                error.push(STRUCT_NAME, "alias");
                                error
                            })
                    }
                    _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0 + self.operator.as_ref().map_or(0, aggregation::Operator::encoded_len)
                    + if self.alias != "" {
                        ::prost::encoding::string::encoded_len(7u32, &self.alias)
                    } else {
                        0
                    }
            }
            fn clear(&mut self) {
                self.operator = ::core::option::Option::None;
                self.alias.clear();
            }
        }
        impl ::core::default::Default for Aggregation {
            fn default() -> Self {
                Aggregation {
                    operator: ::core::default::Default::default(),
                    alias: ::prost::alloc::string::String::new(),
                }
            }
        }
        impl ::core::fmt::Debug for Aggregation {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let mut builder = f.debug_struct("Aggregation");
                let builder = {
                    let wrapper = {
                        #[allow(non_snake_case)]
                        fn ScalarWrapper<T>(v: T) -> T {
                            v
                        }
                        ScalarWrapper(&self.alias)
                    };
                    builder.field("alias", &wrapper)
                };
                let builder = {
                    let wrapper = &self.operator;
                    builder.field("operator", &wrapper)
                };
                builder.finish()
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Aggregation {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "alias" => _serde::__private::Ok(__Field::__field0),
                                "operator" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"alias" => _serde::__private::Ok(__Field::__field0),
                                b"operator" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Aggregation>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Aggregation;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Aggregation",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                ::prost::alloc::string::String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Aggregation with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                ::core::option::Option<aggregation::Operator>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Aggregation with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Aggregation {
                                alias: __field0,
                                operator: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                ::prost::alloc::string::String,
                            > = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                ::core::option::Option<aggregation::Operator>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("alias"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ::prost::alloc::string::String,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "operator",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ::core::option::Option<aggregation::Operator>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("alias")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("operator")?
                                }
                            };
                            _serde::__private::Ok(Aggregation {
                                alias: __field0,
                                operator: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["alias", "operator"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Aggregation",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Aggregation>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Aggregation {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "Aggregation",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "alias",
                        &self.alias,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "operator",
                        &self.operator,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        /// Nested message and enum types in `Aggregation`.
        pub mod aggregation {
            /// Count of documents that match the query.
            ///
            /// The `COUNT(*)` aggregation function operates on the entire document
            /// so it does not require a field reference.
            #[serde(rename_all = "camelCase")]
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct Count {
                /// Optional. Optional constraint on the maximum number of documents to
                /// count.
                ///
                /// This provides a way to set an upper bound on the number of documents
                /// to scan, limiting latency, and cost.
                ///
                /// Unspecified is interpreted as no bound.
                ///
                /// High-Level Example:
                ///
                /// ```
                /// AGGREGATE COUNT_UP_TO(1000) OVER ( SELECT * FROM k );
                /// ```
                ///
                /// Requires:
                ///
                /// * Must be greater than zero when present.
                #[prost(message, optional, tag = "1")]
                pub up_to: ::core::option::Option<
                    super::super::super::super::protobuf::Int64Value,
                >,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for Count {
                #[inline]
                fn clone(&self) -> Count {
                    Count {
                        up_to: ::core::clone::Clone::clone(&self.up_to),
                    }
                }
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::marker::StructuralPartialEq for Count {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for Count {
                #[inline]
                fn eq(&self, other: &Count) -> bool {
                    self.up_to == other.up_to
                }
            }
            impl ::prost::Message for Count {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if let Some(ref msg) = self.up_to {
                        ::prost::encoding::message::encode(1u32, msg, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "Count";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.up_to;
                            ::prost::encoding::message::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "up_to");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + self
                            .up_to
                            .as_ref()
                            .map_or(
                                0,
                                |msg| ::prost::encoding::message::encoded_len(1u32, msg),
                            )
                }
                fn clear(&mut self) {
                    self.up_to = ::core::option::Option::None;
                }
            }
            impl ::core::default::Default for Count {
                fn default() -> Self {
                    Count {
                        up_to: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for Count {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("Count");
                    let builder = {
                        let wrapper = &self.up_to;
                        builder.field("up_to", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for Count {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "upTo" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"upTo" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<Count>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Count;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct Count",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    ::core::option::Option<
                                        super::super::super::super::protobuf::Int64Value,
                                    >,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct Count with 1 element",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(Count { up_to: __field0 })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<
                                    ::core::option::Option<
                                        super::super::super::super::protobuf::Int64Value,
                                    >,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("upTo"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    ::core::option::Option<
                                                        super::super::super::super::protobuf::Int64Value,
                                                    >,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("upTo")?
                                    }
                                };
                                _serde::__private::Ok(Count { up_to: __field0 })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["upTo"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "Count",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Count>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for Count {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "Count",
                            false as usize + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "upTo",
                            &self.up_to,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            /// Sum of the values of the requested field.
            ///
            /// * Only numeric values will be aggregated. All non-numeric values
            /// including `NULL` are skipped.
            ///
            /// * If the aggregated values contain `NaN`, returns `NaN`. Infinity math
            /// follows IEEE-754 standards.
            ///
            /// * If the aggregated value set is empty, returns 0.
            ///
            /// * Returns a 64-bit integer if all aggregated numbers are integers and the
            /// sum result does not overflow. Otherwise, the result is returned as a
            /// double. Note that even if all the aggregated values are integers, the
            /// result is returned as a double if it cannot fit within a 64-bit signed
            /// integer. When this occurs, the returned value will lose precision.
            ///
            /// * When underflow occurs, floating-point aggregation is non-deterministic.
            /// This means that running the same query repeatedly without any changes to
            /// the underlying values could produce slightly different results each
            /// time. In those cases, values should be stored as integers over
            /// floating-point numbers.
            #[serde(rename_all = "camelCase")]
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct Sum {
                /// The field to aggregate on.
                #[prost(message, optional, tag = "1")]
                pub field: ::core::option::Option<
                    super::super::structured_query::FieldReference,
                >,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for Sum {
                #[inline]
                fn clone(&self) -> Sum {
                    Sum {
                        field: ::core::clone::Clone::clone(&self.field),
                    }
                }
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::marker::StructuralPartialEq for Sum {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for Sum {
                #[inline]
                fn eq(&self, other: &Sum) -> bool {
                    self.field == other.field
                }
            }
            impl ::prost::Message for Sum {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if let Some(ref msg) = self.field {
                        ::prost::encoding::message::encode(1u32, msg, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "Sum";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.field;
                            ::prost::encoding::message::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "field");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + self
                            .field
                            .as_ref()
                            .map_or(
                                0,
                                |msg| ::prost::encoding::message::encoded_len(1u32, msg),
                            )
                }
                fn clear(&mut self) {
                    self.field = ::core::option::Option::None;
                }
            }
            impl ::core::default::Default for Sum {
                fn default() -> Self {
                    Sum {
                        field: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for Sum {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("Sum");
                    let builder = {
                        let wrapper = &self.field;
                        builder.field("field", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for Sum {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "field" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"field" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<Sum>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Sum;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct Sum",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    ::core::option::Option<
                                        super::super::structured_query::FieldReference,
                                    >,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct Sum with 1 element",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(Sum { field: __field0 })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<
                                    ::core::option::Option<
                                        super::super::structured_query::FieldReference,
                                    >,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("field"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    ::core::option::Option<
                                                        super::super::structured_query::FieldReference,
                                                    >,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("field")?
                                    }
                                };
                                _serde::__private::Ok(Sum { field: __field0 })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["field"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "Sum",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Sum>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for Sum {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "Sum",
                            false as usize + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "field",
                            &self.field,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            /// Average of the values of the requested field.
            ///
            /// * Only numeric values will be aggregated. All non-numeric values
            /// including `NULL` are skipped.
            ///
            /// * If the aggregated values contain `NaN`, returns `NaN`. Infinity math
            /// follows IEEE-754 standards.
            ///
            /// * If the aggregated value set is empty, returns `NULL`.
            ///
            /// * Always returns the result as a double.
            #[serde(rename_all = "camelCase")]
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct Avg {
                /// The field to aggregate on.
                #[prost(message, optional, tag = "1")]
                pub field: ::core::option::Option<
                    super::super::structured_query::FieldReference,
                >,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for Avg {
                #[inline]
                fn clone(&self) -> Avg {
                    Avg {
                        field: ::core::clone::Clone::clone(&self.field),
                    }
                }
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::marker::StructuralPartialEq for Avg {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for Avg {
                #[inline]
                fn eq(&self, other: &Avg) -> bool {
                    self.field == other.field
                }
            }
            impl ::prost::Message for Avg {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if let Some(ref msg) = self.field {
                        ::prost::encoding::message::encode(1u32, msg, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "Avg";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.field;
                            ::prost::encoding::message::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "field");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + self
                            .field
                            .as_ref()
                            .map_or(
                                0,
                                |msg| ::prost::encoding::message::encoded_len(1u32, msg),
                            )
                }
                fn clear(&mut self) {
                    self.field = ::core::option::Option::None;
                }
            }
            impl ::core::default::Default for Avg {
                fn default() -> Self {
                    Avg {
                        field: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for Avg {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("Avg");
                    let builder = {
                        let wrapper = &self.field;
                        builder.field("field", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for Avg {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "field" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"field" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<Avg>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Avg;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct Avg",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    ::core::option::Option<
                                        super::super::structured_query::FieldReference,
                                    >,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct Avg with 1 element",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(Avg { field: __field0 })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<
                                    ::core::option::Option<
                                        super::super::structured_query::FieldReference,
                                    >,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("field"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    ::core::option::Option<
                                                        super::super::structured_query::FieldReference,
                                                    >,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("field")?
                                    }
                                };
                                _serde::__private::Ok(Avg { field: __field0 })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["field"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "Avg",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Avg>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for Avg {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "Avg",
                            false as usize + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "field",
                            &self.field,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            /// The type of aggregation to perform, required.
            #[serde(rename_all = "camelCase")]
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub enum Operator {
                /// Count aggregator.
                #[prost(message, tag = "1")]
                Count(Count),
                /// Sum aggregator.
                #[prost(message, tag = "2")]
                Sum(Sum),
                /// Average aggregator.
                #[prost(message, tag = "3")]
                Avg(Avg),
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for Operator {
                #[inline]
                fn clone(&self) -> Operator {
                    match self {
                        Operator::Count(__self_0) => {
                            Operator::Count(::core::clone::Clone::clone(__self_0))
                        }
                        Operator::Sum(__self_0) => {
                            Operator::Sum(::core::clone::Clone::clone(__self_0))
                        }
                        Operator::Avg(__self_0) => {
                            Operator::Avg(::core::clone::Clone::clone(__self_0))
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::marker::StructuralPartialEq for Operator {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for Operator {
                #[inline]
                fn eq(&self, other: &Operator) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                        && match (self, other) {
                            (Operator::Count(__self_0), Operator::Count(__arg1_0)) => {
                                *__self_0 == *__arg1_0
                            }
                            (Operator::Sum(__self_0), Operator::Sum(__arg1_0)) => {
                                *__self_0 == *__arg1_0
                            }
                            (Operator::Avg(__self_0), Operator::Avg(__arg1_0)) => {
                                *__self_0 == *__arg1_0
                            }
                            _ => unsafe { ::core::intrinsics::unreachable() }
                        }
                }
            }
            impl Operator {
                /// Encodes the message to a buffer.
                pub fn encode<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    match *self {
                        Operator::Count(ref value) => {
                            ::prost::encoding::message::encode(1u32, &*value, buf);
                        }
                        Operator::Sum(ref value) => {
                            ::prost::encoding::message::encode(2u32, &*value, buf);
                        }
                        Operator::Avg(ref value) => {
                            ::prost::encoding::message::encode(3u32, &*value, buf);
                        }
                    }
                }
                /// Decodes an instance of the message from a buffer, and merges it into self.
                pub fn merge<B>(
                    field: &mut ::core::option::Option<Operator>,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    match tag {
                        1u32 => {
                            match field {
                                ::core::option::Option::Some(
                                    Operator::Count(ref mut value),
                                ) => {
                                    ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                }
                                _ => {
                                    let mut owned_value = ::core::default::Default::default();
                                    let value = &mut owned_value;
                                    ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                        .map(|_| {
                                            *field = ::core::option::Option::Some(
                                                Operator::Count(owned_value),
                                            );
                                        })
                                }
                            }
                        }
                        2u32 => {
                            match field {
                                ::core::option::Option::Some(
                                    Operator::Sum(ref mut value),
                                ) => {
                                    ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                }
                                _ => {
                                    let mut owned_value = ::core::default::Default::default();
                                    let value = &mut owned_value;
                                    ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                        .map(|_| {
                                            *field = ::core::option::Option::Some(
                                                Operator::Sum(owned_value),
                                            );
                                        })
                                }
                            }
                        }
                        3u32 => {
                            match field {
                                ::core::option::Option::Some(
                                    Operator::Avg(ref mut value),
                                ) => {
                                    ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                }
                                _ => {
                                    let mut owned_value = ::core::default::Default::default();
                                    let value = &mut owned_value;
                                    ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                        .map(|_| {
                                            *field = ::core::option::Option::Some(
                                                Operator::Avg(owned_value),
                                            );
                                        })
                                }
                            }
                        }
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "internal error: entered unreachable code: {0}",
                                    format_args!("invalid Operator tag: {0}", tag),
                                ),
                            );
                        }
                    }
                }
                /// Returns the encoded length of the message without a length delimiter.
                #[inline]
                pub fn encoded_len(&self) -> usize {
                    match *self {
                        Operator::Count(ref value) => {
                            ::prost::encoding::message::encoded_len(1u32, &*value)
                        }
                        Operator::Sum(ref value) => {
                            ::prost::encoding::message::encoded_len(2u32, &*value)
                        }
                        Operator::Avg(ref value) => {
                            ::prost::encoding::message::encoded_len(3u32, &*value)
                        }
                    }
                }
            }
            impl ::core::fmt::Debug for Operator {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        Operator::Count(ref value) => {
                            let wrapper = &*value;
                            f.debug_tuple("Count").field(&wrapper).finish()
                        }
                        Operator::Sum(ref value) => {
                            let wrapper = &*value;
                            f.debug_tuple("Sum").field(&wrapper).finish()
                        }
                        Operator::Avg(ref value) => {
                            let wrapper = &*value;
                            f.debug_tuple("Avg").field(&wrapper).finish()
                        }
                    }
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for Operator {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "variant identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 3",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "count" => _serde::__private::Ok(__Field::__field0),
                                    "sum" => _serde::__private::Ok(__Field::__field1),
                                    "avg" => _serde::__private::Ok(__Field::__field2),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"count" => _serde::__private::Ok(__Field::__field0),
                                    b"sum" => _serde::__private::Ok(__Field::__field1),
                                    b"avg" => _serde::__private::Ok(__Field::__field2),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<Operator>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Operator;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "enum Operator",
                                )
                            }
                            fn visit_enum<__A>(
                                self,
                                __data: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::EnumAccess<'de>,
                            {
                                match _serde::de::EnumAccess::variant(__data)? {
                                    (__Field::__field0, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                Count,
                                            >(__variant),
                                            Operator::Count,
                                        )
                                    }
                                    (__Field::__field1, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                Sum,
                                            >(__variant),
                                            Operator::Sum,
                                        )
                                    }
                                    (__Field::__field2, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                Avg,
                                            >(__variant),
                                            Operator::Avg,
                                        )
                                    }
                                }
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] = &[
                            "count",
                            "sum",
                            "avg",
                        ];
                        _serde::Deserializer::deserialize_enum(
                            __deserializer,
                            "Operator",
                            VARIANTS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Operator>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for Operator {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        match *self {
                            Operator::Count(ref __field0) => {
                                _serde::Serializer::serialize_newtype_variant(
                                    __serializer,
                                    "Operator",
                                    0u32,
                                    "count",
                                    __field0,
                                )
                            }
                            Operator::Sum(ref __field0) => {
                                _serde::Serializer::serialize_newtype_variant(
                                    __serializer,
                                    "Operator",
                                    1u32,
                                    "sum",
                                    __field0,
                                )
                            }
                            Operator::Avg(ref __field0) => {
                                _serde::Serializer::serialize_newtype_variant(
                                    __serializer,
                                    "Operator",
                                    2u32,
                                    "avg",
                                    __field0,
                                )
                            }
                        }
                    }
                }
            };
        }
        /// The base query to aggregate over.
        #[serde(rename_all = "camelCase")]
        #[allow(clippy::derive_partial_eq_without_eq)]
        pub enum QueryType {
            /// Nested structured query.
            #[prost(message, tag = "1")]
            StructuredQuery(super::StructuredQuery),
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::clone::Clone for QueryType {
            #[inline]
            fn clone(&self) -> QueryType {
                match self {
                    QueryType::StructuredQuery(__self_0) => {
                        QueryType::StructuredQuery(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::marker::StructuralPartialEq for QueryType {}
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::cmp::PartialEq for QueryType {
            #[inline]
            fn eq(&self, other: &QueryType) -> bool {
                match (self, other) {
                    (
                        QueryType::StructuredQuery(__self_0),
                        QueryType::StructuredQuery(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                }
            }
        }
        impl QueryType {
            /// Encodes the message to a buffer.
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    QueryType::StructuredQuery(ref value) => {
                        ::prost::encoding::message::encode(1u32, &*value, buf);
                    }
                }
            }
            /// Decodes an instance of the message from a buffer, and merges it into self.
            pub fn merge<B>(
                field: &mut ::core::option::Option<QueryType>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag {
                    1u32 => {
                        match field {
                            ::core::option::Option::Some(
                                QueryType::StructuredQuery(ref mut value),
                            ) => {
                                ::prost::encoding::message::merge(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            QueryType::StructuredQuery(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    _ => {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "internal error: entered unreachable code: {0}",
                                format_args!("invalid QueryType tag: {0}", tag),
                            ),
                        );
                    }
                }
            }
            /// Returns the encoded length of the message without a length delimiter.
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    QueryType::StructuredQuery(ref value) => {
                        ::prost::encoding::message::encoded_len(1u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for QueryType {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    QueryType::StructuredQuery(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("StructuredQuery").field(&wrapper).finish()
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for QueryType {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 1",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "structuredQuery" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"structuredQuery" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<QueryType>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = QueryType;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum QueryType",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            super::StructuredQuery,
                                        >(__variant),
                                        QueryType::StructuredQuery,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &["structuredQuery"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "QueryType",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<QueryType>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for QueryType {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        QueryType::StructuredQuery(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "QueryType",
                                0u32,
                                "structuredQuery",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
    }
    /// A position in a query result set.
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct Cursor {
        /// The values that represent a position, in the order they appear in
        /// the order by clause of a query.
        ///
        /// Can contain fewer values than specified in the order by clause.
        #[prost(message, repeated, tag = "1")]
        pub values: ::prost::alloc::vec::Vec<Value>,
        /// If the position is just before or just after the given values, relative
        /// to the sort order defined by the query.
        #[prost(bool, tag = "2")]
        pub before: bool,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for Cursor {
        #[inline]
        fn clone(&self) -> Cursor {
            Cursor {
                values: ::core::clone::Clone::clone(&self.values),
                before: ::core::clone::Clone::clone(&self.before),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for Cursor {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for Cursor {
        #[inline]
        fn eq(&self, other: &Cursor) -> bool {
            self.values == other.values && self.before == other.before
        }
    }
    impl ::prost::Message for Cursor {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            for msg in &self.values {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if self.before != false {
                ::prost::encoding::bool::encode(2u32, &self.before, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "Cursor";
            match tag {
                1u32 => {
                    let mut value = &mut self.values;
                    ::prost::encoding::message::merge_repeated(
                            wire_type,
                            value,
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "values");
                            error
                        })
                }
                2u32 => {
                    let mut value = &mut self.before;
                    ::prost::encoding::bool::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "before");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + ::prost::encoding::message::encoded_len_repeated(1u32, &self.values)
                + if self.before != false {
                    ::prost::encoding::bool::encoded_len(2u32, &self.before)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.values.clear();
            self.before = false;
        }
    }
    impl ::core::default::Default for Cursor {
        fn default() -> Self {
            Cursor {
                values: ::core::default::Default::default(),
                before: false,
            }
        }
    }
    impl ::core::fmt::Debug for Cursor {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("Cursor");
            let builder = {
                let wrapper = &self.values;
                builder.field("values", &wrapper)
            };
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.before)
                };
                builder.field("before", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Cursor {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "values" => _serde::__private::Ok(__Field::__field0),
                            "before" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"values" => _serde::__private::Ok(__Field::__field0),
                            b"before" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Cursor>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Cursor;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Cursor",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::vec::Vec<Value>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Cursor with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Cursor with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Cursor {
                            values: __field0,
                            before: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::prost::alloc::vec::Vec<Value>,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<bool> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("values"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::vec::Vec<Value>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("before"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("values")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("before")?
                            }
                        };
                        _serde::__private::Ok(Cursor {
                            values: __field0,
                            before: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["values", "before"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Cursor",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Cursor>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Cursor {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "Cursor",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "values",
                    &self.values,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "before",
                    &self.before,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// A sequence of bits, encoded in a byte array.
    ///
    /// Each byte in the `bitmap` byte array stores 8 bits of the sequence. The only
    /// exception is the last byte, which may store 8 _or fewer_ bits. The `padding`
    /// defines the number of bits of the last byte to be ignored as "padding". The
    /// values of these "padding" bits are unspecified and must be ignored.
    ///
    /// To retrieve the first bit, bit 0, calculate: `(bitmap\[0\] & 0x01) != 0`.
    /// To retrieve the second bit, bit 1, calculate: `(bitmap\[0\] & 0x02) != 0`.
    /// To retrieve the third bit, bit 2, calculate: `(bitmap\[0\] & 0x04) != 0`.
    /// To retrieve the fourth bit, bit 3, calculate: `(bitmap\[0\] & 0x08) != 0`.
    /// To retrieve bit n, calculate: `(bitmap\[n / 8\] & (0x01 << (n % 8))) != 0`.
    ///
    /// The "size" of a `BitSequence` (the number of bits it contains) is calculated
    /// by this formula: `(bitmap.length * 8) - padding`.
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct BitSequence {
        /// The bytes that encode the bit sequence.
        /// May have a length of zero.
        #[prost(bytes = "vec", tag = "1")]
        pub bitmap: ::prost::alloc::vec::Vec<u8>,
        /// The number of bits of the last byte in `bitmap` to ignore as "padding".
        /// If the length of `bitmap` is zero, then this value must be `0`.
        /// Otherwise, this value must be between 0 and 7, inclusive.
        #[prost(int32, tag = "2")]
        pub padding: i32,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for BitSequence {
        #[inline]
        fn clone(&self) -> BitSequence {
            BitSequence {
                bitmap: ::core::clone::Clone::clone(&self.bitmap),
                padding: ::core::clone::Clone::clone(&self.padding),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for BitSequence {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for BitSequence {
        #[inline]
        fn eq(&self, other: &BitSequence) -> bool {
            self.bitmap == other.bitmap && self.padding == other.padding
        }
    }
    impl ::prost::Message for BitSequence {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.bitmap != b"" as &[u8] {
                ::prost::encoding::bytes::encode(1u32, &self.bitmap, buf);
            }
            if self.padding != 0i32 {
                ::prost::encoding::int32::encode(2u32, &self.padding, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "BitSequence";
            match tag {
                1u32 => {
                    let mut value = &mut self.bitmap;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "bitmap");
                            error
                        })
                }
                2u32 => {
                    let mut value = &mut self.padding;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "padding");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0
                + if self.bitmap != b"" as &[u8] {
                    ::prost::encoding::bytes::encoded_len(1u32, &self.bitmap)
                } else {
                    0
                }
                + if self.padding != 0i32 {
                    ::prost::encoding::int32::encoded_len(2u32, &self.padding)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.bitmap.clear();
            self.padding = 0i32;
        }
    }
    impl ::core::default::Default for BitSequence {
        fn default() -> Self {
            BitSequence {
                bitmap: ::core::default::Default::default(),
                padding: 0i32,
            }
        }
    }
    impl ::core::fmt::Debug for BitSequence {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("BitSequence");
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.bitmap)
                };
                builder.field("bitmap", &wrapper)
            };
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.padding)
                };
                builder.field("padding", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for BitSequence {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "bitmap" => _serde::__private::Ok(__Field::__field0),
                            "padding" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"bitmap" => _serde::__private::Ok(__Field::__field0),
                            b"padding" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<BitSequence>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = BitSequence;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct BitSequence",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::vec::Vec<u8>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct BitSequence with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            i32,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct BitSequence with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(BitSequence {
                            bitmap: __field0,
                            padding: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::prost::alloc::vec::Vec<u8>,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<i32> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("bitmap"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::vec::Vec<u8>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "padding",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i32>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("bitmap")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("padding")?
                            }
                        };
                        _serde::__private::Ok(BitSequence {
                            bitmap: __field0,
                            padding: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["bitmap", "padding"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "BitSequence",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<BitSequence>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for BitSequence {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "BitSequence",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "bitmap",
                    &self.bitmap,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "padding",
                    &self.padding,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// A bloom filter (<https://en.wikipedia.org/wiki/Bloom_filter>).
    ///
    /// The bloom filter hashes the entries with MD5 and treats the resulting 128-bit
    /// hash as 2 distinct 64-bit hash values, interpreted as unsigned integers
    /// using 2's complement encoding.
    ///
    /// These two hash values, named `h1` and `h2`, are then used to compute the
    /// `hash_count` hash values using the formula, starting at `i=0`:
    ///
    ///      h(i) = h1 + (i * h2)
    ///
    /// These resulting values are then taken modulo the number of bits in the bloom
    /// filter to get the bits of the bloom filter to test for the given entry.
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct BloomFilter {
        /// The bloom filter data.
        #[prost(message, optional, tag = "1")]
        pub bits: ::core::option::Option<BitSequence>,
        /// The number of hashes used by the algorithm.
        #[prost(int32, tag = "2")]
        pub hash_count: i32,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for BloomFilter {
        #[inline]
        fn clone(&self) -> BloomFilter {
            BloomFilter {
                bits: ::core::clone::Clone::clone(&self.bits),
                hash_count: ::core::clone::Clone::clone(&self.hash_count),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for BloomFilter {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for BloomFilter {
        #[inline]
        fn eq(&self, other: &BloomFilter) -> bool {
            self.bits == other.bits && self.hash_count == other.hash_count
        }
    }
    impl ::prost::Message for BloomFilter {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.bits {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if self.hash_count != 0i32 {
                ::prost::encoding::int32::encode(2u32, &self.hash_count, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "BloomFilter";
            match tag {
                1u32 => {
                    let mut value = &mut self.bits;
                    ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "bits");
                            error
                        })
                }
                2u32 => {
                    let mut value = &mut self.hash_count;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "hash_count");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0
                + self
                    .bits
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + if self.hash_count != 0i32 {
                    ::prost::encoding::int32::encoded_len(2u32, &self.hash_count)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.bits = ::core::option::Option::None;
            self.hash_count = 0i32;
        }
    }
    impl ::core::default::Default for BloomFilter {
        fn default() -> Self {
            BloomFilter {
                bits: ::core::default::Default::default(),
                hash_count: 0i32,
            }
        }
    }
    impl ::core::fmt::Debug for BloomFilter {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("BloomFilter");
            let builder = {
                let wrapper = &self.bits;
                builder.field("bits", &wrapper)
            };
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.hash_count)
                };
                builder.field("hash_count", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for BloomFilter {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "bits" => _serde::__private::Ok(__Field::__field0),
                            "hashCount" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"bits" => _serde::__private::Ok(__Field::__field0),
                            b"hashCount" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<BloomFilter>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = BloomFilter;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct BloomFilter",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<BitSequence>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct BloomFilter with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            i32,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct BloomFilter with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(BloomFilter {
                            bits: __field0,
                            hash_count: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::core::option::Option<BitSequence>,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<i32> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("bits"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<BitSequence>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "hashCount",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i32>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("bits")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("hashCount")?
                            }
                        };
                        _serde::__private::Ok(BloomFilter {
                            bits: __field0,
                            hash_count: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["bits", "hashCount"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "BloomFilter",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<BloomFilter>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for BloomFilter {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "BloomFilter",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "bits",
                    &self.bits,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "hashCount",
                    &self.hash_count,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// A write on a document.
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct Write {
        /// The fields to update in this write.
        ///
        /// This field can be set only when the operation is `update`.
        /// If the mask is not set for an `update` and the document exists, any
        /// existing data will be overwritten.
        /// If the mask is set and the document on the server has fields not covered by
        /// the mask, they are left unchanged.
        /// Fields referenced in the mask, but not present in the input document, are
        /// deleted from the document on the server.
        /// The field paths in this mask must not contain a reserved field name.
        #[prost(message, optional, tag = "3")]
        pub update_mask: ::core::option::Option<DocumentMask>,
        /// The transforms to perform after update.
        ///
        /// This field can be set only when the operation is `update`. If present, this
        /// write is equivalent to performing `update` and `transform` to the same
        /// document atomically and in order.
        #[prost(message, repeated, tag = "7")]
        pub update_transforms: ::prost::alloc::vec::Vec<
            document_transform::FieldTransform,
        >,
        /// An optional precondition on the document.
        ///
        /// The write will fail if this is set and not met by the target document.
        #[prost(message, optional, tag = "4")]
        pub current_document: ::core::option::Option<Precondition>,
        /// The operation to execute.
        #[prost(oneof = "write::Operation", tags = "1, 2, 6")]
        pub operation: ::core::option::Option<write::Operation>,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for Write {
        #[inline]
        fn clone(&self) -> Write {
            Write {
                update_mask: ::core::clone::Clone::clone(&self.update_mask),
                update_transforms: ::core::clone::Clone::clone(&self.update_transforms),
                current_document: ::core::clone::Clone::clone(&self.current_document),
                operation: ::core::clone::Clone::clone(&self.operation),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for Write {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for Write {
        #[inline]
        fn eq(&self, other: &Write) -> bool {
            self.update_mask == other.update_mask
                && self.update_transforms == other.update_transforms
                && self.current_document == other.current_document
                && self.operation == other.operation
        }
    }
    impl ::prost::Message for Write {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref oneof) = self.operation {
                oneof.encode(buf)
            }
            if let Some(ref msg) = self.update_mask {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
            if let Some(ref msg) = self.current_document {
                ::prost::encoding::message::encode(4u32, msg, buf);
            }
            for msg in &self.update_transforms {
                ::prost::encoding::message::encode(7u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "Write";
            match tag {
                1u32 | 2u32 | 6u32 => {
                    let mut value = &mut self.operation;
                    write::Operation::merge(value, tag, wire_type, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "operation");
                            error
                        })
                }
                3u32 => {
                    let mut value = &mut self.update_mask;
                    ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "update_mask");
                            error
                        })
                }
                4u32 => {
                    let mut value = &mut self.current_document;
                    ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "current_document");
                            error
                        })
                }
                7u32 => {
                    let mut value = &mut self.update_transforms;
                    ::prost::encoding::message::merge_repeated(
                            wire_type,
                            value,
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "update_transforms");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self.operation.as_ref().map_or(0, write::Operation::encoded_len)
                + self
                    .update_mask
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(3u32, msg))
                + self
                    .current_document
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(4u32, msg))
                + ::prost::encoding::message::encoded_len_repeated(
                    7u32,
                    &self.update_transforms,
                )
        }
        fn clear(&mut self) {
            self.operation = ::core::option::Option::None;
            self.update_mask = ::core::option::Option::None;
            self.current_document = ::core::option::Option::None;
            self.update_transforms.clear();
        }
    }
    impl ::core::default::Default for Write {
        fn default() -> Self {
            Write {
                operation: ::core::default::Default::default(),
                update_mask: ::core::default::Default::default(),
                current_document: ::core::default::Default::default(),
                update_transforms: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for Write {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("Write");
            let builder = {
                let wrapper = &self.update_mask;
                builder.field("update_mask", &wrapper)
            };
            let builder = {
                let wrapper = &self.update_transforms;
                builder.field("update_transforms", &wrapper)
            };
            let builder = {
                let wrapper = &self.current_document;
                builder.field("current_document", &wrapper)
            };
            let builder = {
                let wrapper = &self.operation;
                builder.field("operation", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Write {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "updateMask" => _serde::__private::Ok(__Field::__field0),
                            "updateTransforms" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            "currentDocument" => _serde::__private::Ok(__Field::__field2),
                            "operation" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"updateMask" => _serde::__private::Ok(__Field::__field0),
                            b"updateTransforms" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            b"currentDocument" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            b"operation" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Write>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Write;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Write",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<DocumentMask>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Write with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::vec::Vec<document_transform::FieldTransform>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Write with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<Precondition>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct Write with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<write::Operation>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct Write with 4 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Write {
                            update_mask: __field0,
                            update_transforms: __field1,
                            current_document: __field2,
                            operation: __field3,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::core::option::Option<DocumentMask>,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            ::prost::alloc::vec::Vec<document_transform::FieldTransform>,
                        > = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            ::core::option::Option<Precondition>,
                        > = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<
                            ::core::option::Option<write::Operation>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "updateMask",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<DocumentMask>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "updateTransforms",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::vec::Vec<document_transform::FieldTransform>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "currentDocument",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<Precondition>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "operation",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<write::Operation>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("updateMask")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("updateTransforms")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("currentDocument")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("operation")?
                            }
                        };
                        _serde::__private::Ok(Write {
                            update_mask: __field0,
                            update_transforms: __field1,
                            current_document: __field2,
                            operation: __field3,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "updateMask",
                    "updateTransforms",
                    "currentDocument",
                    "operation",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Write",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Write>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Write {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "Write",
                    false as usize + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "updateMask",
                    &self.update_mask,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "updateTransforms",
                    &self.update_transforms,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "currentDocument",
                    &self.current_document,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "operation",
                    &self.operation,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// Nested message and enum types in `Write`.
    pub mod write {
        /// The operation to execute.
        #[serde(rename_all = "camelCase")]
        #[allow(clippy::derive_partial_eq_without_eq)]
        pub enum Operation {
            /// A document to write.
            #[prost(message, tag = "1")]
            Update(super::Document),
            /// A document name to delete. In the format:
            /// `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
            #[prost(string, tag = "2")]
            Delete(::prost::alloc::string::String),
            /// Applies a transformation to a document.
            #[prost(message, tag = "6")]
            Transform(super::DocumentTransform),
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::clone::Clone for Operation {
            #[inline]
            fn clone(&self) -> Operation {
                match self {
                    Operation::Update(__self_0) => {
                        Operation::Update(::core::clone::Clone::clone(__self_0))
                    }
                    Operation::Delete(__self_0) => {
                        Operation::Delete(::core::clone::Clone::clone(__self_0))
                    }
                    Operation::Transform(__self_0) => {
                        Operation::Transform(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::marker::StructuralPartialEq for Operation {}
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::cmp::PartialEq for Operation {
            #[inline]
            fn eq(&self, other: &Operation) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
                    && match (self, other) {
                        (Operation::Update(__self_0), Operation::Update(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Operation::Delete(__self_0), Operation::Delete(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (
                            Operation::Transform(__self_0),
                            Operation::Transform(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        impl Operation {
            /// Encodes the message to a buffer.
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    Operation::Update(ref value) => {
                        ::prost::encoding::message::encode(1u32, &*value, buf);
                    }
                    Operation::Delete(ref value) => {
                        ::prost::encoding::string::encode(2u32, &*value, buf);
                    }
                    Operation::Transform(ref value) => {
                        ::prost::encoding::message::encode(6u32, &*value, buf);
                    }
                }
            }
            /// Decodes an instance of the message from a buffer, and merges it into self.
            pub fn merge<B>(
                field: &mut ::core::option::Option<Operation>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag {
                    1u32 => {
                        match field {
                            ::core::option::Option::Some(
                                Operation::Update(ref mut value),
                            ) => {
                                ::prost::encoding::message::merge(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            Operation::Update(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    2u32 => {
                        match field {
                            ::core::option::Option::Some(
                                Operation::Delete(ref mut value),
                            ) => {
                                ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            Operation::Delete(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    6u32 => {
                        match field {
                            ::core::option::Option::Some(
                                Operation::Transform(ref mut value),
                            ) => {
                                ::prost::encoding::message::merge(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            Operation::Transform(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    _ => {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "internal error: entered unreachable code: {0}",
                                format_args!("invalid Operation tag: {0}", tag),
                            ),
                        );
                    }
                }
            }
            /// Returns the encoded length of the message without a length delimiter.
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    Operation::Update(ref value) => {
                        ::prost::encoding::message::encoded_len(1u32, &*value)
                    }
                    Operation::Delete(ref value) => {
                        ::prost::encoding::string::encoded_len(2u32, &*value)
                    }
                    Operation::Transform(ref value) => {
                        ::prost::encoding::message::encoded_len(6u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for Operation {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Operation::Update(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("Update").field(&wrapper).finish()
                    }
                    Operation::Delete(ref value) => {
                        let wrapper = {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("Delete").field(&wrapper).finish()
                    }
                    Operation::Transform(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("Transform").field(&wrapper).finish()
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Operation {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 3",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "update" => _serde::__private::Ok(__Field::__field0),
                                "delete" => _serde::__private::Ok(__Field::__field1),
                                "transform" => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"update" => _serde::__private::Ok(__Field::__field0),
                                b"delete" => _serde::__private::Ok(__Field::__field1),
                                b"transform" => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Operation>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Operation;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum Operation",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            super::Document,
                                        >(__variant),
                                        Operation::Update,
                                    )
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            ::prost::alloc::string::String,
                                        >(__variant),
                                        Operation::Delete,
                                    )
                                }
                                (__Field::__field2, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            super::DocumentTransform,
                                        >(__variant),
                                        Operation::Transform,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "update",
                        "delete",
                        "transform",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "Operation",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Operation>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Operation {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        Operation::Update(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "Operation",
                                0u32,
                                "update",
                                __field0,
                            )
                        }
                        Operation::Delete(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "Operation",
                                1u32,
                                "delete",
                                __field0,
                            )
                        }
                        Operation::Transform(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "Operation",
                                2u32,
                                "transform",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
    }
    /// A transformation of a document.
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct DocumentTransform {
        /// The name of the document to transform.
        #[prost(string, tag = "1")]
        pub document: ::prost::alloc::string::String,
        /// The list of transformations to apply to the fields of the document, in
        /// order.
        /// This must not be empty.
        #[prost(message, repeated, tag = "2")]
        pub field_transforms: ::prost::alloc::vec::Vec<
            document_transform::FieldTransform,
        >,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for DocumentTransform {
        #[inline]
        fn clone(&self) -> DocumentTransform {
            DocumentTransform {
                document: ::core::clone::Clone::clone(&self.document),
                field_transforms: ::core::clone::Clone::clone(&self.field_transforms),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for DocumentTransform {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for DocumentTransform {
        #[inline]
        fn eq(&self, other: &DocumentTransform) -> bool {
            self.document == other.document
                && self.field_transforms == other.field_transforms
        }
    }
    impl ::prost::Message for DocumentTransform {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.document != "" {
                ::prost::encoding::string::encode(1u32, &self.document, buf);
            }
            for msg in &self.field_transforms {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "DocumentTransform";
            match tag {
                1u32 => {
                    let mut value = &mut self.document;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "document");
                            error
                        })
                }
                2u32 => {
                    let mut value = &mut self.field_transforms;
                    ::prost::encoding::message::merge_repeated(
                            wire_type,
                            value,
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "field_transforms");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0
                + if self.document != "" {
                    ::prost::encoding::string::encoded_len(1u32, &self.document)
                } else {
                    0
                }
                + ::prost::encoding::message::encoded_len_repeated(
                    2u32,
                    &self.field_transforms,
                )
        }
        fn clear(&mut self) {
            self.document.clear();
            self.field_transforms.clear();
        }
    }
    impl ::core::default::Default for DocumentTransform {
        fn default() -> Self {
            DocumentTransform {
                document: ::prost::alloc::string::String::new(),
                field_transforms: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for DocumentTransform {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("DocumentTransform");
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.document)
                };
                builder.field("document", &wrapper)
            };
            let builder = {
                let wrapper = &self.field_transforms;
                builder.field("field_transforms", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for DocumentTransform {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "document" => _serde::__private::Ok(__Field::__field0),
                            "fieldTransforms" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"document" => _serde::__private::Ok(__Field::__field0),
                            b"fieldTransforms" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<DocumentTransform>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = DocumentTransform;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct DocumentTransform",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::string::String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct DocumentTransform with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::vec::Vec<document_transform::FieldTransform>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct DocumentTransform with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(DocumentTransform {
                            document: __field0,
                            field_transforms: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::prost::alloc::string::String,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            ::prost::alloc::vec::Vec<document_transform::FieldTransform>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "document",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::string::String,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "fieldTransforms",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::vec::Vec<document_transform::FieldTransform>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("document")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("fieldTransforms")?
                            }
                        };
                        _serde::__private::Ok(DocumentTransform {
                            document: __field0,
                            field_transforms: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["document", "fieldTransforms"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "DocumentTransform",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<DocumentTransform>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for DocumentTransform {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "DocumentTransform",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "document",
                    &self.document,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "fieldTransforms",
                    &self.field_transforms,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// Nested message and enum types in `DocumentTransform`.
    pub mod document_transform {
        /// A transformation of a field of the document.
        #[serde(rename_all = "camelCase")]
        #[allow(clippy::derive_partial_eq_without_eq)]
        pub struct FieldTransform {
            /// The path of the field. See
            /// [Document.fields][google.firestore.v1.Document.fields] for the field path
            /// syntax reference.
            #[prost(string, tag = "1")]
            pub field_path: ::prost::alloc::string::String,
            /// The transformation to apply on the field.
            #[prost(oneof = "field_transform::TransformType", tags = "2, 3, 4, 5, 6, 7")]
            pub transform_type: ::core::option::Option<field_transform::TransformType>,
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::clone::Clone for FieldTransform {
            #[inline]
            fn clone(&self) -> FieldTransform {
                FieldTransform {
                    field_path: ::core::clone::Clone::clone(&self.field_path),
                    transform_type: ::core::clone::Clone::clone(&self.transform_type),
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::marker::StructuralPartialEq for FieldTransform {}
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::cmp::PartialEq for FieldTransform {
            #[inline]
            fn eq(&self, other: &FieldTransform) -> bool {
                self.field_path == other.field_path
                    && self.transform_type == other.transform_type
            }
        }
        impl ::prost::Message for FieldTransform {
            #[allow(unused_variables)]
            fn encode_raw<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                if self.field_path != "" {
                    ::prost::encoding::string::encode(1u32, &self.field_path, buf);
                }
                if let Some(ref oneof) = self.transform_type {
                    oneof.encode(buf)
                }
            }
            #[allow(unused_variables)]
            fn merge_field<B>(
                &mut self,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                const STRUCT_NAME: &'static str = "FieldTransform";
                match tag {
                    1u32 => {
                        let mut value = &mut self.field_path;
                        ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                            .map_err(|mut error| {
                                error.push(STRUCT_NAME, "field_path");
                                error
                            })
                    }
                    2u32 | 3u32 | 4u32 | 5u32 | 6u32 | 7u32 => {
                        let mut value = &mut self.transform_type;
                        field_transform::TransformType::merge(
                                value,
                                tag,
                                wire_type,
                                buf,
                                ctx,
                            )
                            .map_err(|mut error| {
                                error.push(STRUCT_NAME, "transform_type");
                                error
                            })
                    }
                    _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0
                    + if self.field_path != "" {
                        ::prost::encoding::string::encoded_len(1u32, &self.field_path)
                    } else {
                        0
                    }
                    + self
                        .transform_type
                        .as_ref()
                        .map_or(0, field_transform::TransformType::encoded_len)
            }
            fn clear(&mut self) {
                self.field_path.clear();
                self.transform_type = ::core::option::Option::None;
            }
        }
        impl ::core::default::Default for FieldTransform {
            fn default() -> Self {
                FieldTransform {
                    field_path: ::prost::alloc::string::String::new(),
                    transform_type: ::core::default::Default::default(),
                }
            }
        }
        impl ::core::fmt::Debug for FieldTransform {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let mut builder = f.debug_struct("FieldTransform");
                let builder = {
                    let wrapper = {
                        #[allow(non_snake_case)]
                        fn ScalarWrapper<T>(v: T) -> T {
                            v
                        }
                        ScalarWrapper(&self.field_path)
                    };
                    builder.field("field_path", &wrapper)
                };
                let builder = {
                    let wrapper = &self.transform_type;
                    builder.field("transform_type", &wrapper)
                };
                builder.finish()
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for FieldTransform {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "fieldPath" => _serde::__private::Ok(__Field::__field0),
                                "transformType" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"fieldPath" => _serde::__private::Ok(__Field::__field0),
                                b"transformType" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<FieldTransform>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = FieldTransform;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct FieldTransform",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                ::prost::alloc::string::String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct FieldTransform with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                ::core::option::Option<field_transform::TransformType>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct FieldTransform with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(FieldTransform {
                                field_path: __field0,
                                transform_type: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                ::prost::alloc::string::String,
                            > = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                ::core::option::Option<field_transform::TransformType>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "fieldPath",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ::prost::alloc::string::String,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "transformType",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ::core::option::Option<field_transform::TransformType>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("fieldPath")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("transformType")?
                                }
                            };
                            _serde::__private::Ok(FieldTransform {
                                field_path: __field0,
                                transform_type: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "fieldPath",
                        "transformType",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "FieldTransform",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<FieldTransform>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for FieldTransform {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "FieldTransform",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "fieldPath",
                        &self.field_path,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "transformType",
                        &self.transform_type,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        /// Nested message and enum types in `FieldTransform`.
        pub mod field_transform {
            /// A value that is calculated by the server.
            #[serde(rename_all = "camelCase")]
            #[repr(i32)]
            pub enum ServerValue {
                /// Unspecified. This value must not be used.
                Unspecified = 0,
                /// The time at which the server processed the request, with millisecond
                /// precision. If used on multiple fields (same or different documents) in
                /// a transaction, all the fields will get the same server timestamp.
                RequestTime = 1,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ServerValue {
                #[inline]
                fn clone(&self) -> ServerValue {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for ServerValue {}
            #[automatically_derived]
            impl ::core::fmt::Debug for ServerValue {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            ServerValue::Unspecified => "Unspecified",
                            ServerValue::RequestTime => "RequestTime",
                        },
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ServerValue {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ServerValue {
                #[inline]
                fn eq(&self, other: &ServerValue) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for ServerValue {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            #[automatically_derived]
            impl ::core::hash::Hash for ServerValue {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    ::core::hash::Hash::hash(&__self_tag, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for ServerValue {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &ServerValue,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for ServerValue {
                #[inline]
                fn cmp(&self, other: &ServerValue) -> ::core::cmp::Ordering {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag)
                }
            }
            impl ServerValue {
                ///Returns `true` if `value` is a variant of `ServerValue`.
                pub fn is_valid(value: i32) -> bool {
                    match value {
                        0 => true,
                        1 => true,
                        _ => false,
                    }
                }
                #[deprecated = "Use the TryFrom<i32> implementation instead"]
                ///Converts an `i32` to a `ServerValue`, or `None` if `value` is not a valid variant.
                pub fn from_i32(value: i32) -> ::core::option::Option<ServerValue> {
                    match value {
                        0 => ::core::option::Option::Some(ServerValue::Unspecified),
                        1 => ::core::option::Option::Some(ServerValue::RequestTime),
                        _ => ::core::option::Option::None,
                    }
                }
            }
            impl ::core::default::Default for ServerValue {
                fn default() -> ServerValue {
                    ServerValue::Unspecified
                }
            }
            impl ::core::convert::From<ServerValue> for i32 {
                fn from(value: ServerValue) -> i32 {
                    value as i32
                }
            }
            impl ::core::convert::TryFrom<i32> for ServerValue {
                type Error = ::prost::DecodeError;
                fn try_from(
                    value: i32,
                ) -> ::core::result::Result<ServerValue, ::prost::DecodeError> {
                    match value {
                        0 => ::core::result::Result::Ok(ServerValue::Unspecified),
                        1 => ::core::result::Result::Ok(ServerValue::RequestTime),
                        _ => {
                            ::core::result::Result::Err(
                                ::prost::DecodeError::new("invalid enumeration value"),
                            )
                        }
                    }
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for ServerValue {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "variant identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 2",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "unspecified" => _serde::__private::Ok(__Field::__field0),
                                    "requestTime" => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"unspecified" => _serde::__private::Ok(__Field::__field0),
                                    b"requestTime" => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<ServerValue>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = ServerValue;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "enum ServerValue",
                                )
                            }
                            fn visit_enum<__A>(
                                self,
                                __data: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::EnumAccess<'de>,
                            {
                                match _serde::de::EnumAccess::variant(__data)? {
                                    (__Field::__field0, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(ServerValue::Unspecified)
                                    }
                                    (__Field::__field1, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(ServerValue::RequestTime)
                                    }
                                }
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] = &[
                            "unspecified",
                            "requestTime",
                        ];
                        _serde::Deserializer::deserialize_enum(
                            __deserializer,
                            "ServerValue",
                            VARIANTS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<ServerValue>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for ServerValue {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        match *self {
                            ServerValue::Unspecified => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "ServerValue",
                                    0u32,
                                    "unspecified",
                                )
                            }
                            ServerValue::RequestTime => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "ServerValue",
                                    1u32,
                                    "requestTime",
                                )
                            }
                        }
                    }
                }
            };
            impl ServerValue {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        ServerValue::Unspecified => "SERVER_VALUE_UNSPECIFIED",
                        ServerValue::RequestTime => "REQUEST_TIME",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "SERVER_VALUE_UNSPECIFIED" => Some(Self::Unspecified),
                        "REQUEST_TIME" => Some(Self::RequestTime),
                        _ => None,
                    }
                }
            }
            /// The transformation to apply on the field.
            #[serde(rename_all = "camelCase")]
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub enum TransformType {
                /// Sets the field to the given server value.
                #[prost(enumeration = "ServerValue", tag = "2")]
                SetToServerValue(i32),
                /// Adds the given value to the field's current value.
                ///
                /// This must be an integer or a double value.
                /// If the field is not an integer or double, or if the field does not yet
                /// exist, the transformation will set the field to the given value.
                /// If either of the given value or the current field value are doubles,
                /// both values will be interpreted as doubles. Double arithmetic and
                /// representation of double values follow IEEE 754 semantics.
                /// If there is positive/negative integer overflow, the field is resolved
                /// to the largest magnitude positive/negative integer.
                #[prost(message, tag = "3")]
                Increment(super::super::Value),
                /// Sets the field to the maximum of its current value and the given value.
                ///
                /// This must be an integer or a double value.
                /// If the field is not an integer or double, or if the field does not yet
                /// exist, the transformation will set the field to the given value.
                /// If a maximum operation is applied where the field and the input value
                /// are of mixed types (that is - one is an integer and one is a double)
                /// the field takes on the type of the larger operand. If the operands are
                /// equivalent (e.g. 3 and 3.0), the field does not change.
                /// 0, 0.0, and -0.0 are all zero. The maximum of a zero stored value and
                /// zero input value is always the stored value.
                /// The maximum of any numeric value x and NaN is NaN.
                #[prost(message, tag = "4")]
                Maximum(super::super::Value),
                /// Sets the field to the minimum of its current value and the given value.
                ///
                /// This must be an integer or a double value.
                /// If the field is not an integer or double, or if the field does not yet
                /// exist, the transformation will set the field to the input value.
                /// If a minimum operation is applied where the field and the input value
                /// are of mixed types (that is - one is an integer and one is a double)
                /// the field takes on the type of the smaller operand. If the operands are
                /// equivalent (e.g. 3 and 3.0), the field does not change.
                /// 0, 0.0, and -0.0 are all zero. The minimum of a zero stored value and
                /// zero input value is always the stored value.
                /// The minimum of any numeric value x and NaN is NaN.
                #[prost(message, tag = "5")]
                Minimum(super::super::Value),
                /// Append the given elements in order if they are not already present in
                /// the current field value.
                /// If the field is not an array, or if the field does not yet exist, it is
                /// first set to the empty array.
                ///
                /// Equivalent numbers of different types (e.g. 3L and 3.0) are
                /// considered equal when checking if a value is missing.
                /// NaN is equal to NaN, and Null is equal to Null.
                /// If the input contains multiple equivalent values, only the first will
                /// be considered.
                ///
                /// The corresponding transform_result will be the null value.
                #[prost(message, tag = "6")]
                AppendMissingElements(super::super::ArrayValue),
                /// Remove all of the given elements from the array in the field.
                /// If the field is not an array, or if the field does not yet exist, it is
                /// set to the empty array.
                ///
                /// Equivalent numbers of the different types (e.g. 3L and 3.0) are
                /// considered equal when deciding whether an element should be removed.
                /// NaN is equal to NaN, and Null is equal to Null.
                /// This will remove all equivalent values if there are duplicates.
                ///
                /// The corresponding transform_result will be the null value.
                #[prost(message, tag = "7")]
                RemoveAllFromArray(super::super::ArrayValue),
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for TransformType {
                #[inline]
                fn clone(&self) -> TransformType {
                    match self {
                        TransformType::SetToServerValue(__self_0) => {
                            TransformType::SetToServerValue(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        TransformType::Increment(__self_0) => {
                            TransformType::Increment(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        TransformType::Maximum(__self_0) => {
                            TransformType::Maximum(::core::clone::Clone::clone(__self_0))
                        }
                        TransformType::Minimum(__self_0) => {
                            TransformType::Minimum(::core::clone::Clone::clone(__self_0))
                        }
                        TransformType::AppendMissingElements(__self_0) => {
                            TransformType::AppendMissingElements(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        TransformType::RemoveAllFromArray(__self_0) => {
                            TransformType::RemoveAllFromArray(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::marker::StructuralPartialEq for TransformType {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for TransformType {
                #[inline]
                fn eq(&self, other: &TransformType) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                        && match (self, other) {
                            (
                                TransformType::SetToServerValue(__self_0),
                                TransformType::SetToServerValue(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                TransformType::Increment(__self_0),
                                TransformType::Increment(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                TransformType::Maximum(__self_0),
                                TransformType::Maximum(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                TransformType::Minimum(__self_0),
                                TransformType::Minimum(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                TransformType::AppendMissingElements(__self_0),
                                TransformType::AppendMissingElements(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                TransformType::RemoveAllFromArray(__self_0),
                                TransformType::RemoveAllFromArray(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            _ => unsafe { ::core::intrinsics::unreachable() }
                        }
                }
            }
            impl TransformType {
                /// Encodes the message to a buffer.
                pub fn encode<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    match *self {
                        TransformType::SetToServerValue(ref value) => {
                            ::prost::encoding::int32::encode(2u32, &*value, buf);
                        }
                        TransformType::Increment(ref value) => {
                            ::prost::encoding::message::encode(3u32, &*value, buf);
                        }
                        TransformType::Maximum(ref value) => {
                            ::prost::encoding::message::encode(4u32, &*value, buf);
                        }
                        TransformType::Minimum(ref value) => {
                            ::prost::encoding::message::encode(5u32, &*value, buf);
                        }
                        TransformType::AppendMissingElements(ref value) => {
                            ::prost::encoding::message::encode(6u32, &*value, buf);
                        }
                        TransformType::RemoveAllFromArray(ref value) => {
                            ::prost::encoding::message::encode(7u32, &*value, buf);
                        }
                    }
                }
                /// Decodes an instance of the message from a buffer, and merges it into self.
                pub fn merge<B>(
                    field: &mut ::core::option::Option<TransformType>,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    match tag {
                        2u32 => {
                            match field {
                                ::core::option::Option::Some(
                                    TransformType::SetToServerValue(ref mut value),
                                ) => {
                                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                                }
                                _ => {
                                    let mut owned_value = ::core::default::Default::default();
                                    let value = &mut owned_value;
                                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                                        .map(|_| {
                                            *field = ::core::option::Option::Some(
                                                TransformType::SetToServerValue(owned_value),
                                            );
                                        })
                                }
                            }
                        }
                        3u32 => {
                            match field {
                                ::core::option::Option::Some(
                                    TransformType::Increment(ref mut value),
                                ) => {
                                    ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                }
                                _ => {
                                    let mut owned_value = ::core::default::Default::default();
                                    let value = &mut owned_value;
                                    ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                        .map(|_| {
                                            *field = ::core::option::Option::Some(
                                                TransformType::Increment(owned_value),
                                            );
                                        })
                                }
                            }
                        }
                        4u32 => {
                            match field {
                                ::core::option::Option::Some(
                                    TransformType::Maximum(ref mut value),
                                ) => {
                                    ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                }
                                _ => {
                                    let mut owned_value = ::core::default::Default::default();
                                    let value = &mut owned_value;
                                    ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                        .map(|_| {
                                            *field = ::core::option::Option::Some(
                                                TransformType::Maximum(owned_value),
                                            );
                                        })
                                }
                            }
                        }
                        5u32 => {
                            match field {
                                ::core::option::Option::Some(
                                    TransformType::Minimum(ref mut value),
                                ) => {
                                    ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                }
                                _ => {
                                    let mut owned_value = ::core::default::Default::default();
                                    let value = &mut owned_value;
                                    ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                        .map(|_| {
                                            *field = ::core::option::Option::Some(
                                                TransformType::Minimum(owned_value),
                                            );
                                        })
                                }
                            }
                        }
                        6u32 => {
                            match field {
                                ::core::option::Option::Some(
                                    TransformType::AppendMissingElements(ref mut value),
                                ) => {
                                    ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                }
                                _ => {
                                    let mut owned_value = ::core::default::Default::default();
                                    let value = &mut owned_value;
                                    ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                        .map(|_| {
                                            *field = ::core::option::Option::Some(
                                                TransformType::AppendMissingElements(owned_value),
                                            );
                                        })
                                }
                            }
                        }
                        7u32 => {
                            match field {
                                ::core::option::Option::Some(
                                    TransformType::RemoveAllFromArray(ref mut value),
                                ) => {
                                    ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                }
                                _ => {
                                    let mut owned_value = ::core::default::Default::default();
                                    let value = &mut owned_value;
                                    ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                        .map(|_| {
                                            *field = ::core::option::Option::Some(
                                                TransformType::RemoveAllFromArray(owned_value),
                                            );
                                        })
                                }
                            }
                        }
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "internal error: entered unreachable code: {0}",
                                    format_args!("invalid TransformType tag: {0}", tag),
                                ),
                            );
                        }
                    }
                }
                /// Returns the encoded length of the message without a length delimiter.
                #[inline]
                pub fn encoded_len(&self) -> usize {
                    match *self {
                        TransformType::SetToServerValue(ref value) => {
                            ::prost::encoding::int32::encoded_len(2u32, &*value)
                        }
                        TransformType::Increment(ref value) => {
                            ::prost::encoding::message::encoded_len(3u32, &*value)
                        }
                        TransformType::Maximum(ref value) => {
                            ::prost::encoding::message::encoded_len(4u32, &*value)
                        }
                        TransformType::Minimum(ref value) => {
                            ::prost::encoding::message::encoded_len(5u32, &*value)
                        }
                        TransformType::AppendMissingElements(ref value) => {
                            ::prost::encoding::message::encoded_len(6u32, &*value)
                        }
                        TransformType::RemoveAllFromArray(ref value) => {
                            ::prost::encoding::message::encoded_len(7u32, &*value)
                        }
                    }
                }
            }
            impl ::core::fmt::Debug for TransformType {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        TransformType::SetToServerValue(ref value) => {
                            let wrapper = {
                                struct ScalarWrapper<'a>(&'a i32);
                                impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                    fn fmt(
                                        &self,
                                        f: &mut ::core::fmt::Formatter,
                                    ) -> ::core::fmt::Result {
                                        let res: ::core::result::Result<ServerValue, _> = ::core::convert::TryFrom::try_from(
                                            *self.0,
                                        );
                                        match res {
                                            Err(_) => ::core::fmt::Debug::fmt(&self.0, f),
                                            Ok(en) => ::core::fmt::Debug::fmt(&en, f),
                                        }
                                    }
                                }
                                ScalarWrapper(&*value)
                            };
                            f.debug_tuple("SetToServerValue").field(&wrapper).finish()
                        }
                        TransformType::Increment(ref value) => {
                            let wrapper = &*value;
                            f.debug_tuple("Increment").field(&wrapper).finish()
                        }
                        TransformType::Maximum(ref value) => {
                            let wrapper = &*value;
                            f.debug_tuple("Maximum").field(&wrapper).finish()
                        }
                        TransformType::Minimum(ref value) => {
                            let wrapper = &*value;
                            f.debug_tuple("Minimum").field(&wrapper).finish()
                        }
                        TransformType::AppendMissingElements(ref value) => {
                            let wrapper = &*value;
                            f.debug_tuple("AppendMissingElements")
                                .field(&wrapper)
                                .finish()
                        }
                        TransformType::RemoveAllFromArray(ref value) => {
                            let wrapper = &*value;
                            f.debug_tuple("RemoveAllFromArray").field(&wrapper).finish()
                        }
                    }
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for TransformType {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                            __field5,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "variant identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    4u64 => _serde::__private::Ok(__Field::__field4),
                                    5u64 => _serde::__private::Ok(__Field::__field5),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 6",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "setToServerValue" => {
                                        _serde::__private::Ok(__Field::__field0)
                                    }
                                    "increment" => _serde::__private::Ok(__Field::__field1),
                                    "maximum" => _serde::__private::Ok(__Field::__field2),
                                    "minimum" => _serde::__private::Ok(__Field::__field3),
                                    "appendMissingElements" => {
                                        _serde::__private::Ok(__Field::__field4)
                                    }
                                    "removeAllFromArray" => {
                                        _serde::__private::Ok(__Field::__field5)
                                    }
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"setToServerValue" => {
                                        _serde::__private::Ok(__Field::__field0)
                                    }
                                    b"increment" => _serde::__private::Ok(__Field::__field1),
                                    b"maximum" => _serde::__private::Ok(__Field::__field2),
                                    b"minimum" => _serde::__private::Ok(__Field::__field3),
                                    b"appendMissingElements" => {
                                        _serde::__private::Ok(__Field::__field4)
                                    }
                                    b"removeAllFromArray" => {
                                        _serde::__private::Ok(__Field::__field5)
                                    }
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<TransformType>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = TransformType;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "enum TransformType",
                                )
                            }
                            fn visit_enum<__A>(
                                self,
                                __data: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::EnumAccess<'de>,
                            {
                                match _serde::de::EnumAccess::variant(__data)? {
                                    (__Field::__field0, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                i32,
                                            >(__variant),
                                            TransformType::SetToServerValue,
                                        )
                                    }
                                    (__Field::__field1, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                super::super::Value,
                                            >(__variant),
                                            TransformType::Increment,
                                        )
                                    }
                                    (__Field::__field2, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                super::super::Value,
                                            >(__variant),
                                            TransformType::Maximum,
                                        )
                                    }
                                    (__Field::__field3, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                super::super::Value,
                                            >(__variant),
                                            TransformType::Minimum,
                                        )
                                    }
                                    (__Field::__field4, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                super::super::ArrayValue,
                                            >(__variant),
                                            TransformType::AppendMissingElements,
                                        )
                                    }
                                    (__Field::__field5, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                super::super::ArrayValue,
                                            >(__variant),
                                            TransformType::RemoveAllFromArray,
                                        )
                                    }
                                }
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] = &[
                            "setToServerValue",
                            "increment",
                            "maximum",
                            "minimum",
                            "appendMissingElements",
                            "removeAllFromArray",
                        ];
                        _serde::Deserializer::deserialize_enum(
                            __deserializer,
                            "TransformType",
                            VARIANTS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<TransformType>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for TransformType {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        match *self {
                            TransformType::SetToServerValue(ref __field0) => {
                                _serde::Serializer::serialize_newtype_variant(
                                    __serializer,
                                    "TransformType",
                                    0u32,
                                    "setToServerValue",
                                    __field0,
                                )
                            }
                            TransformType::Increment(ref __field0) => {
                                _serde::Serializer::serialize_newtype_variant(
                                    __serializer,
                                    "TransformType",
                                    1u32,
                                    "increment",
                                    __field0,
                                )
                            }
                            TransformType::Maximum(ref __field0) => {
                                _serde::Serializer::serialize_newtype_variant(
                                    __serializer,
                                    "TransformType",
                                    2u32,
                                    "maximum",
                                    __field0,
                                )
                            }
                            TransformType::Minimum(ref __field0) => {
                                _serde::Serializer::serialize_newtype_variant(
                                    __serializer,
                                    "TransformType",
                                    3u32,
                                    "minimum",
                                    __field0,
                                )
                            }
                            TransformType::AppendMissingElements(ref __field0) => {
                                _serde::Serializer::serialize_newtype_variant(
                                    __serializer,
                                    "TransformType",
                                    4u32,
                                    "appendMissingElements",
                                    __field0,
                                )
                            }
                            TransformType::RemoveAllFromArray(ref __field0) => {
                                _serde::Serializer::serialize_newtype_variant(
                                    __serializer,
                                    "TransformType",
                                    5u32,
                                    "removeAllFromArray",
                                    __field0,
                                )
                            }
                        }
                    }
                }
            };
        }
    }
    /// The result of applying a write.
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct WriteResult {
        /// The last update time of the document after applying the write. Not set
        /// after a `delete`.
        ///
        /// If the write did not actually change the document, this will be the
        /// previous update_time.
        #[prost(message, optional, tag = "1")]
        pub update_time: ::core::option::Option<super::super::protobuf::Timestamp>,
        /// The results of applying each
        /// [DocumentTransform.FieldTransform][google.firestore.v1.DocumentTransform.FieldTransform],
        /// in the same order.
        #[prost(message, repeated, tag = "2")]
        pub transform_results: ::prost::alloc::vec::Vec<Value>,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for WriteResult {
        #[inline]
        fn clone(&self) -> WriteResult {
            WriteResult {
                update_time: ::core::clone::Clone::clone(&self.update_time),
                transform_results: ::core::clone::Clone::clone(&self.transform_results),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for WriteResult {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for WriteResult {
        #[inline]
        fn eq(&self, other: &WriteResult) -> bool {
            self.update_time == other.update_time
                && self.transform_results == other.transform_results
        }
    }
    impl ::prost::Message for WriteResult {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.update_time {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            for msg in &self.transform_results {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "WriteResult";
            match tag {
                1u32 => {
                    let mut value = &mut self.update_time;
                    ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "update_time");
                            error
                        })
                }
                2u32 => {
                    let mut value = &mut self.transform_results;
                    ::prost::encoding::message::merge_repeated(
                            wire_type,
                            value,
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "transform_results");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0
                + self
                    .update_time
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + ::prost::encoding::message::encoded_len_repeated(
                    2u32,
                    &self.transform_results,
                )
        }
        fn clear(&mut self) {
            self.update_time = ::core::option::Option::None;
            self.transform_results.clear();
        }
    }
    impl ::core::default::Default for WriteResult {
        fn default() -> Self {
            WriteResult {
                update_time: ::core::default::Default::default(),
                transform_results: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for WriteResult {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("WriteResult");
            let builder = {
                let wrapper = &self.update_time;
                builder.field("update_time", &wrapper)
            };
            let builder = {
                let wrapper = &self.transform_results;
                builder.field("transform_results", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for WriteResult {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "updateTime" => _serde::__private::Ok(__Field::__field0),
                            "transformResults" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"updateTime" => _serde::__private::Ok(__Field::__field0),
                            b"transformResults" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<WriteResult>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = WriteResult;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct WriteResult",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<super::super::protobuf::Timestamp>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct WriteResult with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::vec::Vec<Value>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct WriteResult with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(WriteResult {
                            update_time: __field0,
                            transform_results: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::core::option::Option<super::super::protobuf::Timestamp>,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            ::prost::alloc::vec::Vec<Value>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "updateTime",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<super::super::protobuf::Timestamp>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "transformResults",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::vec::Vec<Value>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("updateTime")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("transformResults")?
                            }
                        };
                        _serde::__private::Ok(WriteResult {
                            update_time: __field0,
                            transform_results: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "updateTime",
                    "transformResults",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "WriteResult",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<WriteResult>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for WriteResult {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "WriteResult",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "updateTime",
                    &self.update_time,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "transformResults",
                    &self.transform_results,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// A [Document][google.firestore.v1.Document] has changed.
    ///
    /// May be the result of multiple [writes][google.firestore.v1.Write], including
    /// deletes, that ultimately resulted in a new value for the
    /// [Document][google.firestore.v1.Document].
    ///
    /// Multiple [DocumentChange][google.firestore.v1.DocumentChange] messages may be
    /// returned for the same logical change, if multiple targets are affected.
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct DocumentChange {
        /// The new state of the [Document][google.firestore.v1.Document].
        ///
        /// If `mask` is set, contains only fields that were updated or added.
        #[prost(message, optional, tag = "1")]
        pub document: ::core::option::Option<Document>,
        /// A set of target IDs of targets that match this document.
        #[prost(int32, repeated, tag = "5")]
        pub target_ids: ::prost::alloc::vec::Vec<i32>,
        /// A set of target IDs for targets that no longer match this document.
        #[prost(int32, repeated, tag = "6")]
        pub removed_target_ids: ::prost::alloc::vec::Vec<i32>,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for DocumentChange {
        #[inline]
        fn clone(&self) -> DocumentChange {
            DocumentChange {
                document: ::core::clone::Clone::clone(&self.document),
                target_ids: ::core::clone::Clone::clone(&self.target_ids),
                removed_target_ids: ::core::clone::Clone::clone(&self.removed_target_ids),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for DocumentChange {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for DocumentChange {
        #[inline]
        fn eq(&self, other: &DocumentChange) -> bool {
            self.document == other.document && self.target_ids == other.target_ids
                && self.removed_target_ids == other.removed_target_ids
        }
    }
    impl ::prost::Message for DocumentChange {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.document {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            ::prost::encoding::int32::encode_packed(5u32, &self.target_ids, buf);
            ::prost::encoding::int32::encode_packed(6u32, &self.removed_target_ids, buf);
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "DocumentChange";
            match tag {
                1u32 => {
                    let mut value = &mut self.document;
                    ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "document");
                            error
                        })
                }
                5u32 => {
                    let mut value = &mut self.target_ids;
                    ::prost::encoding::int32::merge_repeated(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "target_ids");
                            error
                        })
                }
                6u32 => {
                    let mut value = &mut self.removed_target_ids;
                    ::prost::encoding::int32::merge_repeated(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "removed_target_ids");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0
                + self
                    .document
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + ::prost::encoding::int32::encoded_len_packed(5u32, &self.target_ids)
                + ::prost::encoding::int32::encoded_len_packed(
                    6u32,
                    &self.removed_target_ids,
                )
        }
        fn clear(&mut self) {
            self.document = ::core::option::Option::None;
            self.target_ids.clear();
            self.removed_target_ids.clear();
        }
    }
    impl ::core::default::Default for DocumentChange {
        fn default() -> Self {
            DocumentChange {
                document: ::core::default::Default::default(),
                target_ids: ::prost::alloc::vec::Vec::new(),
                removed_target_ids: ::prost::alloc::vec::Vec::new(),
            }
        }
    }
    impl ::core::fmt::Debug for DocumentChange {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("DocumentChange");
            let builder = {
                let wrapper = &self.document;
                builder.field("document", &wrapper)
            };
            let builder = {
                let wrapper = {
                    struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<i32>);
                    impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                        fn fmt(
                            &self,
                            f: &mut ::core::fmt::Formatter,
                        ) -> ::core::fmt::Result {
                            let mut vec_builder = f.debug_list();
                            for v in self.0 {
                                #[allow(non_snake_case)]
                                fn Inner<T>(v: T) -> T {
                                    v
                                }
                                vec_builder.entry(&Inner(v));
                            }
                            vec_builder.finish()
                        }
                    }
                    ScalarWrapper(&self.target_ids)
                };
                builder.field("target_ids", &wrapper)
            };
            let builder = {
                let wrapper = {
                    struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<i32>);
                    impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                        fn fmt(
                            &self,
                            f: &mut ::core::fmt::Formatter,
                        ) -> ::core::fmt::Result {
                            let mut vec_builder = f.debug_list();
                            for v in self.0 {
                                #[allow(non_snake_case)]
                                fn Inner<T>(v: T) -> T {
                                    v
                                }
                                vec_builder.entry(&Inner(v));
                            }
                            vec_builder.finish()
                        }
                    }
                    ScalarWrapper(&self.removed_target_ids)
                };
                builder.field("removed_target_ids", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for DocumentChange {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "document" => _serde::__private::Ok(__Field::__field0),
                            "targetIds" => _serde::__private::Ok(__Field::__field1),
                            "removedTargetIds" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"document" => _serde::__private::Ok(__Field::__field0),
                            b"targetIds" => _serde::__private::Ok(__Field::__field1),
                            b"removedTargetIds" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<DocumentChange>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = DocumentChange;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct DocumentChange",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<Document>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct DocumentChange with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::vec::Vec<i32>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct DocumentChange with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::vec::Vec<i32>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct DocumentChange with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(DocumentChange {
                            document: __field0,
                            target_ids: __field1,
                            removed_target_ids: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::core::option::Option<Document>,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            ::prost::alloc::vec::Vec<i32>,
                        > = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            ::prost::alloc::vec::Vec<i32>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "document",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<Document>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "targetIds",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::vec::Vec<i32>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "removedTargetIds",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::vec::Vec<i32>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("document")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("targetIds")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("removedTargetIds")?
                            }
                        };
                        _serde::__private::Ok(DocumentChange {
                            document: __field0,
                            target_ids: __field1,
                            removed_target_ids: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "document",
                    "targetIds",
                    "removedTargetIds",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "DocumentChange",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<DocumentChange>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for DocumentChange {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "DocumentChange",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "document",
                    &self.document,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "targetIds",
                    &self.target_ids,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "removedTargetIds",
                    &self.removed_target_ids,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// A [Document][google.firestore.v1.Document] has been deleted.
    ///
    /// May be the result of multiple [writes][google.firestore.v1.Write], including
    /// updates, the last of which deleted the
    /// [Document][google.firestore.v1.Document].
    ///
    /// Multiple [DocumentDelete][google.firestore.v1.DocumentDelete] messages may be
    /// returned for the same logical delete, if multiple targets are affected.
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct DocumentDelete {
        /// The resource name of the [Document][google.firestore.v1.Document] that was
        /// deleted.
        #[prost(string, tag = "1")]
        pub document: ::prost::alloc::string::String,
        /// A set of target IDs for targets that previously matched this entity.
        #[prost(int32, repeated, tag = "6")]
        pub removed_target_ids: ::prost::alloc::vec::Vec<i32>,
        /// The read timestamp at which the delete was observed.
        ///
        /// Greater or equal to the `commit_time` of the delete.
        #[prost(message, optional, tag = "4")]
        pub read_time: ::core::option::Option<super::super::protobuf::Timestamp>,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for DocumentDelete {
        #[inline]
        fn clone(&self) -> DocumentDelete {
            DocumentDelete {
                document: ::core::clone::Clone::clone(&self.document),
                removed_target_ids: ::core::clone::Clone::clone(
                    &self.removed_target_ids,
                ),
                read_time: ::core::clone::Clone::clone(&self.read_time),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for DocumentDelete {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for DocumentDelete {
        #[inline]
        fn eq(&self, other: &DocumentDelete) -> bool {
            self.document == other.document
                && self.removed_target_ids == other.removed_target_ids
                && self.read_time == other.read_time
        }
    }
    impl ::prost::Message for DocumentDelete {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.document != "" {
                ::prost::encoding::string::encode(1u32, &self.document, buf);
            }
            if let Some(ref msg) = self.read_time {
                ::prost::encoding::message::encode(4u32, msg, buf);
            }
            ::prost::encoding::int32::encode_packed(6u32, &self.removed_target_ids, buf);
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "DocumentDelete";
            match tag {
                1u32 => {
                    let mut value = &mut self.document;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "document");
                            error
                        })
                }
                4u32 => {
                    let mut value = &mut self.read_time;
                    ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "read_time");
                            error
                        })
                }
                6u32 => {
                    let mut value = &mut self.removed_target_ids;
                    ::prost::encoding::int32::merge_repeated(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "removed_target_ids");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0
                + if self.document != "" {
                    ::prost::encoding::string::encoded_len(1u32, &self.document)
                } else {
                    0
                }
                + self
                    .read_time
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(4u32, msg))
                + ::prost::encoding::int32::encoded_len_packed(
                    6u32,
                    &self.removed_target_ids,
                )
        }
        fn clear(&mut self) {
            self.document.clear();
            self.read_time = ::core::option::Option::None;
            self.removed_target_ids.clear();
        }
    }
    impl ::core::default::Default for DocumentDelete {
        fn default() -> Self {
            DocumentDelete {
                document: ::prost::alloc::string::String::new(),
                read_time: ::core::default::Default::default(),
                removed_target_ids: ::prost::alloc::vec::Vec::new(),
            }
        }
    }
    impl ::core::fmt::Debug for DocumentDelete {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("DocumentDelete");
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.document)
                };
                builder.field("document", &wrapper)
            };
            let builder = {
                let wrapper = {
                    struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<i32>);
                    impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                        fn fmt(
                            &self,
                            f: &mut ::core::fmt::Formatter,
                        ) -> ::core::fmt::Result {
                            let mut vec_builder = f.debug_list();
                            for v in self.0 {
                                #[allow(non_snake_case)]
                                fn Inner<T>(v: T) -> T {
                                    v
                                }
                                vec_builder.entry(&Inner(v));
                            }
                            vec_builder.finish()
                        }
                    }
                    ScalarWrapper(&self.removed_target_ids)
                };
                builder.field("removed_target_ids", &wrapper)
            };
            let builder = {
                let wrapper = &self.read_time;
                builder.field("read_time", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for DocumentDelete {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "document" => _serde::__private::Ok(__Field::__field0),
                            "removedTargetIds" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            "readTime" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"document" => _serde::__private::Ok(__Field::__field0),
                            b"removedTargetIds" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            b"readTime" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<DocumentDelete>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = DocumentDelete;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct DocumentDelete",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::string::String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct DocumentDelete with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::vec::Vec<i32>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct DocumentDelete with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<super::super::protobuf::Timestamp>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct DocumentDelete with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(DocumentDelete {
                            document: __field0,
                            removed_target_ids: __field1,
                            read_time: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::prost::alloc::string::String,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            ::prost::alloc::vec::Vec<i32>,
                        > = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            ::core::option::Option<super::super::protobuf::Timestamp>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "document",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::string::String,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "removedTargetIds",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::vec::Vec<i32>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "readTime",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<super::super::protobuf::Timestamp>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("document")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("removedTargetIds")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("readTime")?
                            }
                        };
                        _serde::__private::Ok(DocumentDelete {
                            document: __field0,
                            removed_target_ids: __field1,
                            read_time: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "document",
                    "removedTargetIds",
                    "readTime",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "DocumentDelete",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<DocumentDelete>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for DocumentDelete {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "DocumentDelete",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "document",
                    &self.document,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "removedTargetIds",
                    &self.removed_target_ids,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "readTime",
                    &self.read_time,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// A [Document][google.firestore.v1.Document] has been removed from the view of
    /// the targets.
    ///
    /// Sent if the document is no longer relevant to a target and is out of view.
    /// Can be sent instead of a DocumentDelete or a DocumentChange if the server
    /// can not send the new value of the document.
    ///
    /// Multiple [DocumentRemove][google.firestore.v1.DocumentRemove] messages may be
    /// returned for the same logical write or delete, if multiple targets are
    /// affected.
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct DocumentRemove {
        /// The resource name of the [Document][google.firestore.v1.Document] that has
        /// gone out of view.
        #[prost(string, tag = "1")]
        pub document: ::prost::alloc::string::String,
        /// A set of target IDs for targets that previously matched this document.
        #[prost(int32, repeated, tag = "2")]
        pub removed_target_ids: ::prost::alloc::vec::Vec<i32>,
        /// The read timestamp at which the remove was observed.
        ///
        /// Greater or equal to the `commit_time` of the change/delete/remove.
        #[prost(message, optional, tag = "4")]
        pub read_time: ::core::option::Option<super::super::protobuf::Timestamp>,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for DocumentRemove {
        #[inline]
        fn clone(&self) -> DocumentRemove {
            DocumentRemove {
                document: ::core::clone::Clone::clone(&self.document),
                removed_target_ids: ::core::clone::Clone::clone(
                    &self.removed_target_ids,
                ),
                read_time: ::core::clone::Clone::clone(&self.read_time),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for DocumentRemove {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for DocumentRemove {
        #[inline]
        fn eq(&self, other: &DocumentRemove) -> bool {
            self.document == other.document
                && self.removed_target_ids == other.removed_target_ids
                && self.read_time == other.read_time
        }
    }
    impl ::prost::Message for DocumentRemove {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.document != "" {
                ::prost::encoding::string::encode(1u32, &self.document, buf);
            }
            ::prost::encoding::int32::encode_packed(2u32, &self.removed_target_ids, buf);
            if let Some(ref msg) = self.read_time {
                ::prost::encoding::message::encode(4u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "DocumentRemove";
            match tag {
                1u32 => {
                    let mut value = &mut self.document;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "document");
                            error
                        })
                }
                2u32 => {
                    let mut value = &mut self.removed_target_ids;
                    ::prost::encoding::int32::merge_repeated(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "removed_target_ids");
                            error
                        })
                }
                4u32 => {
                    let mut value = &mut self.read_time;
                    ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "read_time");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0
                + if self.document != "" {
                    ::prost::encoding::string::encoded_len(1u32, &self.document)
                } else {
                    0
                }
                + ::prost::encoding::int32::encoded_len_packed(
                    2u32,
                    &self.removed_target_ids,
                )
                + self
                    .read_time
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(4u32, msg))
        }
        fn clear(&mut self) {
            self.document.clear();
            self.removed_target_ids.clear();
            self.read_time = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for DocumentRemove {
        fn default() -> Self {
            DocumentRemove {
                document: ::prost::alloc::string::String::new(),
                removed_target_ids: ::prost::alloc::vec::Vec::new(),
                read_time: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for DocumentRemove {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("DocumentRemove");
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.document)
                };
                builder.field("document", &wrapper)
            };
            let builder = {
                let wrapper = {
                    struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<i32>);
                    impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                        fn fmt(
                            &self,
                            f: &mut ::core::fmt::Formatter,
                        ) -> ::core::fmt::Result {
                            let mut vec_builder = f.debug_list();
                            for v in self.0 {
                                #[allow(non_snake_case)]
                                fn Inner<T>(v: T) -> T {
                                    v
                                }
                                vec_builder.entry(&Inner(v));
                            }
                            vec_builder.finish()
                        }
                    }
                    ScalarWrapper(&self.removed_target_ids)
                };
                builder.field("removed_target_ids", &wrapper)
            };
            let builder = {
                let wrapper = &self.read_time;
                builder.field("read_time", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for DocumentRemove {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "document" => _serde::__private::Ok(__Field::__field0),
                            "removedTargetIds" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            "readTime" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"document" => _serde::__private::Ok(__Field::__field0),
                            b"removedTargetIds" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            b"readTime" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<DocumentRemove>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = DocumentRemove;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct DocumentRemove",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::string::String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct DocumentRemove with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::vec::Vec<i32>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct DocumentRemove with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<super::super::protobuf::Timestamp>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct DocumentRemove with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(DocumentRemove {
                            document: __field0,
                            removed_target_ids: __field1,
                            read_time: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::prost::alloc::string::String,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            ::prost::alloc::vec::Vec<i32>,
                        > = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            ::core::option::Option<super::super::protobuf::Timestamp>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "document",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::string::String,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "removedTargetIds",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::vec::Vec<i32>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "readTime",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<super::super::protobuf::Timestamp>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("document")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("removedTargetIds")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("readTime")?
                            }
                        };
                        _serde::__private::Ok(DocumentRemove {
                            document: __field0,
                            removed_target_ids: __field1,
                            read_time: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "document",
                    "removedTargetIds",
                    "readTime",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "DocumentRemove",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<DocumentRemove>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for DocumentRemove {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "DocumentRemove",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "document",
                    &self.document,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "removedTargetIds",
                    &self.removed_target_ids,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "readTime",
                    &self.read_time,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// A digest of all the documents that match a given target.
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct ExistenceFilter {
        /// The target ID to which this filter applies.
        #[prost(int32, tag = "1")]
        pub target_id: i32,
        /// The total count of documents that match
        /// [target_id][google.firestore.v1.ExistenceFilter.target_id].
        ///
        /// If different from the count of documents in the client that match, the
        /// client must manually determine which documents no longer match the target.
        ///
        /// The client can use the `unchanged_names` bloom filter to assist with
        /// this determination by testing ALL the document names against the filter;
        /// if the document name is NOT in the filter, it means the document no
        /// longer matches the target.
        #[prost(int32, tag = "2")]
        pub count: i32,
        /// A bloom filter that, despite its name, contains the UTF-8 byte encodings of
        /// the resource names of ALL the documents that match
        /// [target_id][google.firestore.v1.ExistenceFilter.target_id], in the form
        /// `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
        ///
        /// This bloom filter may be omitted at the server's discretion, such as if it
        /// is deemed that the client will not make use of it or if it is too
        /// computationally expensive to calculate or transmit. Clients must gracefully
        /// handle this field being absent by falling back to the logic used before
        /// this field existed; that is, re-add the target without a resume token to
        /// figure out which documents in the client's cache are out of sync.
        #[prost(message, optional, tag = "3")]
        pub unchanged_names: ::core::option::Option<BloomFilter>,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for ExistenceFilter {
        #[inline]
        fn clone(&self) -> ExistenceFilter {
            ExistenceFilter {
                target_id: ::core::clone::Clone::clone(&self.target_id),
                count: ::core::clone::Clone::clone(&self.count),
                unchanged_names: ::core::clone::Clone::clone(&self.unchanged_names),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for ExistenceFilter {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for ExistenceFilter {
        #[inline]
        fn eq(&self, other: &ExistenceFilter) -> bool {
            self.target_id == other.target_id && self.count == other.count
                && self.unchanged_names == other.unchanged_names
        }
    }
    impl ::prost::Message for ExistenceFilter {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.target_id != 0i32 {
                ::prost::encoding::int32::encode(1u32, &self.target_id, buf);
            }
            if self.count != 0i32 {
                ::prost::encoding::int32::encode(2u32, &self.count, buf);
            }
            if let Some(ref msg) = self.unchanged_names {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ExistenceFilter";
            match tag {
                1u32 => {
                    let mut value = &mut self.target_id;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "target_id");
                            error
                        })
                }
                2u32 => {
                    let mut value = &mut self.count;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "count");
                            error
                        })
                }
                3u32 => {
                    let mut value = &mut self.unchanged_names;
                    ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "unchanged_names");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0
                + if self.target_id != 0i32 {
                    ::prost::encoding::int32::encoded_len(1u32, &self.target_id)
                } else {
                    0
                }
                + if self.count != 0i32 {
                    ::prost::encoding::int32::encoded_len(2u32, &self.count)
                } else {
                    0
                }
                + self
                    .unchanged_names
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(3u32, msg))
        }
        fn clear(&mut self) {
            self.target_id = 0i32;
            self.count = 0i32;
            self.unchanged_names = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for ExistenceFilter {
        fn default() -> Self {
            ExistenceFilter {
                target_id: 0i32,
                count: 0i32,
                unchanged_names: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for ExistenceFilter {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ExistenceFilter");
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.target_id)
                };
                builder.field("target_id", &wrapper)
            };
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.count)
                };
                builder.field("count", &wrapper)
            };
            let builder = {
                let wrapper = &self.unchanged_names;
                builder.field("unchanged_names", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ExistenceFilter {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "targetId" => _serde::__private::Ok(__Field::__field0),
                            "count" => _serde::__private::Ok(__Field::__field1),
                            "unchangedNames" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"targetId" => _serde::__private::Ok(__Field::__field0),
                            b"count" => _serde::__private::Ok(__Field::__field1),
                            b"unchangedNames" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ExistenceFilter>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ExistenceFilter;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ExistenceFilter",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            i32,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ExistenceFilter with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            i32,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct ExistenceFilter with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<BloomFilter>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct ExistenceFilter with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ExistenceFilter {
                            target_id: __field0,
                            count: __field1,
                            unchanged_names: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<i32> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<i32> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            ::core::option::Option<BloomFilter>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "targetId",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i32>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("count"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i32>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "unchangedNames",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<BloomFilter>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("targetId")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("count")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("unchangedNames")?
                            }
                        };
                        _serde::__private::Ok(ExistenceFilter {
                            target_id: __field0,
                            count: __field1,
                            unchanged_names: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "targetId",
                    "count",
                    "unchangedNames",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ExistenceFilter",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ExistenceFilter>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ExistenceFilter {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ExistenceFilter",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "targetId",
                    &self.target_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "count",
                    &self.count,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "unchangedNames",
                    &self.unchanged_names,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// The request for
    /// [Firestore.GetDocument][google.firestore.v1.Firestore.GetDocument].
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct GetDocumentRequest {
        /// Required. The resource name of the Document to get. In the format:
        /// `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// The fields to return. If not set, returns all fields.
        ///
        /// If the document has a field that is not present in this mask, that field
        /// will not be returned in the response.
        #[prost(message, optional, tag = "2")]
        pub mask: ::core::option::Option<DocumentMask>,
        /// The consistency mode for this transaction.
        /// If not set, defaults to strong consistency.
        #[prost(oneof = "get_document_request::ConsistencySelector", tags = "3, 5")]
        pub consistency_selector: ::core::option::Option<
            get_document_request::ConsistencySelector,
        >,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for GetDocumentRequest {
        #[inline]
        fn clone(&self) -> GetDocumentRequest {
            GetDocumentRequest {
                name: ::core::clone::Clone::clone(&self.name),
                mask: ::core::clone::Clone::clone(&self.mask),
                consistency_selector: ::core::clone::Clone::clone(
                    &self.consistency_selector,
                ),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for GetDocumentRequest {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for GetDocumentRequest {
        #[inline]
        fn eq(&self, other: &GetDocumentRequest) -> bool {
            self.name == other.name && self.mask == other.mask
                && self.consistency_selector == other.consistency_selector
        }
    }
    impl ::prost::Message for GetDocumentRequest {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.name != "" {
                ::prost::encoding::string::encode(1u32, &self.name, buf);
            }
            if let Some(ref msg) = self.mask {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            if let Some(ref oneof) = self.consistency_selector {
                oneof.encode(buf)
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "GetDocumentRequest";
            match tag {
                1u32 => {
                    let mut value = &mut self.name;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "name");
                            error
                        })
                }
                2u32 => {
                    let mut value = &mut self.mask;
                    ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "mask");
                            error
                        })
                }
                3u32 | 5u32 => {
                    let mut value = &mut self.consistency_selector;
                    get_document_request::ConsistencySelector::merge(
                            value,
                            tag,
                            wire_type,
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "consistency_selector");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0
                + if self.name != "" {
                    ::prost::encoding::string::encoded_len(1u32, &self.name)
                } else {
                    0
                }
                + self
                    .mask
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
                + self
                    .consistency_selector
                    .as_ref()
                    .map_or(0, get_document_request::ConsistencySelector::encoded_len)
        }
        fn clear(&mut self) {
            self.name.clear();
            self.mask = ::core::option::Option::None;
            self.consistency_selector = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for GetDocumentRequest {
        fn default() -> Self {
            GetDocumentRequest {
                name: ::prost::alloc::string::String::new(),
                mask: ::core::default::Default::default(),
                consistency_selector: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for GetDocumentRequest {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("GetDocumentRequest");
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.name)
                };
                builder.field("name", &wrapper)
            };
            let builder = {
                let wrapper = &self.mask;
                builder.field("mask", &wrapper)
            };
            let builder = {
                let wrapper = &self.consistency_selector;
                builder.field("consistency_selector", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for GetDocumentRequest {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "name" => _serde::__private::Ok(__Field::__field0),
                            "mask" => _serde::__private::Ok(__Field::__field1),
                            "consistencySelector" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"name" => _serde::__private::Ok(__Field::__field0),
                            b"mask" => _serde::__private::Ok(__Field::__field1),
                            b"consistencySelector" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<GetDocumentRequest>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = GetDocumentRequest;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct GetDocumentRequest",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::string::String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct GetDocumentRequest with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<DocumentMask>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct GetDocumentRequest with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<
                                get_document_request::ConsistencySelector,
                            >,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct GetDocumentRequest with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(GetDocumentRequest {
                            name: __field0,
                            mask: __field1,
                            consistency_selector: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::prost::alloc::string::String,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            ::core::option::Option<DocumentMask>,
                        > = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            ::core::option::Option<
                                get_document_request::ConsistencySelector,
                            >,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::string::String,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("mask"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<DocumentMask>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "consistencySelector",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<
                                                get_document_request::ConsistencySelector,
                                            >,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("name")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("mask")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("consistencySelector")?
                            }
                        };
                        _serde::__private::Ok(GetDocumentRequest {
                            name: __field0,
                            mask: __field1,
                            consistency_selector: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "name",
                    "mask",
                    "consistencySelector",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "GetDocumentRequest",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<GetDocumentRequest>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for GetDocumentRequest {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "GetDocumentRequest",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "name",
                    &self.name,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "mask",
                    &self.mask,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "consistencySelector",
                    &self.consistency_selector,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// Nested message and enum types in `GetDocumentRequest`.
    pub mod get_document_request {
        /// The consistency mode for this transaction.
        /// If not set, defaults to strong consistency.
        #[serde(rename_all = "camelCase")]
        #[allow(clippy::derive_partial_eq_without_eq)]
        pub enum ConsistencySelector {
            /// Reads the document in a transaction.
            #[prost(bytes, tag = "3")]
            Transaction(::prost::alloc::vec::Vec<u8>),
            /// Reads the version of the document at the given time.
            ///
            /// This must be a microsecond precision timestamp within the past one hour,
            /// or if Point-in-Time Recovery is enabled, can additionally be a whole
            /// minute timestamp within the past 7 days.
            #[prost(message, tag = "5")]
            ReadTime(super::super::super::protobuf::Timestamp),
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::clone::Clone for ConsistencySelector {
            #[inline]
            fn clone(&self) -> ConsistencySelector {
                match self {
                    ConsistencySelector::Transaction(__self_0) => {
                        ConsistencySelector::Transaction(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    ConsistencySelector::ReadTime(__self_0) => {
                        ConsistencySelector::ReadTime(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::marker::StructuralPartialEq for ConsistencySelector {}
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::cmp::PartialEq for ConsistencySelector {
            #[inline]
            fn eq(&self, other: &ConsistencySelector) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
                    && match (self, other) {
                        (
                            ConsistencySelector::Transaction(__self_0),
                            ConsistencySelector::Transaction(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            ConsistencySelector::ReadTime(__self_0),
                            ConsistencySelector::ReadTime(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        impl ConsistencySelector {
            /// Encodes the message to a buffer.
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    ConsistencySelector::Transaction(ref value) => {
                        ::prost::encoding::bytes::encode(3u32, &*value, buf);
                    }
                    ConsistencySelector::ReadTime(ref value) => {
                        ::prost::encoding::message::encode(5u32, &*value, buf);
                    }
                }
            }
            /// Decodes an instance of the message from a buffer, and merges it into self.
            pub fn merge<B>(
                field: &mut ::core::option::Option<ConsistencySelector>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag {
                    3u32 => {
                        match field {
                            ::core::option::Option::Some(
                                ConsistencySelector::Transaction(ref mut value),
                            ) => {
                                ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            ConsistencySelector::Transaction(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    5u32 => {
                        match field {
                            ::core::option::Option::Some(
                                ConsistencySelector::ReadTime(ref mut value),
                            ) => {
                                ::prost::encoding::message::merge(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            ConsistencySelector::ReadTime(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    _ => {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "internal error: entered unreachable code: {0}",
                                format_args!("invalid ConsistencySelector tag: {0}", tag),
                            ),
                        );
                    }
                }
            }
            /// Returns the encoded length of the message without a length delimiter.
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    ConsistencySelector::Transaction(ref value) => {
                        ::prost::encoding::bytes::encoded_len(3u32, &*value)
                    }
                    ConsistencySelector::ReadTime(ref value) => {
                        ::prost::encoding::message::encoded_len(5u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for ConsistencySelector {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ConsistencySelector::Transaction(ref value) => {
                        let wrapper = {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("Transaction").field(&wrapper).finish()
                    }
                    ConsistencySelector::ReadTime(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ReadTime").field(&wrapper).finish()
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ConsistencySelector {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 2",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "transaction" => _serde::__private::Ok(__Field::__field0),
                                "readTime" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"transaction" => _serde::__private::Ok(__Field::__field0),
                                b"readTime" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ConsistencySelector>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ConsistencySelector;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum ConsistencySelector",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            ::prost::alloc::vec::Vec<u8>,
                                        >(__variant),
                                        ConsistencySelector::Transaction,
                                    )
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            super::super::super::protobuf::Timestamp,
                                        >(__variant),
                                        ConsistencySelector::ReadTime,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "transaction",
                        "readTime",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "ConsistencySelector",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                ConsistencySelector,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ConsistencySelector {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        ConsistencySelector::Transaction(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "ConsistencySelector",
                                0u32,
                                "transaction",
                                __field0,
                            )
                        }
                        ConsistencySelector::ReadTime(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "ConsistencySelector",
                                1u32,
                                "readTime",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
    }
    /// The request for
    /// [Firestore.ListDocuments][google.firestore.v1.Firestore.ListDocuments].
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct ListDocumentsRequest {
        /// Required. The parent resource name. In the format:
        /// `projects/{project_id}/databases/{database_id}/documents` or
        /// `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
        ///
        /// For example:
        /// `projects/my-project/databases/my-database/documents` or
        /// `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`
        #[prost(string, tag = "1")]
        pub parent: ::prost::alloc::string::String,
        /// Optional. The collection ID, relative to `parent`, to list.
        ///
        /// For example: `chatrooms` or `messages`.
        ///
        /// This is optional, and when not provided, Firestore will list documents
        /// from all collections under the provided `parent`.
        #[prost(string, tag = "2")]
        pub collection_id: ::prost::alloc::string::String,
        /// Optional. The maximum number of documents to return in a single response.
        ///
        /// Firestore may return fewer than this value.
        #[prost(int32, tag = "3")]
        pub page_size: i32,
        /// Optional. A page token, received from a previous `ListDocuments` response.
        ///
        /// Provide this to retrieve the subsequent page. When paginating, all other
        /// parameters (with the exception of `page_size`) must match the values set
        /// in the request that generated the page token.
        #[prost(string, tag = "4")]
        pub page_token: ::prost::alloc::string::String,
        /// Optional. The optional ordering of the documents to return.
        ///
        /// For example: `priority desc, __name__ desc`.
        ///
        /// This mirrors the [`ORDER BY`][google.firestore.v1.StructuredQuery.order_by]
        /// used in Firestore queries but in a string representation. When absent,
        /// documents are ordered based on `__name__ ASC`.
        #[prost(string, tag = "6")]
        pub order_by: ::prost::alloc::string::String,
        /// Optional. The fields to return. If not set, returns all fields.
        ///
        /// If a document has a field that is not present in this mask, that field
        /// will not be returned in the response.
        #[prost(message, optional, tag = "7")]
        pub mask: ::core::option::Option<DocumentMask>,
        /// If the list should show missing documents.
        ///
        /// A document is missing if it does not exist, but there are sub-documents
        /// nested underneath it. When true, such missing documents will be returned
        /// with a key but will not have fields,
        /// [`create_time`][google.firestore.v1.Document.create_time], or
        /// [`update_time`][google.firestore.v1.Document.update_time] set.
        ///
        /// Requests with `show_missing` may not specify `where` or `order_by`.
        #[prost(bool, tag = "12")]
        pub show_missing: bool,
        /// The consistency mode for this transaction.
        /// If not set, defaults to strong consistency.
        #[prost(oneof = "list_documents_request::ConsistencySelector", tags = "8, 10")]
        pub consistency_selector: ::core::option::Option<
            list_documents_request::ConsistencySelector,
        >,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for ListDocumentsRequest {
        #[inline]
        fn clone(&self) -> ListDocumentsRequest {
            ListDocumentsRequest {
                parent: ::core::clone::Clone::clone(&self.parent),
                collection_id: ::core::clone::Clone::clone(&self.collection_id),
                page_size: ::core::clone::Clone::clone(&self.page_size),
                page_token: ::core::clone::Clone::clone(&self.page_token),
                order_by: ::core::clone::Clone::clone(&self.order_by),
                mask: ::core::clone::Clone::clone(&self.mask),
                show_missing: ::core::clone::Clone::clone(&self.show_missing),
                consistency_selector: ::core::clone::Clone::clone(
                    &self.consistency_selector,
                ),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for ListDocumentsRequest {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for ListDocumentsRequest {
        #[inline]
        fn eq(&self, other: &ListDocumentsRequest) -> bool {
            self.parent == other.parent && self.collection_id == other.collection_id
                && self.page_size == other.page_size
                && self.page_token == other.page_token && self.order_by == other.order_by
                && self.mask == other.mask && self.show_missing == other.show_missing
                && self.consistency_selector == other.consistency_selector
        }
    }
    impl ::prost::Message for ListDocumentsRequest {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.parent != "" {
                ::prost::encoding::string::encode(1u32, &self.parent, buf);
            }
            if self.collection_id != "" {
                ::prost::encoding::string::encode(2u32, &self.collection_id, buf);
            }
            if self.page_size != 0i32 {
                ::prost::encoding::int32::encode(3u32, &self.page_size, buf);
            }
            if self.page_token != "" {
                ::prost::encoding::string::encode(4u32, &self.page_token, buf);
            }
            if self.order_by != "" {
                ::prost::encoding::string::encode(6u32, &self.order_by, buf);
            }
            if let Some(ref msg) = self.mask {
                ::prost::encoding::message::encode(7u32, msg, buf);
            }
            if let Some(ref oneof) = self.consistency_selector {
                oneof.encode(buf)
            }
            if self.show_missing != false {
                ::prost::encoding::bool::encode(12u32, &self.show_missing, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ListDocumentsRequest";
            match tag {
                1u32 => {
                    let mut value = &mut self.parent;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "parent");
                            error
                        })
                }
                2u32 => {
                    let mut value = &mut self.collection_id;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "collection_id");
                            error
                        })
                }
                3u32 => {
                    let mut value = &mut self.page_size;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "page_size");
                            error
                        })
                }
                4u32 => {
                    let mut value = &mut self.page_token;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "page_token");
                            error
                        })
                }
                6u32 => {
                    let mut value = &mut self.order_by;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "order_by");
                            error
                        })
                }
                7u32 => {
                    let mut value = &mut self.mask;
                    ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "mask");
                            error
                        })
                }
                8u32 | 10u32 => {
                    let mut value = &mut self.consistency_selector;
                    list_documents_request::ConsistencySelector::merge(
                            value,
                            tag,
                            wire_type,
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "consistency_selector");
                            error
                        })
                }
                12u32 => {
                    let mut value = &mut self.show_missing;
                    ::prost::encoding::bool::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "show_missing");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0
                + if self.parent != "" {
                    ::prost::encoding::string::encoded_len(1u32, &self.parent)
                } else {
                    0
                }
                + if self.collection_id != "" {
                    ::prost::encoding::string::encoded_len(2u32, &self.collection_id)
                } else {
                    0
                }
                + if self.page_size != 0i32 {
                    ::prost::encoding::int32::encoded_len(3u32, &self.page_size)
                } else {
                    0
                }
                + if self.page_token != "" {
                    ::prost::encoding::string::encoded_len(4u32, &self.page_token)
                } else {
                    0
                }
                + if self.order_by != "" {
                    ::prost::encoding::string::encoded_len(6u32, &self.order_by)
                } else {
                    0
                }
                + self
                    .mask
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(7u32, msg))
                + self
                    .consistency_selector
                    .as_ref()
                    .map_or(0, list_documents_request::ConsistencySelector::encoded_len)
                + if self.show_missing != false {
                    ::prost::encoding::bool::encoded_len(12u32, &self.show_missing)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.parent.clear();
            self.collection_id.clear();
            self.page_size = 0i32;
            self.page_token.clear();
            self.order_by.clear();
            self.mask = ::core::option::Option::None;
            self.consistency_selector = ::core::option::Option::None;
            self.show_missing = false;
        }
    }
    impl ::core::default::Default for ListDocumentsRequest {
        fn default() -> Self {
            ListDocumentsRequest {
                parent: ::prost::alloc::string::String::new(),
                collection_id: ::prost::alloc::string::String::new(),
                page_size: 0i32,
                page_token: ::prost::alloc::string::String::new(),
                order_by: ::prost::alloc::string::String::new(),
                mask: ::core::default::Default::default(),
                consistency_selector: ::core::default::Default::default(),
                show_missing: false,
            }
        }
    }
    impl ::core::fmt::Debug for ListDocumentsRequest {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ListDocumentsRequest");
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.parent)
                };
                builder.field("parent", &wrapper)
            };
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.collection_id)
                };
                builder.field("collection_id", &wrapper)
            };
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.page_size)
                };
                builder.field("page_size", &wrapper)
            };
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.page_token)
                };
                builder.field("page_token", &wrapper)
            };
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.order_by)
                };
                builder.field("order_by", &wrapper)
            };
            let builder = {
                let wrapper = &self.mask;
                builder.field("mask", &wrapper)
            };
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.show_missing)
                };
                builder.field("show_missing", &wrapper)
            };
            let builder = {
                let wrapper = &self.consistency_selector;
                builder.field("consistency_selector", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ListDocumentsRequest {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "parent" => _serde::__private::Ok(__Field::__field0),
                            "collectionId" => _serde::__private::Ok(__Field::__field1),
                            "pageSize" => _serde::__private::Ok(__Field::__field2),
                            "pageToken" => _serde::__private::Ok(__Field::__field3),
                            "orderBy" => _serde::__private::Ok(__Field::__field4),
                            "mask" => _serde::__private::Ok(__Field::__field5),
                            "showMissing" => _serde::__private::Ok(__Field::__field6),
                            "consistencySelector" => {
                                _serde::__private::Ok(__Field::__field7)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"parent" => _serde::__private::Ok(__Field::__field0),
                            b"collectionId" => _serde::__private::Ok(__Field::__field1),
                            b"pageSize" => _serde::__private::Ok(__Field::__field2),
                            b"pageToken" => _serde::__private::Ok(__Field::__field3),
                            b"orderBy" => _serde::__private::Ok(__Field::__field4),
                            b"mask" => _serde::__private::Ok(__Field::__field5),
                            b"showMissing" => _serde::__private::Ok(__Field::__field6),
                            b"consistencySelector" => {
                                _serde::__private::Ok(__Field::__field7)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ListDocumentsRequest>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ListDocumentsRequest;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ListDocumentsRequest",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::string::String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ListDocumentsRequest with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::string::String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct ListDocumentsRequest with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            i32,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct ListDocumentsRequest with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::string::String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct ListDocumentsRequest with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::string::String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct ListDocumentsRequest with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<DocumentMask>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct ListDocumentsRequest with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct ListDocumentsRequest with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field7 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<
                                list_documents_request::ConsistencySelector,
                            >,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct ListDocumentsRequest with 8 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ListDocumentsRequest {
                            parent: __field0,
                            collection_id: __field1,
                            page_size: __field2,
                            page_token: __field3,
                            order_by: __field4,
                            mask: __field5,
                            show_missing: __field6,
                            consistency_selector: __field7,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::prost::alloc::string::String,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            ::prost::alloc::string::String,
                        > = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<i32> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<
                            ::prost::alloc::string::String,
                        > = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<
                            ::prost::alloc::string::String,
                        > = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<
                            ::core::option::Option<DocumentMask>,
                        > = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<
                            ::core::option::Option<
                                list_documents_request::ConsistencySelector,
                            >,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("parent"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::string::String,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "collectionId",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::string::String,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "pageSize",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i32>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "pageToken",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::string::String,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "orderBy",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::string::String,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("mask"),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<DocumentMask>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "showMissing",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "consistencySelector",
                                            ),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<
                                                list_documents_request::ConsistencySelector,
                                            >,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("parent")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("collectionId")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("pageSize")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("pageToken")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("orderBy")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("mask")?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("showMissing")?
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("consistencySelector")?
                            }
                        };
                        _serde::__private::Ok(ListDocumentsRequest {
                            parent: __field0,
                            collection_id: __field1,
                            page_size: __field2,
                            page_token: __field3,
                            order_by: __field4,
                            mask: __field5,
                            show_missing: __field6,
                            consistency_selector: __field7,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "parent",
                    "collectionId",
                    "pageSize",
                    "pageToken",
                    "orderBy",
                    "mask",
                    "showMissing",
                    "consistencySelector",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ListDocumentsRequest",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ListDocumentsRequest>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ListDocumentsRequest {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ListDocumentsRequest",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "parent",
                    &self.parent,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "collectionId",
                    &self.collection_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "pageSize",
                    &self.page_size,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "pageToken",
                    &self.page_token,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "orderBy",
                    &self.order_by,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "mask",
                    &self.mask,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "showMissing",
                    &self.show_missing,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "consistencySelector",
                    &self.consistency_selector,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// Nested message and enum types in `ListDocumentsRequest`.
    pub mod list_documents_request {
        /// The consistency mode for this transaction.
        /// If not set, defaults to strong consistency.
        #[serde(rename_all = "camelCase")]
        #[allow(clippy::derive_partial_eq_without_eq)]
        pub enum ConsistencySelector {
            /// Perform the read as part of an already active transaction.
            #[prost(bytes, tag = "8")]
            Transaction(::prost::alloc::vec::Vec<u8>),
            /// Perform the read at the provided time.
            ///
            /// This must be a microsecond precision timestamp within the past one hour,
            /// or if Point-in-Time Recovery is enabled, can additionally be a whole
            /// minute timestamp within the past 7 days.
            #[prost(message, tag = "10")]
            ReadTime(super::super::super::protobuf::Timestamp),
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::clone::Clone for ConsistencySelector {
            #[inline]
            fn clone(&self) -> ConsistencySelector {
                match self {
                    ConsistencySelector::Transaction(__self_0) => {
                        ConsistencySelector::Transaction(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    ConsistencySelector::ReadTime(__self_0) => {
                        ConsistencySelector::ReadTime(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::marker::StructuralPartialEq for ConsistencySelector {}
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::cmp::PartialEq for ConsistencySelector {
            #[inline]
            fn eq(&self, other: &ConsistencySelector) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
                    && match (self, other) {
                        (
                            ConsistencySelector::Transaction(__self_0),
                            ConsistencySelector::Transaction(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            ConsistencySelector::ReadTime(__self_0),
                            ConsistencySelector::ReadTime(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        impl ConsistencySelector {
            /// Encodes the message to a buffer.
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    ConsistencySelector::Transaction(ref value) => {
                        ::prost::encoding::bytes::encode(8u32, &*value, buf);
                    }
                    ConsistencySelector::ReadTime(ref value) => {
                        ::prost::encoding::message::encode(10u32, &*value, buf);
                    }
                }
            }
            /// Decodes an instance of the message from a buffer, and merges it into self.
            pub fn merge<B>(
                field: &mut ::core::option::Option<ConsistencySelector>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag {
                    8u32 => {
                        match field {
                            ::core::option::Option::Some(
                                ConsistencySelector::Transaction(ref mut value),
                            ) => {
                                ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            ConsistencySelector::Transaction(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    10u32 => {
                        match field {
                            ::core::option::Option::Some(
                                ConsistencySelector::ReadTime(ref mut value),
                            ) => {
                                ::prost::encoding::message::merge(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            ConsistencySelector::ReadTime(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    _ => {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "internal error: entered unreachable code: {0}",
                                format_args!("invalid ConsistencySelector tag: {0}", tag),
                            ),
                        );
                    }
                }
            }
            /// Returns the encoded length of the message without a length delimiter.
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    ConsistencySelector::Transaction(ref value) => {
                        ::prost::encoding::bytes::encoded_len(8u32, &*value)
                    }
                    ConsistencySelector::ReadTime(ref value) => {
                        ::prost::encoding::message::encoded_len(10u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for ConsistencySelector {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ConsistencySelector::Transaction(ref value) => {
                        let wrapper = {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("Transaction").field(&wrapper).finish()
                    }
                    ConsistencySelector::ReadTime(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ReadTime").field(&wrapper).finish()
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ConsistencySelector {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 2",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "transaction" => _serde::__private::Ok(__Field::__field0),
                                "readTime" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"transaction" => _serde::__private::Ok(__Field::__field0),
                                b"readTime" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ConsistencySelector>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ConsistencySelector;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum ConsistencySelector",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            ::prost::alloc::vec::Vec<u8>,
                                        >(__variant),
                                        ConsistencySelector::Transaction,
                                    )
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            super::super::super::protobuf::Timestamp,
                                        >(__variant),
                                        ConsistencySelector::ReadTime,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "transaction",
                        "readTime",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "ConsistencySelector",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                ConsistencySelector,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ConsistencySelector {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        ConsistencySelector::Transaction(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "ConsistencySelector",
                                0u32,
                                "transaction",
                                __field0,
                            )
                        }
                        ConsistencySelector::ReadTime(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "ConsistencySelector",
                                1u32,
                                "readTime",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
    }
    /// The response for
    /// [Firestore.ListDocuments][google.firestore.v1.Firestore.ListDocuments].
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct ListDocumentsResponse {
        /// The Documents found.
        #[prost(message, repeated, tag = "1")]
        pub documents: ::prost::alloc::vec::Vec<Document>,
        /// A token to retrieve the next page of documents.
        ///
        /// If this field is omitted, there are no subsequent pages.
        #[prost(string, tag = "2")]
        pub next_page_token: ::prost::alloc::string::String,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for ListDocumentsResponse {
        #[inline]
        fn clone(&self) -> ListDocumentsResponse {
            ListDocumentsResponse {
                documents: ::core::clone::Clone::clone(&self.documents),
                next_page_token: ::core::clone::Clone::clone(&self.next_page_token),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for ListDocumentsResponse {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for ListDocumentsResponse {
        #[inline]
        fn eq(&self, other: &ListDocumentsResponse) -> bool {
            self.documents == other.documents
                && self.next_page_token == other.next_page_token
        }
    }
    impl ::prost::Message for ListDocumentsResponse {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            for msg in &self.documents {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if self.next_page_token != "" {
                ::prost::encoding::string::encode(2u32, &self.next_page_token, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ListDocumentsResponse";
            match tag {
                1u32 => {
                    let mut value = &mut self.documents;
                    ::prost::encoding::message::merge_repeated(
                            wire_type,
                            value,
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "documents");
                            error
                        })
                }
                2u32 => {
                    let mut value = &mut self.next_page_token;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "next_page_token");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + ::prost::encoding::message::encoded_len_repeated(1u32, &self.documents)
                + if self.next_page_token != "" {
                    ::prost::encoding::string::encoded_len(2u32, &self.next_page_token)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.documents.clear();
            self.next_page_token.clear();
        }
    }
    impl ::core::default::Default for ListDocumentsResponse {
        fn default() -> Self {
            ListDocumentsResponse {
                documents: ::core::default::Default::default(),
                next_page_token: ::prost::alloc::string::String::new(),
            }
        }
    }
    impl ::core::fmt::Debug for ListDocumentsResponse {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ListDocumentsResponse");
            let builder = {
                let wrapper = &self.documents;
                builder.field("documents", &wrapper)
            };
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.next_page_token)
                };
                builder.field("next_page_token", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ListDocumentsResponse {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "documents" => _serde::__private::Ok(__Field::__field0),
                            "nextPageToken" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"documents" => _serde::__private::Ok(__Field::__field0),
                            b"nextPageToken" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ListDocumentsResponse>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ListDocumentsResponse;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ListDocumentsResponse",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::vec::Vec<Document>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ListDocumentsResponse with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::string::String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct ListDocumentsResponse with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ListDocumentsResponse {
                            documents: __field0,
                            next_page_token: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::prost::alloc::vec::Vec<Document>,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            ::prost::alloc::string::String,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "documents",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::vec::Vec<Document>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "nextPageToken",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::string::String,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("documents")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("nextPageToken")?
                            }
                        };
                        _serde::__private::Ok(ListDocumentsResponse {
                            documents: __field0,
                            next_page_token: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["documents", "nextPageToken"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ListDocumentsResponse",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ListDocumentsResponse>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ListDocumentsResponse {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ListDocumentsResponse",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "documents",
                    &self.documents,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "nextPageToken",
                    &self.next_page_token,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// The request for
    /// [Firestore.CreateDocument][google.firestore.v1.Firestore.CreateDocument].
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct CreateDocumentRequest {
        /// Required. The parent resource. For example:
        /// `projects/{project_id}/databases/{database_id}/documents` or
        /// `projects/{project_id}/databases/{database_id}/documents/chatrooms/{chatroom_id}`
        #[prost(string, tag = "1")]
        pub parent: ::prost::alloc::string::String,
        /// Required. The collection ID, relative to `parent`, to list. For example:
        /// `chatrooms`.
        #[prost(string, tag = "2")]
        pub collection_id: ::prost::alloc::string::String,
        /// The client-assigned document ID to use for this document.
        ///
        /// Optional. If not specified, an ID will be assigned by the service.
        #[prost(string, tag = "3")]
        pub document_id: ::prost::alloc::string::String,
        /// Required. The document to create. `name` must not be set.
        #[prost(message, optional, tag = "4")]
        pub document: ::core::option::Option<Document>,
        /// The fields to return. If not set, returns all fields.
        ///
        /// If the document has a field that is not present in this mask, that field
        /// will not be returned in the response.
        #[prost(message, optional, tag = "5")]
        pub mask: ::core::option::Option<DocumentMask>,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for CreateDocumentRequest {
        #[inline]
        fn clone(&self) -> CreateDocumentRequest {
            CreateDocumentRequest {
                parent: ::core::clone::Clone::clone(&self.parent),
                collection_id: ::core::clone::Clone::clone(&self.collection_id),
                document_id: ::core::clone::Clone::clone(&self.document_id),
                document: ::core::clone::Clone::clone(&self.document),
                mask: ::core::clone::Clone::clone(&self.mask),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for CreateDocumentRequest {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for CreateDocumentRequest {
        #[inline]
        fn eq(&self, other: &CreateDocumentRequest) -> bool {
            self.parent == other.parent && self.collection_id == other.collection_id
                && self.document_id == other.document_id
                && self.document == other.document && self.mask == other.mask
        }
    }
    impl ::prost::Message for CreateDocumentRequest {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.parent != "" {
                ::prost::encoding::string::encode(1u32, &self.parent, buf);
            }
            if self.collection_id != "" {
                ::prost::encoding::string::encode(2u32, &self.collection_id, buf);
            }
            if self.document_id != "" {
                ::prost::encoding::string::encode(3u32, &self.document_id, buf);
            }
            if let Some(ref msg) = self.document {
                ::prost::encoding::message::encode(4u32, msg, buf);
            }
            if let Some(ref msg) = self.mask {
                ::prost::encoding::message::encode(5u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "CreateDocumentRequest";
            match tag {
                1u32 => {
                    let mut value = &mut self.parent;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "parent");
                            error
                        })
                }
                2u32 => {
                    let mut value = &mut self.collection_id;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "collection_id");
                            error
                        })
                }
                3u32 => {
                    let mut value = &mut self.document_id;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "document_id");
                            error
                        })
                }
                4u32 => {
                    let mut value = &mut self.document;
                    ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "document");
                            error
                        })
                }
                5u32 => {
                    let mut value = &mut self.mask;
                    ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "mask");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0
                + if self.parent != "" {
                    ::prost::encoding::string::encoded_len(1u32, &self.parent)
                } else {
                    0
                }
                + if self.collection_id != "" {
                    ::prost::encoding::string::encoded_len(2u32, &self.collection_id)
                } else {
                    0
                }
                + if self.document_id != "" {
                    ::prost::encoding::string::encoded_len(3u32, &self.document_id)
                } else {
                    0
                }
                + self
                    .document
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(4u32, msg))
                + self
                    .mask
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(5u32, msg))
        }
        fn clear(&mut self) {
            self.parent.clear();
            self.collection_id.clear();
            self.document_id.clear();
            self.document = ::core::option::Option::None;
            self.mask = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for CreateDocumentRequest {
        fn default() -> Self {
            CreateDocumentRequest {
                parent: ::prost::alloc::string::String::new(),
                collection_id: ::prost::alloc::string::String::new(),
                document_id: ::prost::alloc::string::String::new(),
                document: ::core::default::Default::default(),
                mask: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for CreateDocumentRequest {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("CreateDocumentRequest");
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.parent)
                };
                builder.field("parent", &wrapper)
            };
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.collection_id)
                };
                builder.field("collection_id", &wrapper)
            };
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.document_id)
                };
                builder.field("document_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.document;
                builder.field("document", &wrapper)
            };
            let builder = {
                let wrapper = &self.mask;
                builder.field("mask", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for CreateDocumentRequest {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "parent" => _serde::__private::Ok(__Field::__field0),
                            "collectionId" => _serde::__private::Ok(__Field::__field1),
                            "documentId" => _serde::__private::Ok(__Field::__field2),
                            "document" => _serde::__private::Ok(__Field::__field3),
                            "mask" => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"parent" => _serde::__private::Ok(__Field::__field0),
                            b"collectionId" => _serde::__private::Ok(__Field::__field1),
                            b"documentId" => _serde::__private::Ok(__Field::__field2),
                            b"document" => _serde::__private::Ok(__Field::__field3),
                            b"mask" => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<CreateDocumentRequest>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = CreateDocumentRequest;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct CreateDocumentRequest",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::string::String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct CreateDocumentRequest with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::string::String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct CreateDocumentRequest with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::string::String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct CreateDocumentRequest with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<Document>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct CreateDocumentRequest with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<DocumentMask>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct CreateDocumentRequest with 5 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(CreateDocumentRequest {
                            parent: __field0,
                            collection_id: __field1,
                            document_id: __field2,
                            document: __field3,
                            mask: __field4,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::prost::alloc::string::String,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            ::prost::alloc::string::String,
                        > = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            ::prost::alloc::string::String,
                        > = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<
                            ::core::option::Option<Document>,
                        > = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<
                            ::core::option::Option<DocumentMask>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("parent"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::string::String,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "collectionId",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::string::String,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "documentId",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::string::String,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "document",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<Document>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("mask"),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<DocumentMask>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("parent")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("collectionId")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("documentId")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("document")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("mask")?
                            }
                        };
                        _serde::__private::Ok(CreateDocumentRequest {
                            parent: __field0,
                            collection_id: __field1,
                            document_id: __field2,
                            document: __field3,
                            mask: __field4,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "parent",
                    "collectionId",
                    "documentId",
                    "document",
                    "mask",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "CreateDocumentRequest",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<CreateDocumentRequest>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for CreateDocumentRequest {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "CreateDocumentRequest",
                    false as usize + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "parent",
                    &self.parent,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "collectionId",
                    &self.collection_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "documentId",
                    &self.document_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "document",
                    &self.document,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "mask",
                    &self.mask,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// The request for
    /// [Firestore.UpdateDocument][google.firestore.v1.Firestore.UpdateDocument].
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct UpdateDocumentRequest {
        /// Required. The updated document.
        /// Creates the document if it does not already exist.
        #[prost(message, optional, tag = "1")]
        pub document: ::core::option::Option<Document>,
        /// The fields to update.
        /// None of the field paths in the mask may contain a reserved name.
        ///
        /// If the document exists on the server and has fields not referenced in the
        /// mask, they are left unchanged.
        /// Fields referenced in the mask, but not present in the input document, are
        /// deleted from the document on the server.
        #[prost(message, optional, tag = "2")]
        pub update_mask: ::core::option::Option<DocumentMask>,
        /// The fields to return. If not set, returns all fields.
        ///
        /// If the document has a field that is not present in this mask, that field
        /// will not be returned in the response.
        #[prost(message, optional, tag = "3")]
        pub mask: ::core::option::Option<DocumentMask>,
        /// An optional precondition on the document.
        /// The request will fail if this is set and not met by the target document.
        #[prost(message, optional, tag = "4")]
        pub current_document: ::core::option::Option<Precondition>,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for UpdateDocumentRequest {
        #[inline]
        fn clone(&self) -> UpdateDocumentRequest {
            UpdateDocumentRequest {
                document: ::core::clone::Clone::clone(&self.document),
                update_mask: ::core::clone::Clone::clone(&self.update_mask),
                mask: ::core::clone::Clone::clone(&self.mask),
                current_document: ::core::clone::Clone::clone(&self.current_document),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for UpdateDocumentRequest {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for UpdateDocumentRequest {
        #[inline]
        fn eq(&self, other: &UpdateDocumentRequest) -> bool {
            self.document == other.document && self.update_mask == other.update_mask
                && self.mask == other.mask
                && self.current_document == other.current_document
        }
    }
    impl ::prost::Message for UpdateDocumentRequest {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.document {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.update_mask {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            if let Some(ref msg) = self.mask {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
            if let Some(ref msg) = self.current_document {
                ::prost::encoding::message::encode(4u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "UpdateDocumentRequest";
            match tag {
                1u32 => {
                    let mut value = &mut self.document;
                    ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "document");
                            error
                        })
                }
                2u32 => {
                    let mut value = &mut self.update_mask;
                    ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "update_mask");
                            error
                        })
                }
                3u32 => {
                    let mut value = &mut self.mask;
                    ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "mask");
                            error
                        })
                }
                4u32 => {
                    let mut value = &mut self.current_document;
                    ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "current_document");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0
                + self
                    .document
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .update_mask
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
                + self
                    .mask
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(3u32, msg))
                + self
                    .current_document
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(4u32, msg))
        }
        fn clear(&mut self) {
            self.document = ::core::option::Option::None;
            self.update_mask = ::core::option::Option::None;
            self.mask = ::core::option::Option::None;
            self.current_document = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for UpdateDocumentRequest {
        fn default() -> Self {
            UpdateDocumentRequest {
                document: ::core::default::Default::default(),
                update_mask: ::core::default::Default::default(),
                mask: ::core::default::Default::default(),
                current_document: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for UpdateDocumentRequest {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("UpdateDocumentRequest");
            let builder = {
                let wrapper = &self.document;
                builder.field("document", &wrapper)
            };
            let builder = {
                let wrapper = &self.update_mask;
                builder.field("update_mask", &wrapper)
            };
            let builder = {
                let wrapper = &self.mask;
                builder.field("mask", &wrapper)
            };
            let builder = {
                let wrapper = &self.current_document;
                builder.field("current_document", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UpdateDocumentRequest {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "document" => _serde::__private::Ok(__Field::__field0),
                            "updateMask" => _serde::__private::Ok(__Field::__field1),
                            "mask" => _serde::__private::Ok(__Field::__field2),
                            "currentDocument" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"document" => _serde::__private::Ok(__Field::__field0),
                            b"updateMask" => _serde::__private::Ok(__Field::__field1),
                            b"mask" => _serde::__private::Ok(__Field::__field2),
                            b"currentDocument" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<UpdateDocumentRequest>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UpdateDocumentRequest;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct UpdateDocumentRequest",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<Document>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct UpdateDocumentRequest with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<DocumentMask>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct UpdateDocumentRequest with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<DocumentMask>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct UpdateDocumentRequest with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<Precondition>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct UpdateDocumentRequest with 4 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(UpdateDocumentRequest {
                            document: __field0,
                            update_mask: __field1,
                            mask: __field2,
                            current_document: __field3,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::core::option::Option<Document>,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            ::core::option::Option<DocumentMask>,
                        > = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            ::core::option::Option<DocumentMask>,
                        > = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<
                            ::core::option::Option<Precondition>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "document",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<Document>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "updateMask",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<DocumentMask>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("mask"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<DocumentMask>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "currentDocument",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<Precondition>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("document")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("updateMask")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("mask")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("currentDocument")?
                            }
                        };
                        _serde::__private::Ok(UpdateDocumentRequest {
                            document: __field0,
                            update_mask: __field1,
                            mask: __field2,
                            current_document: __field3,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "document",
                    "updateMask",
                    "mask",
                    "currentDocument",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "UpdateDocumentRequest",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<UpdateDocumentRequest>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UpdateDocumentRequest {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "UpdateDocumentRequest",
                    false as usize + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "document",
                    &self.document,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "updateMask",
                    &self.update_mask,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "mask",
                    &self.mask,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "currentDocument",
                    &self.current_document,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// The request for
    /// [Firestore.DeleteDocument][google.firestore.v1.Firestore.DeleteDocument].
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct DeleteDocumentRequest {
        /// Required. The resource name of the Document to delete. In the format:
        /// `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// An optional precondition on the document.
        /// The request will fail if this is set and not met by the target document.
        #[prost(message, optional, tag = "2")]
        pub current_document: ::core::option::Option<Precondition>,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for DeleteDocumentRequest {
        #[inline]
        fn clone(&self) -> DeleteDocumentRequest {
            DeleteDocumentRequest {
                name: ::core::clone::Clone::clone(&self.name),
                current_document: ::core::clone::Clone::clone(&self.current_document),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for DeleteDocumentRequest {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for DeleteDocumentRequest {
        #[inline]
        fn eq(&self, other: &DeleteDocumentRequest) -> bool {
            self.name == other.name && self.current_document == other.current_document
        }
    }
    impl ::prost::Message for DeleteDocumentRequest {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.name != "" {
                ::prost::encoding::string::encode(1u32, &self.name, buf);
            }
            if let Some(ref msg) = self.current_document {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "DeleteDocumentRequest";
            match tag {
                1u32 => {
                    let mut value = &mut self.name;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "name");
                            error
                        })
                }
                2u32 => {
                    let mut value = &mut self.current_document;
                    ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "current_document");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0
                + if self.name != "" {
                    ::prost::encoding::string::encoded_len(1u32, &self.name)
                } else {
                    0
                }
                + self
                    .current_document
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.name.clear();
            self.current_document = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for DeleteDocumentRequest {
        fn default() -> Self {
            DeleteDocumentRequest {
                name: ::prost::alloc::string::String::new(),
                current_document: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for DeleteDocumentRequest {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("DeleteDocumentRequest");
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.name)
                };
                builder.field("name", &wrapper)
            };
            let builder = {
                let wrapper = &self.current_document;
                builder.field("current_document", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for DeleteDocumentRequest {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "name" => _serde::__private::Ok(__Field::__field0),
                            "currentDocument" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"name" => _serde::__private::Ok(__Field::__field0),
                            b"currentDocument" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<DeleteDocumentRequest>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = DeleteDocumentRequest;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct DeleteDocumentRequest",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::string::String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct DeleteDocumentRequest with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<Precondition>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct DeleteDocumentRequest with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(DeleteDocumentRequest {
                            name: __field0,
                            current_document: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::prost::alloc::string::String,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            ::core::option::Option<Precondition>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::string::String,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "currentDocument",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<Precondition>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("name")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("currentDocument")?
                            }
                        };
                        _serde::__private::Ok(DeleteDocumentRequest {
                            name: __field0,
                            current_document: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["name", "currentDocument"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "DeleteDocumentRequest",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<DeleteDocumentRequest>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for DeleteDocumentRequest {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "DeleteDocumentRequest",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "name",
                    &self.name,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "currentDocument",
                    &self.current_document,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// The request for
    /// [Firestore.BatchGetDocuments][google.firestore.v1.Firestore.BatchGetDocuments].
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct BatchGetDocumentsRequest {
        /// Required. The database name. In the format:
        /// `projects/{project_id}/databases/{database_id}`.
        #[prost(string, tag = "1")]
        pub database: ::prost::alloc::string::String,
        /// The names of the documents to retrieve. In the format:
        /// `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
        /// The request will fail if any of the document is not a child resource of the
        /// given `database`. Duplicate names will be elided.
        #[prost(string, repeated, tag = "2")]
        pub documents: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// The fields to return. If not set, returns all fields.
        ///
        /// If a document has a field that is not present in this mask, that field will
        /// not be returned in the response.
        #[prost(message, optional, tag = "3")]
        pub mask: ::core::option::Option<DocumentMask>,
        /// The consistency mode for this transaction.
        /// If not set, defaults to strong consistency.
        #[prost(
            oneof = "batch_get_documents_request::ConsistencySelector",
            tags = "4, 5, 7"
        )]
        pub consistency_selector: ::core::option::Option<
            batch_get_documents_request::ConsistencySelector,
        >,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for BatchGetDocumentsRequest {
        #[inline]
        fn clone(&self) -> BatchGetDocumentsRequest {
            BatchGetDocumentsRequest {
                database: ::core::clone::Clone::clone(&self.database),
                documents: ::core::clone::Clone::clone(&self.documents),
                mask: ::core::clone::Clone::clone(&self.mask),
                consistency_selector: ::core::clone::Clone::clone(
                    &self.consistency_selector,
                ),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for BatchGetDocumentsRequest {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for BatchGetDocumentsRequest {
        #[inline]
        fn eq(&self, other: &BatchGetDocumentsRequest) -> bool {
            self.database == other.database && self.documents == other.documents
                && self.mask == other.mask
                && self.consistency_selector == other.consistency_selector
        }
    }
    impl ::prost::Message for BatchGetDocumentsRequest {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.database != "" {
                ::prost::encoding::string::encode(1u32, &self.database, buf);
            }
            ::prost::encoding::string::encode_repeated(2u32, &self.documents, buf);
            if let Some(ref msg) = self.mask {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
            if let Some(ref oneof) = self.consistency_selector {
                oneof.encode(buf)
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "BatchGetDocumentsRequest";
            match tag {
                1u32 => {
                    let mut value = &mut self.database;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "database");
                            error
                        })
                }
                2u32 => {
                    let mut value = &mut self.documents;
                    ::prost::encoding::string::merge_repeated(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "documents");
                            error
                        })
                }
                3u32 => {
                    let mut value = &mut self.mask;
                    ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "mask");
                            error
                        })
                }
                4u32 | 5u32 | 7u32 => {
                    let mut value = &mut self.consistency_selector;
                    batch_get_documents_request::ConsistencySelector::merge(
                            value,
                            tag,
                            wire_type,
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "consistency_selector");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0
                + if self.database != "" {
                    ::prost::encoding::string::encoded_len(1u32, &self.database)
                } else {
                    0
                }
                + ::prost::encoding::string::encoded_len_repeated(2u32, &self.documents)
                + self
                    .mask
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(3u32, msg))
                + self
                    .consistency_selector
                    .as_ref()
                    .map_or(
                        0,
                        batch_get_documents_request::ConsistencySelector::encoded_len,
                    )
        }
        fn clear(&mut self) {
            self.database.clear();
            self.documents.clear();
            self.mask = ::core::option::Option::None;
            self.consistency_selector = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for BatchGetDocumentsRequest {
        fn default() -> Self {
            BatchGetDocumentsRequest {
                database: ::prost::alloc::string::String::new(),
                documents: ::prost::alloc::vec::Vec::new(),
                mask: ::core::default::Default::default(),
                consistency_selector: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for BatchGetDocumentsRequest {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("BatchGetDocumentsRequest");
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.database)
                };
                builder.field("database", &wrapper)
            };
            let builder = {
                let wrapper = {
                    struct ScalarWrapper<'a>(
                        &'a ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                    );
                    impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                        fn fmt(
                            &self,
                            f: &mut ::core::fmt::Formatter,
                        ) -> ::core::fmt::Result {
                            let mut vec_builder = f.debug_list();
                            for v in self.0 {
                                #[allow(non_snake_case)]
                                fn Inner<T>(v: T) -> T {
                                    v
                                }
                                vec_builder.entry(&Inner(v));
                            }
                            vec_builder.finish()
                        }
                    }
                    ScalarWrapper(&self.documents)
                };
                builder.field("documents", &wrapper)
            };
            let builder = {
                let wrapper = &self.mask;
                builder.field("mask", &wrapper)
            };
            let builder = {
                let wrapper = &self.consistency_selector;
                builder.field("consistency_selector", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for BatchGetDocumentsRequest {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "database" => _serde::__private::Ok(__Field::__field0),
                            "documents" => _serde::__private::Ok(__Field::__field1),
                            "mask" => _serde::__private::Ok(__Field::__field2),
                            "consistencySelector" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"database" => _serde::__private::Ok(__Field::__field0),
                            b"documents" => _serde::__private::Ok(__Field::__field1),
                            b"mask" => _serde::__private::Ok(__Field::__field2),
                            b"consistencySelector" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<BatchGetDocumentsRequest>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = BatchGetDocumentsRequest;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct BatchGetDocumentsRequest",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::string::String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct BatchGetDocumentsRequest with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct BatchGetDocumentsRequest with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<DocumentMask>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct BatchGetDocumentsRequest with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<
                                batch_get_documents_request::ConsistencySelector,
                            >,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct BatchGetDocumentsRequest with 4 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(BatchGetDocumentsRequest {
                            database: __field0,
                            documents: __field1,
                            mask: __field2,
                            consistency_selector: __field3,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::prost::alloc::string::String,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                        > = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            ::core::option::Option<DocumentMask>,
                        > = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<
                            ::core::option::Option<
                                batch_get_documents_request::ConsistencySelector,
                            >,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "database",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::string::String,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "documents",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("mask"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<DocumentMask>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "consistencySelector",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<
                                                batch_get_documents_request::ConsistencySelector,
                                            >,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("database")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("documents")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("mask")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("consistencySelector")?
                            }
                        };
                        _serde::__private::Ok(BatchGetDocumentsRequest {
                            database: __field0,
                            documents: __field1,
                            mask: __field2,
                            consistency_selector: __field3,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "database",
                    "documents",
                    "mask",
                    "consistencySelector",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "BatchGetDocumentsRequest",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            BatchGetDocumentsRequest,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for BatchGetDocumentsRequest {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "BatchGetDocumentsRequest",
                    false as usize + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "database",
                    &self.database,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "documents",
                    &self.documents,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "mask",
                    &self.mask,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "consistencySelector",
                    &self.consistency_selector,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// Nested message and enum types in `BatchGetDocumentsRequest`.
    pub mod batch_get_documents_request {
        /// The consistency mode for this transaction.
        /// If not set, defaults to strong consistency.
        #[serde(rename_all = "camelCase")]
        #[allow(clippy::derive_partial_eq_without_eq)]
        pub enum ConsistencySelector {
            /// Reads documents in a transaction.
            #[prost(bytes, tag = "4")]
            Transaction(::prost::alloc::vec::Vec<u8>),
            /// Starts a new transaction and reads the documents.
            /// Defaults to a read-only transaction.
            /// The new transaction ID will be returned as the first response in the
            /// stream.
            #[prost(message, tag = "5")]
            NewTransaction(super::TransactionOptions),
            /// Reads documents as they were at the given time.
            ///
            /// This must be a microsecond precision timestamp within the past one hour,
            /// or if Point-in-Time Recovery is enabled, can additionally be a whole
            /// minute timestamp within the past 7 days.
            #[prost(message, tag = "7")]
            ReadTime(super::super::super::protobuf::Timestamp),
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::clone::Clone for ConsistencySelector {
            #[inline]
            fn clone(&self) -> ConsistencySelector {
                match self {
                    ConsistencySelector::Transaction(__self_0) => {
                        ConsistencySelector::Transaction(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    ConsistencySelector::NewTransaction(__self_0) => {
                        ConsistencySelector::NewTransaction(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    ConsistencySelector::ReadTime(__self_0) => {
                        ConsistencySelector::ReadTime(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::marker::StructuralPartialEq for ConsistencySelector {}
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::cmp::PartialEq for ConsistencySelector {
            #[inline]
            fn eq(&self, other: &ConsistencySelector) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
                    && match (self, other) {
                        (
                            ConsistencySelector::Transaction(__self_0),
                            ConsistencySelector::Transaction(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            ConsistencySelector::NewTransaction(__self_0),
                            ConsistencySelector::NewTransaction(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            ConsistencySelector::ReadTime(__self_0),
                            ConsistencySelector::ReadTime(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        impl ConsistencySelector {
            /// Encodes the message to a buffer.
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    ConsistencySelector::Transaction(ref value) => {
                        ::prost::encoding::bytes::encode(4u32, &*value, buf);
                    }
                    ConsistencySelector::NewTransaction(ref value) => {
                        ::prost::encoding::message::encode(5u32, &*value, buf);
                    }
                    ConsistencySelector::ReadTime(ref value) => {
                        ::prost::encoding::message::encode(7u32, &*value, buf);
                    }
                }
            }
            /// Decodes an instance of the message from a buffer, and merges it into self.
            pub fn merge<B>(
                field: &mut ::core::option::Option<ConsistencySelector>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag {
                    4u32 => {
                        match field {
                            ::core::option::Option::Some(
                                ConsistencySelector::Transaction(ref mut value),
                            ) => {
                                ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            ConsistencySelector::Transaction(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    5u32 => {
                        match field {
                            ::core::option::Option::Some(
                                ConsistencySelector::NewTransaction(ref mut value),
                            ) => {
                                ::prost::encoding::message::merge(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            ConsistencySelector::NewTransaction(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    7u32 => {
                        match field {
                            ::core::option::Option::Some(
                                ConsistencySelector::ReadTime(ref mut value),
                            ) => {
                                ::prost::encoding::message::merge(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            ConsistencySelector::ReadTime(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    _ => {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "internal error: entered unreachable code: {0}",
                                format_args!("invalid ConsistencySelector tag: {0}", tag),
                            ),
                        );
                    }
                }
            }
            /// Returns the encoded length of the message without a length delimiter.
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    ConsistencySelector::Transaction(ref value) => {
                        ::prost::encoding::bytes::encoded_len(4u32, &*value)
                    }
                    ConsistencySelector::NewTransaction(ref value) => {
                        ::prost::encoding::message::encoded_len(5u32, &*value)
                    }
                    ConsistencySelector::ReadTime(ref value) => {
                        ::prost::encoding::message::encoded_len(7u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for ConsistencySelector {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ConsistencySelector::Transaction(ref value) => {
                        let wrapper = {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("Transaction").field(&wrapper).finish()
                    }
                    ConsistencySelector::NewTransaction(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("NewTransaction").field(&wrapper).finish()
                    }
                    ConsistencySelector::ReadTime(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ReadTime").field(&wrapper).finish()
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ConsistencySelector {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 3",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "transaction" => _serde::__private::Ok(__Field::__field0),
                                "newTransaction" => _serde::__private::Ok(__Field::__field1),
                                "readTime" => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"transaction" => _serde::__private::Ok(__Field::__field0),
                                b"newTransaction" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                b"readTime" => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ConsistencySelector>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ConsistencySelector;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum ConsistencySelector",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            ::prost::alloc::vec::Vec<u8>,
                                        >(__variant),
                                        ConsistencySelector::Transaction,
                                    )
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            super::TransactionOptions,
                                        >(__variant),
                                        ConsistencySelector::NewTransaction,
                                    )
                                }
                                (__Field::__field2, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            super::super::super::protobuf::Timestamp,
                                        >(__variant),
                                        ConsistencySelector::ReadTime,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "transaction",
                        "newTransaction",
                        "readTime",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "ConsistencySelector",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                ConsistencySelector,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ConsistencySelector {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        ConsistencySelector::Transaction(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "ConsistencySelector",
                                0u32,
                                "transaction",
                                __field0,
                            )
                        }
                        ConsistencySelector::NewTransaction(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "ConsistencySelector",
                                1u32,
                                "newTransaction",
                                __field0,
                            )
                        }
                        ConsistencySelector::ReadTime(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "ConsistencySelector",
                                2u32,
                                "readTime",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
    }
    /// The streamed response for
    /// [Firestore.BatchGetDocuments][google.firestore.v1.Firestore.BatchGetDocuments].
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct BatchGetDocumentsResponse {
        /// The transaction that was started as part of this request.
        /// Will only be set in the first response, and only if
        /// [BatchGetDocumentsRequest.new_transaction][google.firestore.v1.BatchGetDocumentsRequest.new_transaction]
        /// was set in the request.
        #[prost(bytes = "vec", tag = "3")]
        pub transaction: ::prost::alloc::vec::Vec<u8>,
        /// The time at which the document was read.
        /// This may be monotically increasing, in this case the previous documents in
        /// the result stream are guaranteed not to have changed between their
        /// read_time and this one.
        #[prost(message, optional, tag = "4")]
        pub read_time: ::core::option::Option<super::super::protobuf::Timestamp>,
        /// A single result.
        /// This can be empty if the server is just returning a transaction.
        #[prost(oneof = "batch_get_documents_response::Result", tags = "1, 2")]
        pub result: ::core::option::Option<batch_get_documents_response::Result>,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for BatchGetDocumentsResponse {
        #[inline]
        fn clone(&self) -> BatchGetDocumentsResponse {
            BatchGetDocumentsResponse {
                transaction: ::core::clone::Clone::clone(&self.transaction),
                read_time: ::core::clone::Clone::clone(&self.read_time),
                result: ::core::clone::Clone::clone(&self.result),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for BatchGetDocumentsResponse {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for BatchGetDocumentsResponse {
        #[inline]
        fn eq(&self, other: &BatchGetDocumentsResponse) -> bool {
            self.transaction == other.transaction && self.read_time == other.read_time
                && self.result == other.result
        }
    }
    impl ::prost::Message for BatchGetDocumentsResponse {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref oneof) = self.result {
                oneof.encode(buf)
            }
            if self.transaction != b"" as &[u8] {
                ::prost::encoding::bytes::encode(3u32, &self.transaction, buf);
            }
            if let Some(ref msg) = self.read_time {
                ::prost::encoding::message::encode(4u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "BatchGetDocumentsResponse";
            match tag {
                1u32 | 2u32 => {
                    let mut value = &mut self.result;
                    batch_get_documents_response::Result::merge(
                            value,
                            tag,
                            wire_type,
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "result");
                            error
                        })
                }
                3u32 => {
                    let mut value = &mut self.transaction;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "transaction");
                            error
                        })
                }
                4u32 => {
                    let mut value = &mut self.read_time;
                    ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "read_time");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0
                + self
                    .result
                    .as_ref()
                    .map_or(0, batch_get_documents_response::Result::encoded_len)
                + if self.transaction != b"" as &[u8] {
                    ::prost::encoding::bytes::encoded_len(3u32, &self.transaction)
                } else {
                    0
                }
                + self
                    .read_time
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(4u32, msg))
        }
        fn clear(&mut self) {
            self.result = ::core::option::Option::None;
            self.transaction.clear();
            self.read_time = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for BatchGetDocumentsResponse {
        fn default() -> Self {
            BatchGetDocumentsResponse {
                result: ::core::default::Default::default(),
                transaction: ::core::default::Default::default(),
                read_time: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for BatchGetDocumentsResponse {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("BatchGetDocumentsResponse");
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.transaction)
                };
                builder.field("transaction", &wrapper)
            };
            let builder = {
                let wrapper = &self.read_time;
                builder.field("read_time", &wrapper)
            };
            let builder = {
                let wrapper = &self.result;
                builder.field("result", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for BatchGetDocumentsResponse {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "transaction" => _serde::__private::Ok(__Field::__field0),
                            "readTime" => _serde::__private::Ok(__Field::__field1),
                            "result" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"transaction" => _serde::__private::Ok(__Field::__field0),
                            b"readTime" => _serde::__private::Ok(__Field::__field1),
                            b"result" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<BatchGetDocumentsResponse>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = BatchGetDocumentsResponse;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct BatchGetDocumentsResponse",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::vec::Vec<u8>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct BatchGetDocumentsResponse with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<super::super::protobuf::Timestamp>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct BatchGetDocumentsResponse with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<batch_get_documents_response::Result>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct BatchGetDocumentsResponse with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(BatchGetDocumentsResponse {
                            transaction: __field0,
                            read_time: __field1,
                            result: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::prost::alloc::vec::Vec<u8>,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            ::core::option::Option<super::super::protobuf::Timestamp>,
                        > = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            ::core::option::Option<batch_get_documents_response::Result>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "transaction",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::vec::Vec<u8>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "readTime",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<super::super::protobuf::Timestamp>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("result"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<batch_get_documents_response::Result>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("transaction")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("readTime")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("result")?
                            }
                        };
                        _serde::__private::Ok(BatchGetDocumentsResponse {
                            transaction: __field0,
                            read_time: __field1,
                            result: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "transaction",
                    "readTime",
                    "result",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "BatchGetDocumentsResponse",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            BatchGetDocumentsResponse,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for BatchGetDocumentsResponse {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "BatchGetDocumentsResponse",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "transaction",
                    &self.transaction,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "readTime",
                    &self.read_time,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "result",
                    &self.result,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// Nested message and enum types in `BatchGetDocumentsResponse`.
    pub mod batch_get_documents_response {
        /// A single result.
        /// This can be empty if the server is just returning a transaction.
        #[serde(rename_all = "camelCase")]
        #[allow(clippy::derive_partial_eq_without_eq)]
        pub enum Result {
            /// A document that was requested.
            #[prost(message, tag = "1")]
            Found(super::Document),
            /// A document name that was requested but does not exist. In the format:
            /// `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
            #[prost(string, tag = "2")]
            Missing(::prost::alloc::string::String),
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::clone::Clone for Result {
            #[inline]
            fn clone(&self) -> Result {
                match self {
                    Result::Found(__self_0) => {
                        Result::Found(::core::clone::Clone::clone(__self_0))
                    }
                    Result::Missing(__self_0) => {
                        Result::Missing(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::marker::StructuralPartialEq for Result {}
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::cmp::PartialEq for Result {
            #[inline]
            fn eq(&self, other: &Result) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
                    && match (self, other) {
                        (Result::Found(__self_0), Result::Found(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Result::Missing(__self_0), Result::Missing(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        impl Result {
            /// Encodes the message to a buffer.
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    Result::Found(ref value) => {
                        ::prost::encoding::message::encode(1u32, &*value, buf);
                    }
                    Result::Missing(ref value) => {
                        ::prost::encoding::string::encode(2u32, &*value, buf);
                    }
                }
            }
            /// Decodes an instance of the message from a buffer, and merges it into self.
            pub fn merge<B>(
                field: &mut ::core::option::Option<Result>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag {
                    1u32 => {
                        match field {
                            ::core::option::Option::Some(
                                Result::Found(ref mut value),
                            ) => {
                                ::prost::encoding::message::merge(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            Result::Found(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    2u32 => {
                        match field {
                            ::core::option::Option::Some(
                                Result::Missing(ref mut value),
                            ) => {
                                ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            Result::Missing(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    _ => {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "internal error: entered unreachable code: {0}",
                                format_args!("invalid Result tag: {0}", tag),
                            ),
                        );
                    }
                }
            }
            /// Returns the encoded length of the message without a length delimiter.
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    Result::Found(ref value) => {
                        ::prost::encoding::message::encoded_len(1u32, &*value)
                    }
                    Result::Missing(ref value) => {
                        ::prost::encoding::string::encoded_len(2u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for Result {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Result::Found(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("Found").field(&wrapper).finish()
                    }
                    Result::Missing(ref value) => {
                        let wrapper = {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("Missing").field(&wrapper).finish()
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Result {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 2",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "found" => _serde::__private::Ok(__Field::__field0),
                                "missing" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"found" => _serde::__private::Ok(__Field::__field0),
                                b"missing" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Result>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Result;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum Result",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            super::Document,
                                        >(__variant),
                                        Result::Found,
                                    )
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            ::prost::alloc::string::String,
                                        >(__variant),
                                        Result::Missing,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &["found", "missing"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "Result",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Result>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Result {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        Result::Found(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "Result",
                                0u32,
                                "found",
                                __field0,
                            )
                        }
                        Result::Missing(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "Result",
                                1u32,
                                "missing",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
    }
    /// The request for
    /// [Firestore.BeginTransaction][google.firestore.v1.Firestore.BeginTransaction].
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct BeginTransactionRequest {
        /// Required. The database name. In the format:
        /// `projects/{project_id}/databases/{database_id}`.
        #[prost(string, tag = "1")]
        pub database: ::prost::alloc::string::String,
        /// The options for the transaction.
        /// Defaults to a read-write transaction.
        #[prost(message, optional, tag = "2")]
        pub options: ::core::option::Option<TransactionOptions>,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for BeginTransactionRequest {
        #[inline]
        fn clone(&self) -> BeginTransactionRequest {
            BeginTransactionRequest {
                database: ::core::clone::Clone::clone(&self.database),
                options: ::core::clone::Clone::clone(&self.options),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for BeginTransactionRequest {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for BeginTransactionRequest {
        #[inline]
        fn eq(&self, other: &BeginTransactionRequest) -> bool {
            self.database == other.database && self.options == other.options
        }
    }
    impl ::prost::Message for BeginTransactionRequest {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.database != "" {
                ::prost::encoding::string::encode(1u32, &self.database, buf);
            }
            if let Some(ref msg) = self.options {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "BeginTransactionRequest";
            match tag {
                1u32 => {
                    let mut value = &mut self.database;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "database");
                            error
                        })
                }
                2u32 => {
                    let mut value = &mut self.options;
                    ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "options");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0
                + if self.database != "" {
                    ::prost::encoding::string::encoded_len(1u32, &self.database)
                } else {
                    0
                }
                + self
                    .options
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.database.clear();
            self.options = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for BeginTransactionRequest {
        fn default() -> Self {
            BeginTransactionRequest {
                database: ::prost::alloc::string::String::new(),
                options: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for BeginTransactionRequest {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("BeginTransactionRequest");
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.database)
                };
                builder.field("database", &wrapper)
            };
            let builder = {
                let wrapper = &self.options;
                builder.field("options", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for BeginTransactionRequest {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "database" => _serde::__private::Ok(__Field::__field0),
                            "options" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"database" => _serde::__private::Ok(__Field::__field0),
                            b"options" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<BeginTransactionRequest>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = BeginTransactionRequest;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct BeginTransactionRequest",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::string::String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct BeginTransactionRequest with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<TransactionOptions>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct BeginTransactionRequest with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(BeginTransactionRequest {
                            database: __field0,
                            options: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::prost::alloc::string::String,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            ::core::option::Option<TransactionOptions>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "database",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::string::String,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "options",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<TransactionOptions>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("database")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("options")?
                            }
                        };
                        _serde::__private::Ok(BeginTransactionRequest {
                            database: __field0,
                            options: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["database", "options"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "BeginTransactionRequest",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            BeginTransactionRequest,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for BeginTransactionRequest {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "BeginTransactionRequest",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "database",
                    &self.database,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "options",
                    &self.options,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// The response for
    /// [Firestore.BeginTransaction][google.firestore.v1.Firestore.BeginTransaction].
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct BeginTransactionResponse {
        /// The transaction that was started.
        #[prost(bytes = "vec", tag = "1")]
        pub transaction: ::prost::alloc::vec::Vec<u8>,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for BeginTransactionResponse {
        #[inline]
        fn clone(&self) -> BeginTransactionResponse {
            BeginTransactionResponse {
                transaction: ::core::clone::Clone::clone(&self.transaction),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for BeginTransactionResponse {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for BeginTransactionResponse {
        #[inline]
        fn eq(&self, other: &BeginTransactionResponse) -> bool {
            self.transaction == other.transaction
        }
    }
    impl ::prost::Message for BeginTransactionResponse {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.transaction != b"" as &[u8] {
                ::prost::encoding::bytes::encode(1u32, &self.transaction, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "BeginTransactionResponse";
            match tag {
                1u32 => {
                    let mut value = &mut self.transaction;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "transaction");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0
                + if self.transaction != b"" as &[u8] {
                    ::prost::encoding::bytes::encoded_len(1u32, &self.transaction)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.transaction.clear();
        }
    }
    impl ::core::default::Default for BeginTransactionResponse {
        fn default() -> Self {
            BeginTransactionResponse {
                transaction: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for BeginTransactionResponse {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("BeginTransactionResponse");
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.transaction)
                };
                builder.field("transaction", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for BeginTransactionResponse {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "transaction" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"transaction" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<BeginTransactionResponse>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = BeginTransactionResponse;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct BeginTransactionResponse",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::vec::Vec<u8>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct BeginTransactionResponse with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(BeginTransactionResponse {
                            transaction: __field0,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::prost::alloc::vec::Vec<u8>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "transaction",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::vec::Vec<u8>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("transaction")?
                            }
                        };
                        _serde::__private::Ok(BeginTransactionResponse {
                            transaction: __field0,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["transaction"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "BeginTransactionResponse",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            BeginTransactionResponse,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for BeginTransactionResponse {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "BeginTransactionResponse",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "transaction",
                    &self.transaction,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// The request for [Firestore.Commit][google.firestore.v1.Firestore.Commit].
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct CommitRequest {
        /// Required. The database name. In the format:
        /// `projects/{project_id}/databases/{database_id}`.
        #[prost(string, tag = "1")]
        pub database: ::prost::alloc::string::String,
        /// The writes to apply.
        ///
        /// Always executed atomically and in order.
        #[prost(message, repeated, tag = "2")]
        pub writes: ::prost::alloc::vec::Vec<Write>,
        /// If set, applies all writes in this transaction, and commits it.
        #[prost(bytes = "vec", tag = "3")]
        pub transaction: ::prost::alloc::vec::Vec<u8>,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for CommitRequest {
        #[inline]
        fn clone(&self) -> CommitRequest {
            CommitRequest {
                database: ::core::clone::Clone::clone(&self.database),
                writes: ::core::clone::Clone::clone(&self.writes),
                transaction: ::core::clone::Clone::clone(&self.transaction),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for CommitRequest {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for CommitRequest {
        #[inline]
        fn eq(&self, other: &CommitRequest) -> bool {
            self.database == other.database && self.writes == other.writes
                && self.transaction == other.transaction
        }
    }
    impl ::prost::Message for CommitRequest {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.database != "" {
                ::prost::encoding::string::encode(1u32, &self.database, buf);
            }
            for msg in &self.writes {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            if self.transaction != b"" as &[u8] {
                ::prost::encoding::bytes::encode(3u32, &self.transaction, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "CommitRequest";
            match tag {
                1u32 => {
                    let mut value = &mut self.database;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "database");
                            error
                        })
                }
                2u32 => {
                    let mut value = &mut self.writes;
                    ::prost::encoding::message::merge_repeated(
                            wire_type,
                            value,
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "writes");
                            error
                        })
                }
                3u32 => {
                    let mut value = &mut self.transaction;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "transaction");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0
                + if self.database != "" {
                    ::prost::encoding::string::encoded_len(1u32, &self.database)
                } else {
                    0
                } + ::prost::encoding::message::encoded_len_repeated(2u32, &self.writes)
                + if self.transaction != b"" as &[u8] {
                    ::prost::encoding::bytes::encoded_len(3u32, &self.transaction)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.database.clear();
            self.writes.clear();
            self.transaction.clear();
        }
    }
    impl ::core::default::Default for CommitRequest {
        fn default() -> Self {
            CommitRequest {
                database: ::prost::alloc::string::String::new(),
                writes: ::core::default::Default::default(),
                transaction: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for CommitRequest {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("CommitRequest");
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.database)
                };
                builder.field("database", &wrapper)
            };
            let builder = {
                let wrapper = &self.writes;
                builder.field("writes", &wrapper)
            };
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.transaction)
                };
                builder.field("transaction", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for CommitRequest {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "database" => _serde::__private::Ok(__Field::__field0),
                            "writes" => _serde::__private::Ok(__Field::__field1),
                            "transaction" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"database" => _serde::__private::Ok(__Field::__field0),
                            b"writes" => _serde::__private::Ok(__Field::__field1),
                            b"transaction" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<CommitRequest>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = CommitRequest;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct CommitRequest",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::string::String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct CommitRequest with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::vec::Vec<Write>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct CommitRequest with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::vec::Vec<u8>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct CommitRequest with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(CommitRequest {
                            database: __field0,
                            writes: __field1,
                            transaction: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::prost::alloc::string::String,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            ::prost::alloc::vec::Vec<Write>,
                        > = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            ::prost::alloc::vec::Vec<u8>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "database",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::string::String,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("writes"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::vec::Vec<Write>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "transaction",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::vec::Vec<u8>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("database")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("writes")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("transaction")?
                            }
                        };
                        _serde::__private::Ok(CommitRequest {
                            database: __field0,
                            writes: __field1,
                            transaction: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "database",
                    "writes",
                    "transaction",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "CommitRequest",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<CommitRequest>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for CommitRequest {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "CommitRequest",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "database",
                    &self.database,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "writes",
                    &self.writes,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "transaction",
                    &self.transaction,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// The response for [Firestore.Commit][google.firestore.v1.Firestore.Commit].
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct CommitResponse {
        /// The result of applying the writes.
        ///
        /// This i-th write result corresponds to the i-th write in the
        /// request.
        #[prost(message, repeated, tag = "1")]
        pub write_results: ::prost::alloc::vec::Vec<WriteResult>,
        /// The time at which the commit occurred. Any read with an equal or greater
        /// `read_time` is guaranteed to see the effects of the commit.
        #[prost(message, optional, tag = "2")]
        pub commit_time: ::core::option::Option<super::super::protobuf::Timestamp>,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for CommitResponse {
        #[inline]
        fn clone(&self) -> CommitResponse {
            CommitResponse {
                write_results: ::core::clone::Clone::clone(&self.write_results),
                commit_time: ::core::clone::Clone::clone(&self.commit_time),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for CommitResponse {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for CommitResponse {
        #[inline]
        fn eq(&self, other: &CommitResponse) -> bool {
            self.write_results == other.write_results
                && self.commit_time == other.commit_time
        }
    }
    impl ::prost::Message for CommitResponse {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            for msg in &self.write_results {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.commit_time {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "CommitResponse";
            match tag {
                1u32 => {
                    let mut value = &mut self.write_results;
                    ::prost::encoding::message::merge_repeated(
                            wire_type,
                            value,
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "write_results");
                            error
                        })
                }
                2u32 => {
                    let mut value = &mut self.commit_time;
                    ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "commit_time");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0
                + ::prost::encoding::message::encoded_len_repeated(
                    1u32,
                    &self.write_results,
                )
                + self
                    .commit_time
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.write_results.clear();
            self.commit_time = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for CommitResponse {
        fn default() -> Self {
            CommitResponse {
                write_results: ::core::default::Default::default(),
                commit_time: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for CommitResponse {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("CommitResponse");
            let builder = {
                let wrapper = &self.write_results;
                builder.field("write_results", &wrapper)
            };
            let builder = {
                let wrapper = &self.commit_time;
                builder.field("commit_time", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for CommitResponse {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "writeResults" => _serde::__private::Ok(__Field::__field0),
                            "commitTime" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"writeResults" => _serde::__private::Ok(__Field::__field0),
                            b"commitTime" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<CommitResponse>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = CommitResponse;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct CommitResponse",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::vec::Vec<WriteResult>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct CommitResponse with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<super::super::protobuf::Timestamp>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct CommitResponse with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(CommitResponse {
                            write_results: __field0,
                            commit_time: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::prost::alloc::vec::Vec<WriteResult>,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            ::core::option::Option<super::super::protobuf::Timestamp>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "writeResults",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::vec::Vec<WriteResult>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "commitTime",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<super::super::protobuf::Timestamp>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("writeResults")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("commitTime")?
                            }
                        };
                        _serde::__private::Ok(CommitResponse {
                            write_results: __field0,
                            commit_time: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["writeResults", "commitTime"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "CommitResponse",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<CommitResponse>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for CommitResponse {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "CommitResponse",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "writeResults",
                    &self.write_results,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "commitTime",
                    &self.commit_time,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// The request for [Firestore.Rollback][google.firestore.v1.Firestore.Rollback].
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct RollbackRequest {
        /// Required. The database name. In the format:
        /// `projects/{project_id}/databases/{database_id}`.
        #[prost(string, tag = "1")]
        pub database: ::prost::alloc::string::String,
        /// Required. The transaction to roll back.
        #[prost(bytes = "vec", tag = "2")]
        pub transaction: ::prost::alloc::vec::Vec<u8>,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for RollbackRequest {
        #[inline]
        fn clone(&self) -> RollbackRequest {
            RollbackRequest {
                database: ::core::clone::Clone::clone(&self.database),
                transaction: ::core::clone::Clone::clone(&self.transaction),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for RollbackRequest {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for RollbackRequest {
        #[inline]
        fn eq(&self, other: &RollbackRequest) -> bool {
            self.database == other.database && self.transaction == other.transaction
        }
    }
    impl ::prost::Message for RollbackRequest {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.database != "" {
                ::prost::encoding::string::encode(1u32, &self.database, buf);
            }
            if self.transaction != b"" as &[u8] {
                ::prost::encoding::bytes::encode(2u32, &self.transaction, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "RollbackRequest";
            match tag {
                1u32 => {
                    let mut value = &mut self.database;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "database");
                            error
                        })
                }
                2u32 => {
                    let mut value = &mut self.transaction;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "transaction");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0
                + if self.database != "" {
                    ::prost::encoding::string::encoded_len(1u32, &self.database)
                } else {
                    0
                }
                + if self.transaction != b"" as &[u8] {
                    ::prost::encoding::bytes::encoded_len(2u32, &self.transaction)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.database.clear();
            self.transaction.clear();
        }
    }
    impl ::core::default::Default for RollbackRequest {
        fn default() -> Self {
            RollbackRequest {
                database: ::prost::alloc::string::String::new(),
                transaction: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for RollbackRequest {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("RollbackRequest");
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.database)
                };
                builder.field("database", &wrapper)
            };
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.transaction)
                };
                builder.field("transaction", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for RollbackRequest {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "database" => _serde::__private::Ok(__Field::__field0),
                            "transaction" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"database" => _serde::__private::Ok(__Field::__field0),
                            b"transaction" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<RollbackRequest>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = RollbackRequest;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct RollbackRequest",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::string::String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct RollbackRequest with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::vec::Vec<u8>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct RollbackRequest with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(RollbackRequest {
                            database: __field0,
                            transaction: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::prost::alloc::string::String,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            ::prost::alloc::vec::Vec<u8>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "database",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::string::String,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "transaction",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::vec::Vec<u8>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("database")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("transaction")?
                            }
                        };
                        _serde::__private::Ok(RollbackRequest {
                            database: __field0,
                            transaction: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["database", "transaction"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "RollbackRequest",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<RollbackRequest>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for RollbackRequest {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "RollbackRequest",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "database",
                    &self.database,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "transaction",
                    &self.transaction,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// The request for [Firestore.RunQuery][google.firestore.v1.Firestore.RunQuery].
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct RunQueryRequest {
        /// Required. The parent resource name. In the format:
        /// `projects/{project_id}/databases/{database_id}/documents` or
        /// `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
        /// For example:
        /// `projects/my-project/databases/my-database/documents` or
        /// `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`
        #[prost(string, tag = "1")]
        pub parent: ::prost::alloc::string::String,
        /// The query to run.
        #[prost(oneof = "run_query_request::QueryType", tags = "2")]
        pub query_type: ::core::option::Option<run_query_request::QueryType>,
        /// The consistency mode for this transaction.
        /// If not set, defaults to strong consistency.
        #[prost(oneof = "run_query_request::ConsistencySelector", tags = "5, 6, 7")]
        pub consistency_selector: ::core::option::Option<
            run_query_request::ConsistencySelector,
        >,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for RunQueryRequest {
        #[inline]
        fn clone(&self) -> RunQueryRequest {
            RunQueryRequest {
                parent: ::core::clone::Clone::clone(&self.parent),
                query_type: ::core::clone::Clone::clone(&self.query_type),
                consistency_selector: ::core::clone::Clone::clone(
                    &self.consistency_selector,
                ),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for RunQueryRequest {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for RunQueryRequest {
        #[inline]
        fn eq(&self, other: &RunQueryRequest) -> bool {
            self.parent == other.parent && self.query_type == other.query_type
                && self.consistency_selector == other.consistency_selector
        }
    }
    impl ::prost::Message for RunQueryRequest {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.parent != "" {
                ::prost::encoding::string::encode(1u32, &self.parent, buf);
            }
            if let Some(ref oneof) = self.query_type {
                oneof.encode(buf)
            }
            if let Some(ref oneof) = self.consistency_selector {
                oneof.encode(buf)
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "RunQueryRequest";
            match tag {
                1u32 => {
                    let mut value = &mut self.parent;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "parent");
                            error
                        })
                }
                2u32 => {
                    let mut value = &mut self.query_type;
                    run_query_request::QueryType::merge(value, tag, wire_type, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "query_type");
                            error
                        })
                }
                5u32 | 6u32 | 7u32 => {
                    let mut value = &mut self.consistency_selector;
                    run_query_request::ConsistencySelector::merge(
                            value,
                            tag,
                            wire_type,
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "consistency_selector");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0
                + if self.parent != "" {
                    ::prost::encoding::string::encoded_len(1u32, &self.parent)
                } else {
                    0
                }
                + self
                    .query_type
                    .as_ref()
                    .map_or(0, run_query_request::QueryType::encoded_len)
                + self
                    .consistency_selector
                    .as_ref()
                    .map_or(0, run_query_request::ConsistencySelector::encoded_len)
        }
        fn clear(&mut self) {
            self.parent.clear();
            self.query_type = ::core::option::Option::None;
            self.consistency_selector = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for RunQueryRequest {
        fn default() -> Self {
            RunQueryRequest {
                parent: ::prost::alloc::string::String::new(),
                query_type: ::core::default::Default::default(),
                consistency_selector: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for RunQueryRequest {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("RunQueryRequest");
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.parent)
                };
                builder.field("parent", &wrapper)
            };
            let builder = {
                let wrapper = &self.query_type;
                builder.field("query_type", &wrapper)
            };
            let builder = {
                let wrapper = &self.consistency_selector;
                builder.field("consistency_selector", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for RunQueryRequest {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "parent" => _serde::__private::Ok(__Field::__field0),
                            "queryType" => _serde::__private::Ok(__Field::__field1),
                            "consistencySelector" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"parent" => _serde::__private::Ok(__Field::__field0),
                            b"queryType" => _serde::__private::Ok(__Field::__field1),
                            b"consistencySelector" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<RunQueryRequest>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = RunQueryRequest;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct RunQueryRequest",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::string::String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct RunQueryRequest with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<run_query_request::QueryType>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct RunQueryRequest with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<
                                run_query_request::ConsistencySelector,
                            >,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct RunQueryRequest with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(RunQueryRequest {
                            parent: __field0,
                            query_type: __field1,
                            consistency_selector: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::prost::alloc::string::String,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            ::core::option::Option<run_query_request::QueryType>,
                        > = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            ::core::option::Option<
                                run_query_request::ConsistencySelector,
                            >,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("parent"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::string::String,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "queryType",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<run_query_request::QueryType>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "consistencySelector",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<
                                                run_query_request::ConsistencySelector,
                                            >,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("parent")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("queryType")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("consistencySelector")?
                            }
                        };
                        _serde::__private::Ok(RunQueryRequest {
                            parent: __field0,
                            query_type: __field1,
                            consistency_selector: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "parent",
                    "queryType",
                    "consistencySelector",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "RunQueryRequest",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<RunQueryRequest>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for RunQueryRequest {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "RunQueryRequest",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "parent",
                    &self.parent,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "queryType",
                    &self.query_type,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "consistencySelector",
                    &self.consistency_selector,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// Nested message and enum types in `RunQueryRequest`.
    pub mod run_query_request {
        /// The query to run.
        #[serde(rename_all = "camelCase")]
        #[allow(clippy::derive_partial_eq_without_eq)]
        pub enum QueryType {
            /// A structured query.
            #[prost(message, tag = "2")]
            StructuredQuery(super::StructuredQuery),
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::clone::Clone for QueryType {
            #[inline]
            fn clone(&self) -> QueryType {
                match self {
                    QueryType::StructuredQuery(__self_0) => {
                        QueryType::StructuredQuery(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::marker::StructuralPartialEq for QueryType {}
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::cmp::PartialEq for QueryType {
            #[inline]
            fn eq(&self, other: &QueryType) -> bool {
                match (self, other) {
                    (
                        QueryType::StructuredQuery(__self_0),
                        QueryType::StructuredQuery(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                }
            }
        }
        impl QueryType {
            /// Encodes the message to a buffer.
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    QueryType::StructuredQuery(ref value) => {
                        ::prost::encoding::message::encode(2u32, &*value, buf);
                    }
                }
            }
            /// Decodes an instance of the message from a buffer, and merges it into self.
            pub fn merge<B>(
                field: &mut ::core::option::Option<QueryType>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag {
                    2u32 => {
                        match field {
                            ::core::option::Option::Some(
                                QueryType::StructuredQuery(ref mut value),
                            ) => {
                                ::prost::encoding::message::merge(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            QueryType::StructuredQuery(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    _ => {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "internal error: entered unreachable code: {0}",
                                format_args!("invalid QueryType tag: {0}", tag),
                            ),
                        );
                    }
                }
            }
            /// Returns the encoded length of the message without a length delimiter.
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    QueryType::StructuredQuery(ref value) => {
                        ::prost::encoding::message::encoded_len(2u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for QueryType {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    QueryType::StructuredQuery(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("StructuredQuery").field(&wrapper).finish()
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for QueryType {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 1",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "structuredQuery" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"structuredQuery" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<QueryType>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = QueryType;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum QueryType",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            super::StructuredQuery,
                                        >(__variant),
                                        QueryType::StructuredQuery,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &["structuredQuery"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "QueryType",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<QueryType>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for QueryType {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        QueryType::StructuredQuery(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "QueryType",
                                0u32,
                                "structuredQuery",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
        /// The consistency mode for this transaction.
        /// If not set, defaults to strong consistency.
        #[serde(rename_all = "camelCase")]
        #[allow(clippy::derive_partial_eq_without_eq)]
        pub enum ConsistencySelector {
            /// Run the query within an already active transaction.
            ///
            /// The value here is the opaque transaction ID to execute the query in.
            #[prost(bytes, tag = "5")]
            Transaction(::prost::alloc::vec::Vec<u8>),
            /// Starts a new transaction and reads the documents.
            /// Defaults to a read-only transaction.
            /// The new transaction ID will be returned as the first response in the
            /// stream.
            #[prost(message, tag = "6")]
            NewTransaction(super::TransactionOptions),
            /// Reads documents as they were at the given time.
            ///
            /// This must be a microsecond precision timestamp within the past one hour,
            /// or if Point-in-Time Recovery is enabled, can additionally be a whole
            /// minute timestamp within the past 7 days.
            #[prost(message, tag = "7")]
            ReadTime(super::super::super::protobuf::Timestamp),
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::clone::Clone for ConsistencySelector {
            #[inline]
            fn clone(&self) -> ConsistencySelector {
                match self {
                    ConsistencySelector::Transaction(__self_0) => {
                        ConsistencySelector::Transaction(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    ConsistencySelector::NewTransaction(__self_0) => {
                        ConsistencySelector::NewTransaction(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    ConsistencySelector::ReadTime(__self_0) => {
                        ConsistencySelector::ReadTime(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::marker::StructuralPartialEq for ConsistencySelector {}
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::cmp::PartialEq for ConsistencySelector {
            #[inline]
            fn eq(&self, other: &ConsistencySelector) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
                    && match (self, other) {
                        (
                            ConsistencySelector::Transaction(__self_0),
                            ConsistencySelector::Transaction(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            ConsistencySelector::NewTransaction(__self_0),
                            ConsistencySelector::NewTransaction(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            ConsistencySelector::ReadTime(__self_0),
                            ConsistencySelector::ReadTime(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        impl ConsistencySelector {
            /// Encodes the message to a buffer.
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    ConsistencySelector::Transaction(ref value) => {
                        ::prost::encoding::bytes::encode(5u32, &*value, buf);
                    }
                    ConsistencySelector::NewTransaction(ref value) => {
                        ::prost::encoding::message::encode(6u32, &*value, buf);
                    }
                    ConsistencySelector::ReadTime(ref value) => {
                        ::prost::encoding::message::encode(7u32, &*value, buf);
                    }
                }
            }
            /// Decodes an instance of the message from a buffer, and merges it into self.
            pub fn merge<B>(
                field: &mut ::core::option::Option<ConsistencySelector>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag {
                    5u32 => {
                        match field {
                            ::core::option::Option::Some(
                                ConsistencySelector::Transaction(ref mut value),
                            ) => {
                                ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            ConsistencySelector::Transaction(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    6u32 => {
                        match field {
                            ::core::option::Option::Some(
                                ConsistencySelector::NewTransaction(ref mut value),
                            ) => {
                                ::prost::encoding::message::merge(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            ConsistencySelector::NewTransaction(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    7u32 => {
                        match field {
                            ::core::option::Option::Some(
                                ConsistencySelector::ReadTime(ref mut value),
                            ) => {
                                ::prost::encoding::message::merge(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            ConsistencySelector::ReadTime(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    _ => {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "internal error: entered unreachable code: {0}",
                                format_args!("invalid ConsistencySelector tag: {0}", tag),
                            ),
                        );
                    }
                }
            }
            /// Returns the encoded length of the message without a length delimiter.
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    ConsistencySelector::Transaction(ref value) => {
                        ::prost::encoding::bytes::encoded_len(5u32, &*value)
                    }
                    ConsistencySelector::NewTransaction(ref value) => {
                        ::prost::encoding::message::encoded_len(6u32, &*value)
                    }
                    ConsistencySelector::ReadTime(ref value) => {
                        ::prost::encoding::message::encoded_len(7u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for ConsistencySelector {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ConsistencySelector::Transaction(ref value) => {
                        let wrapper = {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("Transaction").field(&wrapper).finish()
                    }
                    ConsistencySelector::NewTransaction(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("NewTransaction").field(&wrapper).finish()
                    }
                    ConsistencySelector::ReadTime(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ReadTime").field(&wrapper).finish()
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ConsistencySelector {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 3",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "transaction" => _serde::__private::Ok(__Field::__field0),
                                "newTransaction" => _serde::__private::Ok(__Field::__field1),
                                "readTime" => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"transaction" => _serde::__private::Ok(__Field::__field0),
                                b"newTransaction" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                b"readTime" => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ConsistencySelector>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ConsistencySelector;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum ConsistencySelector",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            ::prost::alloc::vec::Vec<u8>,
                                        >(__variant),
                                        ConsistencySelector::Transaction,
                                    )
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            super::TransactionOptions,
                                        >(__variant),
                                        ConsistencySelector::NewTransaction,
                                    )
                                }
                                (__Field::__field2, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            super::super::super::protobuf::Timestamp,
                                        >(__variant),
                                        ConsistencySelector::ReadTime,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "transaction",
                        "newTransaction",
                        "readTime",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "ConsistencySelector",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                ConsistencySelector,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ConsistencySelector {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        ConsistencySelector::Transaction(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "ConsistencySelector",
                                0u32,
                                "transaction",
                                __field0,
                            )
                        }
                        ConsistencySelector::NewTransaction(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "ConsistencySelector",
                                1u32,
                                "newTransaction",
                                __field0,
                            )
                        }
                        ConsistencySelector::ReadTime(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "ConsistencySelector",
                                2u32,
                                "readTime",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
    }
    /// The response for
    /// [Firestore.RunQuery][google.firestore.v1.Firestore.RunQuery].
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct RunQueryResponse {
        /// The transaction that was started as part of this request.
        /// Can only be set in the first response, and only if
        /// [RunQueryRequest.new_transaction][google.firestore.v1.RunQueryRequest.new_transaction]
        /// was set in the request. If set, no other fields will be set in this
        /// response.
        #[prost(bytes = "vec", tag = "2")]
        pub transaction: ::prost::alloc::vec::Vec<u8>,
        /// A query result, not set when reporting partial progress.
        #[prost(message, optional, tag = "1")]
        pub document: ::core::option::Option<Document>,
        /// The time at which the document was read. This may be monotonically
        /// increasing; in this case, the previous documents in the result stream are
        /// guaranteed not to have changed between their `read_time` and this one.
        ///
        /// If the query returns no results, a response with `read_time` and no
        /// `document` will be sent, and this represents the time at which the query
        /// was run.
        #[prost(message, optional, tag = "3")]
        pub read_time: ::core::option::Option<super::super::protobuf::Timestamp>,
        /// The number of results that have been skipped due to an offset between
        /// the last response and the current response.
        #[prost(int32, tag = "4")]
        pub skipped_results: i32,
        /// The continuation mode for the query. If present, it indicates the current
        /// query response stream has finished. This can be set with or without a
        /// `document` present, but when set, no more results are returned.
        #[prost(oneof = "run_query_response::ContinuationSelector", tags = "6")]
        pub continuation_selector: ::core::option::Option<
            run_query_response::ContinuationSelector,
        >,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for RunQueryResponse {
        #[inline]
        fn clone(&self) -> RunQueryResponse {
            RunQueryResponse {
                transaction: ::core::clone::Clone::clone(&self.transaction),
                document: ::core::clone::Clone::clone(&self.document),
                read_time: ::core::clone::Clone::clone(&self.read_time),
                skipped_results: ::core::clone::Clone::clone(&self.skipped_results),
                continuation_selector: ::core::clone::Clone::clone(
                    &self.continuation_selector,
                ),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for RunQueryResponse {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for RunQueryResponse {
        #[inline]
        fn eq(&self, other: &RunQueryResponse) -> bool {
            self.transaction == other.transaction && self.document == other.document
                && self.read_time == other.read_time
                && self.skipped_results == other.skipped_results
                && self.continuation_selector == other.continuation_selector
        }
    }
    impl ::prost::Message for RunQueryResponse {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.document {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if self.transaction != b"" as &[u8] {
                ::prost::encoding::bytes::encode(2u32, &self.transaction, buf);
            }
            if let Some(ref msg) = self.read_time {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
            if self.skipped_results != 0i32 {
                ::prost::encoding::int32::encode(4u32, &self.skipped_results, buf);
            }
            if let Some(ref oneof) = self.continuation_selector {
                oneof.encode(buf)
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "RunQueryResponse";
            match tag {
                1u32 => {
                    let mut value = &mut self.document;
                    ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "document");
                            error
                        })
                }
                2u32 => {
                    let mut value = &mut self.transaction;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "transaction");
                            error
                        })
                }
                3u32 => {
                    let mut value = &mut self.read_time;
                    ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "read_time");
                            error
                        })
                }
                4u32 => {
                    let mut value = &mut self.skipped_results;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "skipped_results");
                            error
                        })
                }
                6u32 => {
                    let mut value = &mut self.continuation_selector;
                    run_query_response::ContinuationSelector::merge(
                            value,
                            tag,
                            wire_type,
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "continuation_selector");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0
                + self
                    .document
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + if self.transaction != b"" as &[u8] {
                    ::prost::encoding::bytes::encoded_len(2u32, &self.transaction)
                } else {
                    0
                }
                + self
                    .read_time
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(3u32, msg))
                + if self.skipped_results != 0i32 {
                    ::prost::encoding::int32::encoded_len(4u32, &self.skipped_results)
                } else {
                    0
                }
                + self
                    .continuation_selector
                    .as_ref()
                    .map_or(0, run_query_response::ContinuationSelector::encoded_len)
        }
        fn clear(&mut self) {
            self.document = ::core::option::Option::None;
            self.transaction.clear();
            self.read_time = ::core::option::Option::None;
            self.skipped_results = 0i32;
            self.continuation_selector = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for RunQueryResponse {
        fn default() -> Self {
            RunQueryResponse {
                document: ::core::default::Default::default(),
                transaction: ::core::default::Default::default(),
                read_time: ::core::default::Default::default(),
                skipped_results: 0i32,
                continuation_selector: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for RunQueryResponse {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("RunQueryResponse");
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.transaction)
                };
                builder.field("transaction", &wrapper)
            };
            let builder = {
                let wrapper = &self.document;
                builder.field("document", &wrapper)
            };
            let builder = {
                let wrapper = &self.read_time;
                builder.field("read_time", &wrapper)
            };
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.skipped_results)
                };
                builder.field("skipped_results", &wrapper)
            };
            let builder = {
                let wrapper = &self.continuation_selector;
                builder.field("continuation_selector", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for RunQueryResponse {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "transaction" => _serde::__private::Ok(__Field::__field0),
                            "document" => _serde::__private::Ok(__Field::__field1),
                            "readTime" => _serde::__private::Ok(__Field::__field2),
                            "skippedResults" => _serde::__private::Ok(__Field::__field3),
                            "continuationSelector" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"transaction" => _serde::__private::Ok(__Field::__field0),
                            b"document" => _serde::__private::Ok(__Field::__field1),
                            b"readTime" => _serde::__private::Ok(__Field::__field2),
                            b"skippedResults" => _serde::__private::Ok(__Field::__field3),
                            b"continuationSelector" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<RunQueryResponse>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = RunQueryResponse;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct RunQueryResponse",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::vec::Vec<u8>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct RunQueryResponse with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<Document>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct RunQueryResponse with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<super::super::protobuf::Timestamp>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct RunQueryResponse with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            i32,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct RunQueryResponse with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<
                                run_query_response::ContinuationSelector,
                            >,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct RunQueryResponse with 5 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(RunQueryResponse {
                            transaction: __field0,
                            document: __field1,
                            read_time: __field2,
                            skipped_results: __field3,
                            continuation_selector: __field4,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::prost::alloc::vec::Vec<u8>,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            ::core::option::Option<Document>,
                        > = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            ::core::option::Option<super::super::protobuf::Timestamp>,
                        > = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<i32> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<
                            ::core::option::Option<
                                run_query_response::ContinuationSelector,
                            >,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "transaction",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::vec::Vec<u8>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "document",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<Document>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "readTime",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<super::super::protobuf::Timestamp>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "skippedResults",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i32>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "continuationSelector",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<
                                                run_query_response::ContinuationSelector,
                                            >,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("transaction")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("document")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("readTime")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("skippedResults")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "continuationSelector",
                                )?
                            }
                        };
                        _serde::__private::Ok(RunQueryResponse {
                            transaction: __field0,
                            document: __field1,
                            read_time: __field2,
                            skipped_results: __field3,
                            continuation_selector: __field4,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "transaction",
                    "document",
                    "readTime",
                    "skippedResults",
                    "continuationSelector",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "RunQueryResponse",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<RunQueryResponse>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for RunQueryResponse {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "RunQueryResponse",
                    false as usize + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "transaction",
                    &self.transaction,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "document",
                    &self.document,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "readTime",
                    &self.read_time,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "skippedResults",
                    &self.skipped_results,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "continuationSelector",
                    &self.continuation_selector,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// Nested message and enum types in `RunQueryResponse`.
    pub mod run_query_response {
        /// The continuation mode for the query. If present, it indicates the current
        /// query response stream has finished. This can be set with or without a
        /// `document` present, but when set, no more results are returned.
        #[serde(rename_all = "camelCase")]
        #[allow(clippy::derive_partial_eq_without_eq)]
        pub enum ContinuationSelector {
            /// If present, Firestore has completely finished the request and no more
            /// documents will be returned.
            #[prost(bool, tag = "6")]
            Done(bool),
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::clone::Clone for ContinuationSelector {
            #[inline]
            fn clone(&self) -> ContinuationSelector {
                match self {
                    ContinuationSelector::Done(__self_0) => {
                        ContinuationSelector::Done(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::marker::StructuralPartialEq for ContinuationSelector {}
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::cmp::PartialEq for ContinuationSelector {
            #[inline]
            fn eq(&self, other: &ContinuationSelector) -> bool {
                match (self, other) {
                    (
                        ContinuationSelector::Done(__self_0),
                        ContinuationSelector::Done(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                }
            }
        }
        impl ContinuationSelector {
            /// Encodes the message to a buffer.
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    ContinuationSelector::Done(ref value) => {
                        ::prost::encoding::bool::encode(6u32, &*value, buf);
                    }
                }
            }
            /// Decodes an instance of the message from a buffer, and merges it into self.
            pub fn merge<B>(
                field: &mut ::core::option::Option<ContinuationSelector>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag {
                    6u32 => {
                        match field {
                            ::core::option::Option::Some(
                                ContinuationSelector::Done(ref mut value),
                            ) => {
                                ::prost::encoding::bool::merge(wire_type, value, buf, ctx)
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::bool::merge(wire_type, value, buf, ctx)
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            ContinuationSelector::Done(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    _ => {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "internal error: entered unreachable code: {0}",
                                format_args!("invalid ContinuationSelector tag: {0}", tag),
                            ),
                        );
                    }
                }
            }
            /// Returns the encoded length of the message without a length delimiter.
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    ContinuationSelector::Done(ref value) => {
                        ::prost::encoding::bool::encoded_len(6u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for ContinuationSelector {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ContinuationSelector::Done(ref value) => {
                        let wrapper = {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("Done").field(&wrapper).finish()
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ContinuationSelector {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 1",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "done" => _serde::__private::Ok(__Field::__field0),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"done" => _serde::__private::Ok(__Field::__field0),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ContinuationSelector>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ContinuationSelector;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum ContinuationSelector",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            bool,
                                        >(__variant),
                                        ContinuationSelector::Done,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &["done"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "ContinuationSelector",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                ContinuationSelector,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ContinuationSelector {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        ContinuationSelector::Done(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "ContinuationSelector",
                                0u32,
                                "done",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
    }
    /// The request for
    /// [Firestore.RunAggregationQuery][google.firestore.v1.Firestore.RunAggregationQuery].
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct RunAggregationQueryRequest {
        /// Required. The parent resource name. In the format:
        /// `projects/{project_id}/databases/{database_id}/documents` or
        /// `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
        /// For example:
        /// `projects/my-project/databases/my-database/documents` or
        /// `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`
        #[prost(string, tag = "1")]
        pub parent: ::prost::alloc::string::String,
        /// The query to run.
        #[prost(oneof = "run_aggregation_query_request::QueryType", tags = "2")]
        pub query_type: ::core::option::Option<run_aggregation_query_request::QueryType>,
        /// The consistency mode for the query, defaults to strong consistency.
        #[prost(
            oneof = "run_aggregation_query_request::ConsistencySelector",
            tags = "4, 5, 6"
        )]
        pub consistency_selector: ::core::option::Option<
            run_aggregation_query_request::ConsistencySelector,
        >,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for RunAggregationQueryRequest {
        #[inline]
        fn clone(&self) -> RunAggregationQueryRequest {
            RunAggregationQueryRequest {
                parent: ::core::clone::Clone::clone(&self.parent),
                query_type: ::core::clone::Clone::clone(&self.query_type),
                consistency_selector: ::core::clone::Clone::clone(
                    &self.consistency_selector,
                ),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for RunAggregationQueryRequest {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for RunAggregationQueryRequest {
        #[inline]
        fn eq(&self, other: &RunAggregationQueryRequest) -> bool {
            self.parent == other.parent && self.query_type == other.query_type
                && self.consistency_selector == other.consistency_selector
        }
    }
    impl ::prost::Message for RunAggregationQueryRequest {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.parent != "" {
                ::prost::encoding::string::encode(1u32, &self.parent, buf);
            }
            if let Some(ref oneof) = self.query_type {
                oneof.encode(buf)
            }
            if let Some(ref oneof) = self.consistency_selector {
                oneof.encode(buf)
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "RunAggregationQueryRequest";
            match tag {
                1u32 => {
                    let mut value = &mut self.parent;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "parent");
                            error
                        })
                }
                2u32 => {
                    let mut value = &mut self.query_type;
                    run_aggregation_query_request::QueryType::merge(
                            value,
                            tag,
                            wire_type,
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "query_type");
                            error
                        })
                }
                4u32 | 5u32 | 6u32 => {
                    let mut value = &mut self.consistency_selector;
                    run_aggregation_query_request::ConsistencySelector::merge(
                            value,
                            tag,
                            wire_type,
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "consistency_selector");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0
                + if self.parent != "" {
                    ::prost::encoding::string::encoded_len(1u32, &self.parent)
                } else {
                    0
                }
                + self
                    .query_type
                    .as_ref()
                    .map_or(0, run_aggregation_query_request::QueryType::encoded_len)
                + self
                    .consistency_selector
                    .as_ref()
                    .map_or(
                        0,
                        run_aggregation_query_request::ConsistencySelector::encoded_len,
                    )
        }
        fn clear(&mut self) {
            self.parent.clear();
            self.query_type = ::core::option::Option::None;
            self.consistency_selector = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for RunAggregationQueryRequest {
        fn default() -> Self {
            RunAggregationQueryRequest {
                parent: ::prost::alloc::string::String::new(),
                query_type: ::core::default::Default::default(),
                consistency_selector: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for RunAggregationQueryRequest {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("RunAggregationQueryRequest");
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.parent)
                };
                builder.field("parent", &wrapper)
            };
            let builder = {
                let wrapper = &self.query_type;
                builder.field("query_type", &wrapper)
            };
            let builder = {
                let wrapper = &self.consistency_selector;
                builder.field("consistency_selector", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for RunAggregationQueryRequest {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "parent" => _serde::__private::Ok(__Field::__field0),
                            "queryType" => _serde::__private::Ok(__Field::__field1),
                            "consistencySelector" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"parent" => _serde::__private::Ok(__Field::__field0),
                            b"queryType" => _serde::__private::Ok(__Field::__field1),
                            b"consistencySelector" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<RunAggregationQueryRequest>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = RunAggregationQueryRequest;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct RunAggregationQueryRequest",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::string::String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct RunAggregationQueryRequest with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<
                                run_aggregation_query_request::QueryType,
                            >,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct RunAggregationQueryRequest with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<
                                run_aggregation_query_request::ConsistencySelector,
                            >,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct RunAggregationQueryRequest with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(RunAggregationQueryRequest {
                            parent: __field0,
                            query_type: __field1,
                            consistency_selector: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::prost::alloc::string::String,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            ::core::option::Option<
                                run_aggregation_query_request::QueryType,
                            >,
                        > = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            ::core::option::Option<
                                run_aggregation_query_request::ConsistencySelector,
                            >,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("parent"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::string::String,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "queryType",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<
                                                run_aggregation_query_request::QueryType,
                                            >,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "consistencySelector",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<
                                                run_aggregation_query_request::ConsistencySelector,
                                            >,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("parent")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("queryType")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("consistencySelector")?
                            }
                        };
                        _serde::__private::Ok(RunAggregationQueryRequest {
                            parent: __field0,
                            query_type: __field1,
                            consistency_selector: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "parent",
                    "queryType",
                    "consistencySelector",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "RunAggregationQueryRequest",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            RunAggregationQueryRequest,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for RunAggregationQueryRequest {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "RunAggregationQueryRequest",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "parent",
                    &self.parent,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "queryType",
                    &self.query_type,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "consistencySelector",
                    &self.consistency_selector,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// Nested message and enum types in `RunAggregationQueryRequest`.
    pub mod run_aggregation_query_request {
        /// The query to run.
        #[serde(rename_all = "camelCase")]
        #[allow(clippy::derive_partial_eq_without_eq)]
        pub enum QueryType {
            /// An aggregation query.
            #[prost(message, tag = "2")]
            StructuredAggregationQuery(super::StructuredAggregationQuery),
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::clone::Clone for QueryType {
            #[inline]
            fn clone(&self) -> QueryType {
                match self {
                    QueryType::StructuredAggregationQuery(__self_0) => {
                        QueryType::StructuredAggregationQuery(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::marker::StructuralPartialEq for QueryType {}
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::cmp::PartialEq for QueryType {
            #[inline]
            fn eq(&self, other: &QueryType) -> bool {
                match (self, other) {
                    (
                        QueryType::StructuredAggregationQuery(__self_0),
                        QueryType::StructuredAggregationQuery(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                }
            }
        }
        impl QueryType {
            /// Encodes the message to a buffer.
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    QueryType::StructuredAggregationQuery(ref value) => {
                        ::prost::encoding::message::encode(2u32, &*value, buf);
                    }
                }
            }
            /// Decodes an instance of the message from a buffer, and merges it into self.
            pub fn merge<B>(
                field: &mut ::core::option::Option<QueryType>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag {
                    2u32 => {
                        match field {
                            ::core::option::Option::Some(
                                QueryType::StructuredAggregationQuery(ref mut value),
                            ) => {
                                ::prost::encoding::message::merge(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            QueryType::StructuredAggregationQuery(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    _ => {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "internal error: entered unreachable code: {0}",
                                format_args!("invalid QueryType tag: {0}", tag),
                            ),
                        );
                    }
                }
            }
            /// Returns the encoded length of the message without a length delimiter.
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    QueryType::StructuredAggregationQuery(ref value) => {
                        ::prost::encoding::message::encoded_len(2u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for QueryType {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    QueryType::StructuredAggregationQuery(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("StructuredAggregationQuery")
                            .field(&wrapper)
                            .finish()
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for QueryType {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 1",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "structuredAggregationQuery" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"structuredAggregationQuery" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<QueryType>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = QueryType;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum QueryType",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            super::StructuredAggregationQuery,
                                        >(__variant),
                                        QueryType::StructuredAggregationQuery,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "structuredAggregationQuery",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "QueryType",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<QueryType>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for QueryType {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        QueryType::StructuredAggregationQuery(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "QueryType",
                                0u32,
                                "structuredAggregationQuery",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
        /// The consistency mode for the query, defaults to strong consistency.
        #[serde(rename_all = "camelCase")]
        #[allow(clippy::derive_partial_eq_without_eq)]
        pub enum ConsistencySelector {
            /// Run the aggregation within an already active transaction.
            ///
            /// The value here is the opaque transaction ID to execute the query in.
            #[prost(bytes, tag = "4")]
            Transaction(::prost::alloc::vec::Vec<u8>),
            /// Starts a new transaction as part of the query, defaulting to read-only.
            ///
            /// The new transaction ID will be returned as the first response in the
            /// stream.
            #[prost(message, tag = "5")]
            NewTransaction(super::TransactionOptions),
            /// Executes the query at the given timestamp.
            ///
            /// This must be a microsecond precision timestamp within the past one hour,
            /// or if Point-in-Time Recovery is enabled, can additionally be a whole
            /// minute timestamp within the past 7 days.
            #[prost(message, tag = "6")]
            ReadTime(super::super::super::protobuf::Timestamp),
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::clone::Clone for ConsistencySelector {
            #[inline]
            fn clone(&self) -> ConsistencySelector {
                match self {
                    ConsistencySelector::Transaction(__self_0) => {
                        ConsistencySelector::Transaction(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    ConsistencySelector::NewTransaction(__self_0) => {
                        ConsistencySelector::NewTransaction(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    ConsistencySelector::ReadTime(__self_0) => {
                        ConsistencySelector::ReadTime(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::marker::StructuralPartialEq for ConsistencySelector {}
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::cmp::PartialEq for ConsistencySelector {
            #[inline]
            fn eq(&self, other: &ConsistencySelector) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
                    && match (self, other) {
                        (
                            ConsistencySelector::Transaction(__self_0),
                            ConsistencySelector::Transaction(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            ConsistencySelector::NewTransaction(__self_0),
                            ConsistencySelector::NewTransaction(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            ConsistencySelector::ReadTime(__self_0),
                            ConsistencySelector::ReadTime(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        impl ConsistencySelector {
            /// Encodes the message to a buffer.
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    ConsistencySelector::Transaction(ref value) => {
                        ::prost::encoding::bytes::encode(4u32, &*value, buf);
                    }
                    ConsistencySelector::NewTransaction(ref value) => {
                        ::prost::encoding::message::encode(5u32, &*value, buf);
                    }
                    ConsistencySelector::ReadTime(ref value) => {
                        ::prost::encoding::message::encode(6u32, &*value, buf);
                    }
                }
            }
            /// Decodes an instance of the message from a buffer, and merges it into self.
            pub fn merge<B>(
                field: &mut ::core::option::Option<ConsistencySelector>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag {
                    4u32 => {
                        match field {
                            ::core::option::Option::Some(
                                ConsistencySelector::Transaction(ref mut value),
                            ) => {
                                ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            ConsistencySelector::Transaction(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    5u32 => {
                        match field {
                            ::core::option::Option::Some(
                                ConsistencySelector::NewTransaction(ref mut value),
                            ) => {
                                ::prost::encoding::message::merge(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            ConsistencySelector::NewTransaction(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    6u32 => {
                        match field {
                            ::core::option::Option::Some(
                                ConsistencySelector::ReadTime(ref mut value),
                            ) => {
                                ::prost::encoding::message::merge(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            ConsistencySelector::ReadTime(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    _ => {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "internal error: entered unreachable code: {0}",
                                format_args!("invalid ConsistencySelector tag: {0}", tag),
                            ),
                        );
                    }
                }
            }
            /// Returns the encoded length of the message without a length delimiter.
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    ConsistencySelector::Transaction(ref value) => {
                        ::prost::encoding::bytes::encoded_len(4u32, &*value)
                    }
                    ConsistencySelector::NewTransaction(ref value) => {
                        ::prost::encoding::message::encoded_len(5u32, &*value)
                    }
                    ConsistencySelector::ReadTime(ref value) => {
                        ::prost::encoding::message::encoded_len(6u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for ConsistencySelector {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ConsistencySelector::Transaction(ref value) => {
                        let wrapper = {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("Transaction").field(&wrapper).finish()
                    }
                    ConsistencySelector::NewTransaction(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("NewTransaction").field(&wrapper).finish()
                    }
                    ConsistencySelector::ReadTime(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ReadTime").field(&wrapper).finish()
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ConsistencySelector {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 3",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "transaction" => _serde::__private::Ok(__Field::__field0),
                                "newTransaction" => _serde::__private::Ok(__Field::__field1),
                                "readTime" => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"transaction" => _serde::__private::Ok(__Field::__field0),
                                b"newTransaction" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                b"readTime" => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ConsistencySelector>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ConsistencySelector;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum ConsistencySelector",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            ::prost::alloc::vec::Vec<u8>,
                                        >(__variant),
                                        ConsistencySelector::Transaction,
                                    )
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            super::TransactionOptions,
                                        >(__variant),
                                        ConsistencySelector::NewTransaction,
                                    )
                                }
                                (__Field::__field2, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            super::super::super::protobuf::Timestamp,
                                        >(__variant),
                                        ConsistencySelector::ReadTime,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "transaction",
                        "newTransaction",
                        "readTime",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "ConsistencySelector",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                ConsistencySelector,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ConsistencySelector {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        ConsistencySelector::Transaction(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "ConsistencySelector",
                                0u32,
                                "transaction",
                                __field0,
                            )
                        }
                        ConsistencySelector::NewTransaction(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "ConsistencySelector",
                                1u32,
                                "newTransaction",
                                __field0,
                            )
                        }
                        ConsistencySelector::ReadTime(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "ConsistencySelector",
                                2u32,
                                "readTime",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
    }
    /// The response for
    /// [Firestore.RunAggregationQuery][google.firestore.v1.Firestore.RunAggregationQuery].
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct RunAggregationQueryResponse {
        /// A single aggregation result.
        ///
        /// Not present when reporting partial progress.
        #[prost(message, optional, tag = "1")]
        pub result: ::core::option::Option<AggregationResult>,
        /// The transaction that was started as part of this request.
        ///
        /// Only present on the first response when the request requested to start
        /// a new transaction.
        #[prost(bytes = "vec", tag = "2")]
        pub transaction: ::prost::alloc::vec::Vec<u8>,
        /// The time at which the aggregate result was computed. This is always
        /// monotonically increasing; in this case, the previous AggregationResult in
        /// the result stream are guaranteed not to have changed between their
        /// `read_time` and this one.
        ///
        /// If the query returns no results, a response with `read_time` and no
        /// `result` will be sent, and this represents the time at which the query
        /// was run.
        #[prost(message, optional, tag = "3")]
        pub read_time: ::core::option::Option<super::super::protobuf::Timestamp>,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for RunAggregationQueryResponse {
        #[inline]
        fn clone(&self) -> RunAggregationQueryResponse {
            RunAggregationQueryResponse {
                result: ::core::clone::Clone::clone(&self.result),
                transaction: ::core::clone::Clone::clone(&self.transaction),
                read_time: ::core::clone::Clone::clone(&self.read_time),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for RunAggregationQueryResponse {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for RunAggregationQueryResponse {
        #[inline]
        fn eq(&self, other: &RunAggregationQueryResponse) -> bool {
            self.result == other.result && self.transaction == other.transaction
                && self.read_time == other.read_time
        }
    }
    impl ::prost::Message for RunAggregationQueryResponse {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.result {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if self.transaction != b"" as &[u8] {
                ::prost::encoding::bytes::encode(2u32, &self.transaction, buf);
            }
            if let Some(ref msg) = self.read_time {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "RunAggregationQueryResponse";
            match tag {
                1u32 => {
                    let mut value = &mut self.result;
                    ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "result");
                            error
                        })
                }
                2u32 => {
                    let mut value = &mut self.transaction;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "transaction");
                            error
                        })
                }
                3u32 => {
                    let mut value = &mut self.read_time;
                    ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "read_time");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0
                + self
                    .result
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + if self.transaction != b"" as &[u8] {
                    ::prost::encoding::bytes::encoded_len(2u32, &self.transaction)
                } else {
                    0
                }
                + self
                    .read_time
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(3u32, msg))
        }
        fn clear(&mut self) {
            self.result = ::core::option::Option::None;
            self.transaction.clear();
            self.read_time = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for RunAggregationQueryResponse {
        fn default() -> Self {
            RunAggregationQueryResponse {
                result: ::core::default::Default::default(),
                transaction: ::core::default::Default::default(),
                read_time: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for RunAggregationQueryResponse {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("RunAggregationQueryResponse");
            let builder = {
                let wrapper = &self.result;
                builder.field("result", &wrapper)
            };
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.transaction)
                };
                builder.field("transaction", &wrapper)
            };
            let builder = {
                let wrapper = &self.read_time;
                builder.field("read_time", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for RunAggregationQueryResponse {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "result" => _serde::__private::Ok(__Field::__field0),
                            "transaction" => _serde::__private::Ok(__Field::__field1),
                            "readTime" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"result" => _serde::__private::Ok(__Field::__field0),
                            b"transaction" => _serde::__private::Ok(__Field::__field1),
                            b"readTime" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<RunAggregationQueryResponse>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = RunAggregationQueryResponse;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct RunAggregationQueryResponse",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<AggregationResult>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct RunAggregationQueryResponse with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::vec::Vec<u8>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct RunAggregationQueryResponse with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<super::super::protobuf::Timestamp>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct RunAggregationQueryResponse with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(RunAggregationQueryResponse {
                            result: __field0,
                            transaction: __field1,
                            read_time: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::core::option::Option<AggregationResult>,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            ::prost::alloc::vec::Vec<u8>,
                        > = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            ::core::option::Option<super::super::protobuf::Timestamp>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("result"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<AggregationResult>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "transaction",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::vec::Vec<u8>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "readTime",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<super::super::protobuf::Timestamp>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("result")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("transaction")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("readTime")?
                            }
                        };
                        _serde::__private::Ok(RunAggregationQueryResponse {
                            result: __field0,
                            transaction: __field1,
                            read_time: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "result",
                    "transaction",
                    "readTime",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "RunAggregationQueryResponse",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            RunAggregationQueryResponse,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for RunAggregationQueryResponse {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "RunAggregationQueryResponse",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "result",
                    &self.result,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "transaction",
                    &self.transaction,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "readTime",
                    &self.read_time,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// The request for
    /// [Firestore.PartitionQuery][google.firestore.v1.Firestore.PartitionQuery].
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct PartitionQueryRequest {
        /// Required. The parent resource name. In the format:
        /// `projects/{project_id}/databases/{database_id}/documents`.
        /// Document resource names are not supported; only database resource names
        /// can be specified.
        #[prost(string, tag = "1")]
        pub parent: ::prost::alloc::string::String,
        /// The desired maximum number of partition points.
        /// The partitions may be returned across multiple pages of results.
        /// The number must be positive. The actual number of partitions
        /// returned may be fewer.
        ///
        /// For example, this may be set to one fewer than the number of parallel
        /// queries to be run, or in running a data pipeline job, one fewer than the
        /// number of workers or compute instances available.
        #[prost(int64, tag = "3")]
        pub partition_count: i64,
        /// The `next_page_token` value returned from a previous call to
        /// PartitionQuery that may be used to get an additional set of results.
        /// There are no ordering guarantees between sets of results. Thus, using
        /// multiple sets of results will require merging the different result sets.
        ///
        /// For example, two subsequent calls using a page_token may return:
        ///
        ///   * cursor B, cursor M, cursor Q
        ///   * cursor A, cursor U, cursor W
        ///
        /// To obtain a complete result set ordered with respect to the results of the
        /// query supplied to PartitionQuery, the results sets should be merged:
        /// cursor A, cursor B, cursor M, cursor Q, cursor U, cursor W
        #[prost(string, tag = "4")]
        pub page_token: ::prost::alloc::string::String,
        /// The maximum number of partitions to return in this call, subject to
        /// `partition_count`.
        ///
        /// For example, if `partition_count` = 10 and `page_size` = 8, the first call
        /// to PartitionQuery will return up to 8 partitions and a `next_page_token`
        /// if more results exist. A second call to PartitionQuery will return up to
        /// 2 partitions, to complete the total of 10 specified in `partition_count`.
        #[prost(int32, tag = "5")]
        pub page_size: i32,
        /// The query to partition.
        #[prost(oneof = "partition_query_request::QueryType", tags = "2")]
        pub query_type: ::core::option::Option<partition_query_request::QueryType>,
        /// The consistency mode for this request.
        /// If not set, defaults to strong consistency.
        #[prost(oneof = "partition_query_request::ConsistencySelector", tags = "6")]
        pub consistency_selector: ::core::option::Option<
            partition_query_request::ConsistencySelector,
        >,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for PartitionQueryRequest {
        #[inline]
        fn clone(&self) -> PartitionQueryRequest {
            PartitionQueryRequest {
                parent: ::core::clone::Clone::clone(&self.parent),
                partition_count: ::core::clone::Clone::clone(&self.partition_count),
                page_token: ::core::clone::Clone::clone(&self.page_token),
                page_size: ::core::clone::Clone::clone(&self.page_size),
                query_type: ::core::clone::Clone::clone(&self.query_type),
                consistency_selector: ::core::clone::Clone::clone(
                    &self.consistency_selector,
                ),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for PartitionQueryRequest {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for PartitionQueryRequest {
        #[inline]
        fn eq(&self, other: &PartitionQueryRequest) -> bool {
            self.parent == other.parent && self.partition_count == other.partition_count
                && self.page_token == other.page_token
                && self.page_size == other.page_size
                && self.query_type == other.query_type
                && self.consistency_selector == other.consistency_selector
        }
    }
    impl ::prost::Message for PartitionQueryRequest {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.parent != "" {
                ::prost::encoding::string::encode(1u32, &self.parent, buf);
            }
            if let Some(ref oneof) = self.query_type {
                oneof.encode(buf)
            }
            if self.partition_count != 0i64 {
                ::prost::encoding::int64::encode(3u32, &self.partition_count, buf);
            }
            if self.page_token != "" {
                ::prost::encoding::string::encode(4u32, &self.page_token, buf);
            }
            if self.page_size != 0i32 {
                ::prost::encoding::int32::encode(5u32, &self.page_size, buf);
            }
            if let Some(ref oneof) = self.consistency_selector {
                oneof.encode(buf)
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "PartitionQueryRequest";
            match tag {
                1u32 => {
                    let mut value = &mut self.parent;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "parent");
                            error
                        })
                }
                2u32 => {
                    let mut value = &mut self.query_type;
                    partition_query_request::QueryType::merge(
                            value,
                            tag,
                            wire_type,
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "query_type");
                            error
                        })
                }
                3u32 => {
                    let mut value = &mut self.partition_count;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "partition_count");
                            error
                        })
                }
                4u32 => {
                    let mut value = &mut self.page_token;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "page_token");
                            error
                        })
                }
                5u32 => {
                    let mut value = &mut self.page_size;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "page_size");
                            error
                        })
                }
                6u32 => {
                    let mut value = &mut self.consistency_selector;
                    partition_query_request::ConsistencySelector::merge(
                            value,
                            tag,
                            wire_type,
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "consistency_selector");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0
                + if self.parent != "" {
                    ::prost::encoding::string::encoded_len(1u32, &self.parent)
                } else {
                    0
                }
                + self
                    .query_type
                    .as_ref()
                    .map_or(0, partition_query_request::QueryType::encoded_len)
                + if self.partition_count != 0i64 {
                    ::prost::encoding::int64::encoded_len(3u32, &self.partition_count)
                } else {
                    0
                }
                + if self.page_token != "" {
                    ::prost::encoding::string::encoded_len(4u32, &self.page_token)
                } else {
                    0
                }
                + if self.page_size != 0i32 {
                    ::prost::encoding::int32::encoded_len(5u32, &self.page_size)
                } else {
                    0
                }
                + self
                    .consistency_selector
                    .as_ref()
                    .map_or(0, partition_query_request::ConsistencySelector::encoded_len)
        }
        fn clear(&mut self) {
            self.parent.clear();
            self.query_type = ::core::option::Option::None;
            self.partition_count = 0i64;
            self.page_token.clear();
            self.page_size = 0i32;
            self.consistency_selector = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for PartitionQueryRequest {
        fn default() -> Self {
            PartitionQueryRequest {
                parent: ::prost::alloc::string::String::new(),
                query_type: ::core::default::Default::default(),
                partition_count: 0i64,
                page_token: ::prost::alloc::string::String::new(),
                page_size: 0i32,
                consistency_selector: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for PartitionQueryRequest {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("PartitionQueryRequest");
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.parent)
                };
                builder.field("parent", &wrapper)
            };
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.partition_count)
                };
                builder.field("partition_count", &wrapper)
            };
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.page_token)
                };
                builder.field("page_token", &wrapper)
            };
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.page_size)
                };
                builder.field("page_size", &wrapper)
            };
            let builder = {
                let wrapper = &self.query_type;
                builder.field("query_type", &wrapper)
            };
            let builder = {
                let wrapper = &self.consistency_selector;
                builder.field("consistency_selector", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for PartitionQueryRequest {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "parent" => _serde::__private::Ok(__Field::__field0),
                            "partitionCount" => _serde::__private::Ok(__Field::__field1),
                            "pageToken" => _serde::__private::Ok(__Field::__field2),
                            "pageSize" => _serde::__private::Ok(__Field::__field3),
                            "queryType" => _serde::__private::Ok(__Field::__field4),
                            "consistencySelector" => {
                                _serde::__private::Ok(__Field::__field5)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"parent" => _serde::__private::Ok(__Field::__field0),
                            b"partitionCount" => _serde::__private::Ok(__Field::__field1),
                            b"pageToken" => _serde::__private::Ok(__Field::__field2),
                            b"pageSize" => _serde::__private::Ok(__Field::__field3),
                            b"queryType" => _serde::__private::Ok(__Field::__field4),
                            b"consistencySelector" => {
                                _serde::__private::Ok(__Field::__field5)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<PartitionQueryRequest>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = PartitionQueryRequest;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct PartitionQueryRequest",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::string::String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct PartitionQueryRequest with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct PartitionQueryRequest with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::string::String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct PartitionQueryRequest with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            i32,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct PartitionQueryRequest with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<partition_query_request::QueryType>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct PartitionQueryRequest with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<
                                partition_query_request::ConsistencySelector,
                            >,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct PartitionQueryRequest with 6 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(PartitionQueryRequest {
                            parent: __field0,
                            partition_count: __field1,
                            page_token: __field2,
                            page_size: __field3,
                            query_type: __field4,
                            consistency_selector: __field5,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::prost::alloc::string::String,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            ::prost::alloc::string::String,
                        > = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<i32> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<
                            ::core::option::Option<partition_query_request::QueryType>,
                        > = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<
                            ::core::option::Option<
                                partition_query_request::ConsistencySelector,
                            >,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("parent"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::string::String,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "partitionCount",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "pageToken",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::string::String,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "pageSize",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i32>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "queryType",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<partition_query_request::QueryType>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "consistencySelector",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<
                                                partition_query_request::ConsistencySelector,
                                            >,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("parent")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("partitionCount")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("pageToken")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("pageSize")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("queryType")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("consistencySelector")?
                            }
                        };
                        _serde::__private::Ok(PartitionQueryRequest {
                            parent: __field0,
                            partition_count: __field1,
                            page_token: __field2,
                            page_size: __field3,
                            query_type: __field4,
                            consistency_selector: __field5,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "parent",
                    "partitionCount",
                    "pageToken",
                    "pageSize",
                    "queryType",
                    "consistencySelector",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "PartitionQueryRequest",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<PartitionQueryRequest>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for PartitionQueryRequest {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "PartitionQueryRequest",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "parent",
                    &self.parent,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "partitionCount",
                    &self.partition_count,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "pageToken",
                    &self.page_token,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "pageSize",
                    &self.page_size,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "queryType",
                    &self.query_type,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "consistencySelector",
                    &self.consistency_selector,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// Nested message and enum types in `PartitionQueryRequest`.
    pub mod partition_query_request {
        /// The query to partition.
        #[serde(rename_all = "camelCase")]
        #[allow(clippy::derive_partial_eq_without_eq)]
        pub enum QueryType {
            /// A structured query.
            /// Query must specify collection with all descendants and be ordered by name
            /// ascending. Other filters, order bys, limits, offsets, and start/end
            /// cursors are not supported.
            #[prost(message, tag = "2")]
            StructuredQuery(super::StructuredQuery),
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::clone::Clone for QueryType {
            #[inline]
            fn clone(&self) -> QueryType {
                match self {
                    QueryType::StructuredQuery(__self_0) => {
                        QueryType::StructuredQuery(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::marker::StructuralPartialEq for QueryType {}
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::cmp::PartialEq for QueryType {
            #[inline]
            fn eq(&self, other: &QueryType) -> bool {
                match (self, other) {
                    (
                        QueryType::StructuredQuery(__self_0),
                        QueryType::StructuredQuery(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                }
            }
        }
        impl QueryType {
            /// Encodes the message to a buffer.
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    QueryType::StructuredQuery(ref value) => {
                        ::prost::encoding::message::encode(2u32, &*value, buf);
                    }
                }
            }
            /// Decodes an instance of the message from a buffer, and merges it into self.
            pub fn merge<B>(
                field: &mut ::core::option::Option<QueryType>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag {
                    2u32 => {
                        match field {
                            ::core::option::Option::Some(
                                QueryType::StructuredQuery(ref mut value),
                            ) => {
                                ::prost::encoding::message::merge(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            QueryType::StructuredQuery(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    _ => {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "internal error: entered unreachable code: {0}",
                                format_args!("invalid QueryType tag: {0}", tag),
                            ),
                        );
                    }
                }
            }
            /// Returns the encoded length of the message without a length delimiter.
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    QueryType::StructuredQuery(ref value) => {
                        ::prost::encoding::message::encoded_len(2u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for QueryType {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    QueryType::StructuredQuery(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("StructuredQuery").field(&wrapper).finish()
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for QueryType {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 1",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "structuredQuery" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"structuredQuery" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<QueryType>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = QueryType;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum QueryType",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            super::StructuredQuery,
                                        >(__variant),
                                        QueryType::StructuredQuery,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &["structuredQuery"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "QueryType",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<QueryType>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for QueryType {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        QueryType::StructuredQuery(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "QueryType",
                                0u32,
                                "structuredQuery",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
        /// The consistency mode for this request.
        /// If not set, defaults to strong consistency.
        #[serde(rename_all = "camelCase")]
        #[allow(clippy::derive_partial_eq_without_eq)]
        pub enum ConsistencySelector {
            /// Reads documents as they were at the given time.
            ///
            /// This must be a microsecond precision timestamp within the past one hour,
            /// or if Point-in-Time Recovery is enabled, can additionally be a whole
            /// minute timestamp within the past 7 days.
            #[prost(message, tag = "6")]
            ReadTime(super::super::super::protobuf::Timestamp),
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::clone::Clone for ConsistencySelector {
            #[inline]
            fn clone(&self) -> ConsistencySelector {
                match self {
                    ConsistencySelector::ReadTime(__self_0) => {
                        ConsistencySelector::ReadTime(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::marker::StructuralPartialEq for ConsistencySelector {}
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::cmp::PartialEq for ConsistencySelector {
            #[inline]
            fn eq(&self, other: &ConsistencySelector) -> bool {
                match (self, other) {
                    (
                        ConsistencySelector::ReadTime(__self_0),
                        ConsistencySelector::ReadTime(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                }
            }
        }
        impl ConsistencySelector {
            /// Encodes the message to a buffer.
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    ConsistencySelector::ReadTime(ref value) => {
                        ::prost::encoding::message::encode(6u32, &*value, buf);
                    }
                }
            }
            /// Decodes an instance of the message from a buffer, and merges it into self.
            pub fn merge<B>(
                field: &mut ::core::option::Option<ConsistencySelector>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag {
                    6u32 => {
                        match field {
                            ::core::option::Option::Some(
                                ConsistencySelector::ReadTime(ref mut value),
                            ) => {
                                ::prost::encoding::message::merge(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            ConsistencySelector::ReadTime(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    _ => {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "internal error: entered unreachable code: {0}",
                                format_args!("invalid ConsistencySelector tag: {0}", tag),
                            ),
                        );
                    }
                }
            }
            /// Returns the encoded length of the message without a length delimiter.
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    ConsistencySelector::ReadTime(ref value) => {
                        ::prost::encoding::message::encoded_len(6u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for ConsistencySelector {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ConsistencySelector::ReadTime(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ReadTime").field(&wrapper).finish()
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ConsistencySelector {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 1",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "readTime" => _serde::__private::Ok(__Field::__field0),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"readTime" => _serde::__private::Ok(__Field::__field0),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ConsistencySelector>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ConsistencySelector;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum ConsistencySelector",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            super::super::super::protobuf::Timestamp,
                                        >(__variant),
                                        ConsistencySelector::ReadTime,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &["readTime"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "ConsistencySelector",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                ConsistencySelector,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ConsistencySelector {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        ConsistencySelector::ReadTime(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "ConsistencySelector",
                                0u32,
                                "readTime",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
    }
    /// The response for
    /// [Firestore.PartitionQuery][google.firestore.v1.Firestore.PartitionQuery].
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct PartitionQueryResponse {
        /// Partition results.
        /// Each partition is a split point that can be used by RunQuery as a starting
        /// or end point for the query results. The RunQuery requests must be made with
        /// the same query supplied to this PartitionQuery request. The partition
        /// cursors will be ordered according to same ordering as the results of the
        /// query supplied to PartitionQuery.
        ///
        /// For example, if a PartitionQuery request returns partition cursors A and B,
        /// running the following three queries will return the entire result set of
        /// the original query:
        ///
        ///   * query, end_at A
        ///   * query, start_at A, end_at B
        ///   * query, start_at B
        ///
        /// An empty result may indicate that the query has too few results to be
        /// partitioned, or that the query is not yet supported for partitioning.
        #[prost(message, repeated, tag = "1")]
        pub partitions: ::prost::alloc::vec::Vec<Cursor>,
        /// A page token that may be used to request an additional set of results, up
        /// to the number specified by `partition_count` in the PartitionQuery request.
        /// If blank, there are no more results.
        #[prost(string, tag = "2")]
        pub next_page_token: ::prost::alloc::string::String,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for PartitionQueryResponse {
        #[inline]
        fn clone(&self) -> PartitionQueryResponse {
            PartitionQueryResponse {
                partitions: ::core::clone::Clone::clone(&self.partitions),
                next_page_token: ::core::clone::Clone::clone(&self.next_page_token),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for PartitionQueryResponse {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for PartitionQueryResponse {
        #[inline]
        fn eq(&self, other: &PartitionQueryResponse) -> bool {
            self.partitions == other.partitions
                && self.next_page_token == other.next_page_token
        }
    }
    impl ::prost::Message for PartitionQueryResponse {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            for msg in &self.partitions {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if self.next_page_token != "" {
                ::prost::encoding::string::encode(2u32, &self.next_page_token, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "PartitionQueryResponse";
            match tag {
                1u32 => {
                    let mut value = &mut self.partitions;
                    ::prost::encoding::message::merge_repeated(
                            wire_type,
                            value,
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "partitions");
                            error
                        })
                }
                2u32 => {
                    let mut value = &mut self.next_page_token;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "next_page_token");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + ::prost::encoding::message::encoded_len_repeated(1u32, &self.partitions)
                + if self.next_page_token != "" {
                    ::prost::encoding::string::encoded_len(2u32, &self.next_page_token)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.partitions.clear();
            self.next_page_token.clear();
        }
    }
    impl ::core::default::Default for PartitionQueryResponse {
        fn default() -> Self {
            PartitionQueryResponse {
                partitions: ::core::default::Default::default(),
                next_page_token: ::prost::alloc::string::String::new(),
            }
        }
    }
    impl ::core::fmt::Debug for PartitionQueryResponse {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("PartitionQueryResponse");
            let builder = {
                let wrapper = &self.partitions;
                builder.field("partitions", &wrapper)
            };
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.next_page_token)
                };
                builder.field("next_page_token", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for PartitionQueryResponse {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "partitions" => _serde::__private::Ok(__Field::__field0),
                            "nextPageToken" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"partitions" => _serde::__private::Ok(__Field::__field0),
                            b"nextPageToken" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<PartitionQueryResponse>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = PartitionQueryResponse;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct PartitionQueryResponse",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::vec::Vec<Cursor>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct PartitionQueryResponse with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::string::String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct PartitionQueryResponse with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(PartitionQueryResponse {
                            partitions: __field0,
                            next_page_token: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::prost::alloc::vec::Vec<Cursor>,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            ::prost::alloc::string::String,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "partitions",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::vec::Vec<Cursor>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "nextPageToken",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::string::String,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("partitions")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("nextPageToken")?
                            }
                        };
                        _serde::__private::Ok(PartitionQueryResponse {
                            partitions: __field0,
                            next_page_token: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["partitions", "nextPageToken"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "PartitionQueryResponse",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<PartitionQueryResponse>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for PartitionQueryResponse {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "PartitionQueryResponse",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "partitions",
                    &self.partitions,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "nextPageToken",
                    &self.next_page_token,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// The request for [Firestore.Write][google.firestore.v1.Firestore.Write].
    ///
    /// The first request creates a stream, or resumes an existing one from a token.
    ///
    /// When creating a new stream, the server replies with a response containing
    /// only an ID and a token, to use in the next request.
    ///
    /// When resuming a stream, the server first streams any responses later than the
    /// given token, then a response containing only an up-to-date token, to use in
    /// the next request.
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct WriteRequest {
        /// Required. The database name. In the format:
        /// `projects/{project_id}/databases/{database_id}`.
        /// This is only required in the first message.
        #[prost(string, tag = "1")]
        pub database: ::prost::alloc::string::String,
        /// The ID of the write stream to resume.
        /// This may only be set in the first message. When left empty, a new write
        /// stream will be created.
        #[prost(string, tag = "2")]
        pub stream_id: ::prost::alloc::string::String,
        /// The writes to apply.
        ///
        /// Always executed atomically and in order.
        /// This must be empty on the first request.
        /// This may be empty on the last request.
        /// This must not be empty on all other requests.
        #[prost(message, repeated, tag = "3")]
        pub writes: ::prost::alloc::vec::Vec<Write>,
        /// A stream token that was previously sent by the server.
        ///
        /// The client should set this field to the token from the most recent
        /// [WriteResponse][google.firestore.v1.WriteResponse] it has received. This
        /// acknowledges that the client has received responses up to this token. After
        /// sending this token, earlier tokens may not be used anymore.
        ///
        /// The server may close the stream if there are too many unacknowledged
        /// responses.
        ///
        /// Leave this field unset when creating a new stream. To resume a stream at
        /// a specific point, set this field and the `stream_id` field.
        ///
        /// Leave this field unset when creating a new stream.
        #[prost(bytes = "vec", tag = "4")]
        pub stream_token: ::prost::alloc::vec::Vec<u8>,
        /// Labels associated with this write request.
        #[prost(map = "string, string", tag = "5")]
        pub labels: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            ::prost::alloc::string::String,
        >,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for WriteRequest {
        #[inline]
        fn clone(&self) -> WriteRequest {
            WriteRequest {
                database: ::core::clone::Clone::clone(&self.database),
                stream_id: ::core::clone::Clone::clone(&self.stream_id),
                writes: ::core::clone::Clone::clone(&self.writes),
                stream_token: ::core::clone::Clone::clone(&self.stream_token),
                labels: ::core::clone::Clone::clone(&self.labels),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for WriteRequest {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for WriteRequest {
        #[inline]
        fn eq(&self, other: &WriteRequest) -> bool {
            self.database == other.database && self.stream_id == other.stream_id
                && self.writes == other.writes && self.stream_token == other.stream_token
                && self.labels == other.labels
        }
    }
    impl ::prost::Message for WriteRequest {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.database != "" {
                ::prost::encoding::string::encode(1u32, &self.database, buf);
            }
            if self.stream_id != "" {
                ::prost::encoding::string::encode(2u32, &self.stream_id, buf);
            }
            for msg in &self.writes {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
            if self.stream_token != b"" as &[u8] {
                ::prost::encoding::bytes::encode(4u32, &self.stream_token, buf);
            }
            ::prost::encoding::hash_map::encode(
                ::prost::encoding::string::encode,
                ::prost::encoding::string::encoded_len,
                ::prost::encoding::string::encode,
                ::prost::encoding::string::encoded_len,
                5u32,
                &self.labels,
                buf,
            );
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "WriteRequest";
            match tag {
                1u32 => {
                    let mut value = &mut self.database;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "database");
                            error
                        })
                }
                2u32 => {
                    let mut value = &mut self.stream_id;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "stream_id");
                            error
                        })
                }
                3u32 => {
                    let mut value = &mut self.writes;
                    ::prost::encoding::message::merge_repeated(
                            wire_type,
                            value,
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "writes");
                            error
                        })
                }
                4u32 => {
                    let mut value = &mut self.stream_token;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "stream_token");
                            error
                        })
                }
                5u32 => {
                    let mut value = &mut self.labels;
                    ::prost::encoding::hash_map::merge(
                            ::prost::encoding::string::merge,
                            ::prost::encoding::string::merge,
                            &mut value,
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "labels");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0
                + if self.database != "" {
                    ::prost::encoding::string::encoded_len(1u32, &self.database)
                } else {
                    0
                }
                + if self.stream_id != "" {
                    ::prost::encoding::string::encoded_len(2u32, &self.stream_id)
                } else {
                    0
                } + ::prost::encoding::message::encoded_len_repeated(3u32, &self.writes)
                + if self.stream_token != b"" as &[u8] {
                    ::prost::encoding::bytes::encoded_len(4u32, &self.stream_token)
                } else {
                    0
                }
                + ::prost::encoding::hash_map::encoded_len(
                    ::prost::encoding::string::encoded_len,
                    ::prost::encoding::string::encoded_len,
                    5u32,
                    &self.labels,
                )
        }
        fn clear(&mut self) {
            self.database.clear();
            self.stream_id.clear();
            self.writes.clear();
            self.stream_token.clear();
            self.labels.clear();
        }
    }
    impl ::core::default::Default for WriteRequest {
        fn default() -> Self {
            WriteRequest {
                database: ::prost::alloc::string::String::new(),
                stream_id: ::prost::alloc::string::String::new(),
                writes: ::core::default::Default::default(),
                stream_token: ::core::default::Default::default(),
                labels: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for WriteRequest {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("WriteRequest");
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.database)
                };
                builder.field("database", &wrapper)
            };
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.stream_id)
                };
                builder.field("stream_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.writes;
                builder.field("writes", &wrapper)
            };
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.stream_token)
                };
                builder.field("stream_token", &wrapper)
            };
            let builder = {
                let wrapper = {
                    struct MapWrapper<'a>(
                        &'a ::std::collections::HashMap<
                            ::prost::alloc::string::String,
                            ::prost::alloc::string::String,
                        >,
                    );
                    impl<'a> ::core::fmt::Debug for MapWrapper<'a> {
                        fn fmt(
                            &self,
                            f: &mut ::core::fmt::Formatter,
                        ) -> ::core::fmt::Result {
                            #[allow(non_snake_case)]
                            fn KeyWrapper<T>(v: T) -> T {
                                v
                            }
                            #[allow(non_snake_case)]
                            fn ValueWrapper<T>(v: T) -> T {
                                v
                            }
                            let mut builder = f.debug_map();
                            for (k, v) in self.0 {
                                builder.entry(&KeyWrapper(k), &ValueWrapper(v));
                            }
                            builder.finish()
                        }
                    }
                    MapWrapper(&self.labels)
                };
                builder.field("labels", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for WriteRequest {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "database" => _serde::__private::Ok(__Field::__field0),
                            "streamId" => _serde::__private::Ok(__Field::__field1),
                            "writes" => _serde::__private::Ok(__Field::__field2),
                            "streamToken" => _serde::__private::Ok(__Field::__field3),
                            "labels" => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"database" => _serde::__private::Ok(__Field::__field0),
                            b"streamId" => _serde::__private::Ok(__Field::__field1),
                            b"writes" => _serde::__private::Ok(__Field::__field2),
                            b"streamToken" => _serde::__private::Ok(__Field::__field3),
                            b"labels" => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<WriteRequest>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = WriteRequest;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct WriteRequest",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::string::String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct WriteRequest with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::string::String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct WriteRequest with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::vec::Vec<Write>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct WriteRequest with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::vec::Vec<u8>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct WriteRequest with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            ::std::collections::HashMap<
                                ::prost::alloc::string::String,
                                ::prost::alloc::string::String,
                            >,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct WriteRequest with 5 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(WriteRequest {
                            database: __field0,
                            stream_id: __field1,
                            writes: __field2,
                            stream_token: __field3,
                            labels: __field4,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::prost::alloc::string::String,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            ::prost::alloc::string::String,
                        > = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            ::prost::alloc::vec::Vec<Write>,
                        > = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<
                            ::prost::alloc::vec::Vec<u8>,
                        > = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<
                            ::std::collections::HashMap<
                                ::prost::alloc::string::String,
                                ::prost::alloc::string::String,
                            >,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "database",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::string::String,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "streamId",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::string::String,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("writes"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::vec::Vec<Write>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "streamToken",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::vec::Vec<u8>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("labels"),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::std::collections::HashMap<
                                                ::prost::alloc::string::String,
                                                ::prost::alloc::string::String,
                                            >,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("database")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("streamId")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("writes")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("streamToken")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("labels")?
                            }
                        };
                        _serde::__private::Ok(WriteRequest {
                            database: __field0,
                            stream_id: __field1,
                            writes: __field2,
                            stream_token: __field3,
                            labels: __field4,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "database",
                    "streamId",
                    "writes",
                    "streamToken",
                    "labels",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "WriteRequest",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<WriteRequest>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for WriteRequest {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "WriteRequest",
                    false as usize + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "database",
                    &self.database,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "streamId",
                    &self.stream_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "writes",
                    &self.writes,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "streamToken",
                    &self.stream_token,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "labels",
                    &self.labels,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// The response for [Firestore.Write][google.firestore.v1.Firestore.Write].
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct WriteResponse {
        /// The ID of the stream.
        /// Only set on the first message, when a new stream was created.
        #[prost(string, tag = "1")]
        pub stream_id: ::prost::alloc::string::String,
        /// A token that represents the position of this response in the stream.
        /// This can be used by a client to resume the stream at this point.
        ///
        /// This field is always set.
        #[prost(bytes = "vec", tag = "2")]
        pub stream_token: ::prost::alloc::vec::Vec<u8>,
        /// The result of applying the writes.
        ///
        /// This i-th write result corresponds to the i-th write in the
        /// request.
        #[prost(message, repeated, tag = "3")]
        pub write_results: ::prost::alloc::vec::Vec<WriteResult>,
        /// The time at which the commit occurred. Any read with an equal or greater
        /// `read_time` is guaranteed to see the effects of the write.
        #[prost(message, optional, tag = "4")]
        pub commit_time: ::core::option::Option<super::super::protobuf::Timestamp>,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for WriteResponse {
        #[inline]
        fn clone(&self) -> WriteResponse {
            WriteResponse {
                stream_id: ::core::clone::Clone::clone(&self.stream_id),
                stream_token: ::core::clone::Clone::clone(&self.stream_token),
                write_results: ::core::clone::Clone::clone(&self.write_results),
                commit_time: ::core::clone::Clone::clone(&self.commit_time),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for WriteResponse {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for WriteResponse {
        #[inline]
        fn eq(&self, other: &WriteResponse) -> bool {
            self.stream_id == other.stream_id && self.stream_token == other.stream_token
                && self.write_results == other.write_results
                && self.commit_time == other.commit_time
        }
    }
    impl ::prost::Message for WriteResponse {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.stream_id != "" {
                ::prost::encoding::string::encode(1u32, &self.stream_id, buf);
            }
            if self.stream_token != b"" as &[u8] {
                ::prost::encoding::bytes::encode(2u32, &self.stream_token, buf);
            }
            for msg in &self.write_results {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
            if let Some(ref msg) = self.commit_time {
                ::prost::encoding::message::encode(4u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "WriteResponse";
            match tag {
                1u32 => {
                    let mut value = &mut self.stream_id;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "stream_id");
                            error
                        })
                }
                2u32 => {
                    let mut value = &mut self.stream_token;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "stream_token");
                            error
                        })
                }
                3u32 => {
                    let mut value = &mut self.write_results;
                    ::prost::encoding::message::merge_repeated(
                            wire_type,
                            value,
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "write_results");
                            error
                        })
                }
                4u32 => {
                    let mut value = &mut self.commit_time;
                    ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "commit_time");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0
                + if self.stream_id != "" {
                    ::prost::encoding::string::encoded_len(1u32, &self.stream_id)
                } else {
                    0
                }
                + if self.stream_token != b"" as &[u8] {
                    ::prost::encoding::bytes::encoded_len(2u32, &self.stream_token)
                } else {
                    0
                }
                + ::prost::encoding::message::encoded_len_repeated(
                    3u32,
                    &self.write_results,
                )
                + self
                    .commit_time
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(4u32, msg))
        }
        fn clear(&mut self) {
            self.stream_id.clear();
            self.stream_token.clear();
            self.write_results.clear();
            self.commit_time = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for WriteResponse {
        fn default() -> Self {
            WriteResponse {
                stream_id: ::prost::alloc::string::String::new(),
                stream_token: ::core::default::Default::default(),
                write_results: ::core::default::Default::default(),
                commit_time: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for WriteResponse {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("WriteResponse");
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.stream_id)
                };
                builder.field("stream_id", &wrapper)
            };
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.stream_token)
                };
                builder.field("stream_token", &wrapper)
            };
            let builder = {
                let wrapper = &self.write_results;
                builder.field("write_results", &wrapper)
            };
            let builder = {
                let wrapper = &self.commit_time;
                builder.field("commit_time", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for WriteResponse {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "streamId" => _serde::__private::Ok(__Field::__field0),
                            "streamToken" => _serde::__private::Ok(__Field::__field1),
                            "writeResults" => _serde::__private::Ok(__Field::__field2),
                            "commitTime" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"streamId" => _serde::__private::Ok(__Field::__field0),
                            b"streamToken" => _serde::__private::Ok(__Field::__field1),
                            b"writeResults" => _serde::__private::Ok(__Field::__field2),
                            b"commitTime" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<WriteResponse>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = WriteResponse;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct WriteResponse",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::string::String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct WriteResponse with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::vec::Vec<u8>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct WriteResponse with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::vec::Vec<WriteResult>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct WriteResponse with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<super::super::protobuf::Timestamp>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct WriteResponse with 4 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(WriteResponse {
                            stream_id: __field0,
                            stream_token: __field1,
                            write_results: __field2,
                            commit_time: __field3,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::prost::alloc::string::String,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            ::prost::alloc::vec::Vec<u8>,
                        > = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            ::prost::alloc::vec::Vec<WriteResult>,
                        > = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<
                            ::core::option::Option<super::super::protobuf::Timestamp>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "streamId",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::string::String,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "streamToken",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::vec::Vec<u8>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "writeResults",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::vec::Vec<WriteResult>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "commitTime",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<super::super::protobuf::Timestamp>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("streamId")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("streamToken")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("writeResults")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("commitTime")?
                            }
                        };
                        _serde::__private::Ok(WriteResponse {
                            stream_id: __field0,
                            stream_token: __field1,
                            write_results: __field2,
                            commit_time: __field3,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "streamId",
                    "streamToken",
                    "writeResults",
                    "commitTime",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "WriteResponse",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<WriteResponse>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for WriteResponse {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "WriteResponse",
                    false as usize + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "streamId",
                    &self.stream_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "streamToken",
                    &self.stream_token,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "writeResults",
                    &self.write_results,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "commitTime",
                    &self.commit_time,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// A request for [Firestore.Listen][google.firestore.v1.Firestore.Listen]
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct ListenRequest {
        /// Required. The database name. In the format:
        /// `projects/{project_id}/databases/{database_id}`.
        #[prost(string, tag = "1")]
        pub database: ::prost::alloc::string::String,
        /// Labels associated with this target change.
        #[prost(map = "string, string", tag = "4")]
        pub labels: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            ::prost::alloc::string::String,
        >,
        /// The supported target changes.
        #[prost(oneof = "listen_request::TargetChange", tags = "2, 3")]
        pub target_change: ::core::option::Option<listen_request::TargetChange>,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for ListenRequest {
        #[inline]
        fn clone(&self) -> ListenRequest {
            ListenRequest {
                database: ::core::clone::Clone::clone(&self.database),
                labels: ::core::clone::Clone::clone(&self.labels),
                target_change: ::core::clone::Clone::clone(&self.target_change),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for ListenRequest {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for ListenRequest {
        #[inline]
        fn eq(&self, other: &ListenRequest) -> bool {
            self.database == other.database && self.labels == other.labels
                && self.target_change == other.target_change
        }
    }
    impl ::prost::Message for ListenRequest {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.database != "" {
                ::prost::encoding::string::encode(1u32, &self.database, buf);
            }
            if let Some(ref oneof) = self.target_change {
                oneof.encode(buf)
            }
            ::prost::encoding::hash_map::encode(
                ::prost::encoding::string::encode,
                ::prost::encoding::string::encoded_len,
                ::prost::encoding::string::encode,
                ::prost::encoding::string::encoded_len,
                4u32,
                &self.labels,
                buf,
            );
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ListenRequest";
            match tag {
                1u32 => {
                    let mut value = &mut self.database;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "database");
                            error
                        })
                }
                2u32 | 3u32 => {
                    let mut value = &mut self.target_change;
                    listen_request::TargetChange::merge(value, tag, wire_type, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "target_change");
                            error
                        })
                }
                4u32 => {
                    let mut value = &mut self.labels;
                    ::prost::encoding::hash_map::merge(
                            ::prost::encoding::string::merge,
                            ::prost::encoding::string::merge,
                            &mut value,
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "labels");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0
                + if self.database != "" {
                    ::prost::encoding::string::encoded_len(1u32, &self.database)
                } else {
                    0
                }
                + self
                    .target_change
                    .as_ref()
                    .map_or(0, listen_request::TargetChange::encoded_len)
                + ::prost::encoding::hash_map::encoded_len(
                    ::prost::encoding::string::encoded_len,
                    ::prost::encoding::string::encoded_len,
                    4u32,
                    &self.labels,
                )
        }
        fn clear(&mut self) {
            self.database.clear();
            self.target_change = ::core::option::Option::None;
            self.labels.clear();
        }
    }
    impl ::core::default::Default for ListenRequest {
        fn default() -> Self {
            ListenRequest {
                database: ::prost::alloc::string::String::new(),
                target_change: ::core::default::Default::default(),
                labels: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for ListenRequest {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ListenRequest");
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.database)
                };
                builder.field("database", &wrapper)
            };
            let builder = {
                let wrapper = {
                    struct MapWrapper<'a>(
                        &'a ::std::collections::HashMap<
                            ::prost::alloc::string::String,
                            ::prost::alloc::string::String,
                        >,
                    );
                    impl<'a> ::core::fmt::Debug for MapWrapper<'a> {
                        fn fmt(
                            &self,
                            f: &mut ::core::fmt::Formatter,
                        ) -> ::core::fmt::Result {
                            #[allow(non_snake_case)]
                            fn KeyWrapper<T>(v: T) -> T {
                                v
                            }
                            #[allow(non_snake_case)]
                            fn ValueWrapper<T>(v: T) -> T {
                                v
                            }
                            let mut builder = f.debug_map();
                            for (k, v) in self.0 {
                                builder.entry(&KeyWrapper(k), &ValueWrapper(v));
                            }
                            builder.finish()
                        }
                    }
                    MapWrapper(&self.labels)
                };
                builder.field("labels", &wrapper)
            };
            let builder = {
                let wrapper = &self.target_change;
                builder.field("target_change", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ListenRequest {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "database" => _serde::__private::Ok(__Field::__field0),
                            "labels" => _serde::__private::Ok(__Field::__field1),
                            "targetChange" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"database" => _serde::__private::Ok(__Field::__field0),
                            b"labels" => _serde::__private::Ok(__Field::__field1),
                            b"targetChange" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ListenRequest>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ListenRequest;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ListenRequest",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::string::String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ListenRequest with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            ::std::collections::HashMap<
                                ::prost::alloc::string::String,
                                ::prost::alloc::string::String,
                            >,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct ListenRequest with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<listen_request::TargetChange>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct ListenRequest with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ListenRequest {
                            database: __field0,
                            labels: __field1,
                            target_change: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::prost::alloc::string::String,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            ::std::collections::HashMap<
                                ::prost::alloc::string::String,
                                ::prost::alloc::string::String,
                            >,
                        > = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            ::core::option::Option<listen_request::TargetChange>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "database",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::string::String,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("labels"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::std::collections::HashMap<
                                                ::prost::alloc::string::String,
                                                ::prost::alloc::string::String,
                                            >,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "targetChange",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<listen_request::TargetChange>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("database")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("labels")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("targetChange")?
                            }
                        };
                        _serde::__private::Ok(ListenRequest {
                            database: __field0,
                            labels: __field1,
                            target_change: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "database",
                    "labels",
                    "targetChange",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ListenRequest",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ListenRequest>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ListenRequest {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ListenRequest",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "database",
                    &self.database,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "labels",
                    &self.labels,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "targetChange",
                    &self.target_change,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// Nested message and enum types in `ListenRequest`.
    pub mod listen_request {
        /// The supported target changes.
        #[serde(rename_all = "camelCase")]
        #[allow(clippy::derive_partial_eq_without_eq)]
        pub enum TargetChange {
            /// A target to add to this stream.
            #[prost(message, tag = "2")]
            AddTarget(super::Target),
            /// The ID of a target to remove from this stream.
            #[prost(int32, tag = "3")]
            RemoveTarget(i32),
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::clone::Clone for TargetChange {
            #[inline]
            fn clone(&self) -> TargetChange {
                match self {
                    TargetChange::AddTarget(__self_0) => {
                        TargetChange::AddTarget(::core::clone::Clone::clone(__self_0))
                    }
                    TargetChange::RemoveTarget(__self_0) => {
                        TargetChange::RemoveTarget(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::marker::StructuralPartialEq for TargetChange {}
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::cmp::PartialEq for TargetChange {
            #[inline]
            fn eq(&self, other: &TargetChange) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
                    && match (self, other) {
                        (
                            TargetChange::AddTarget(__self_0),
                            TargetChange::AddTarget(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            TargetChange::RemoveTarget(__self_0),
                            TargetChange::RemoveTarget(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        impl TargetChange {
            /// Encodes the message to a buffer.
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    TargetChange::AddTarget(ref value) => {
                        ::prost::encoding::message::encode(2u32, &*value, buf);
                    }
                    TargetChange::RemoveTarget(ref value) => {
                        ::prost::encoding::int32::encode(3u32, &*value, buf);
                    }
                }
            }
            /// Decodes an instance of the message from a buffer, and merges it into self.
            pub fn merge<B>(
                field: &mut ::core::option::Option<TargetChange>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag {
                    2u32 => {
                        match field {
                            ::core::option::Option::Some(
                                TargetChange::AddTarget(ref mut value),
                            ) => {
                                ::prost::encoding::message::merge(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            TargetChange::AddTarget(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    3u32 => {
                        match field {
                            ::core::option::Option::Some(
                                TargetChange::RemoveTarget(ref mut value),
                            ) => {
                                ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            TargetChange::RemoveTarget(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    _ => {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "internal error: entered unreachable code: {0}",
                                format_args!("invalid TargetChange tag: {0}", tag),
                            ),
                        );
                    }
                }
            }
            /// Returns the encoded length of the message without a length delimiter.
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    TargetChange::AddTarget(ref value) => {
                        ::prost::encoding::message::encoded_len(2u32, &*value)
                    }
                    TargetChange::RemoveTarget(ref value) => {
                        ::prost::encoding::int32::encoded_len(3u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for TargetChange {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    TargetChange::AddTarget(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("AddTarget").field(&wrapper).finish()
                    }
                    TargetChange::RemoveTarget(ref value) => {
                        let wrapper = {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("RemoveTarget").field(&wrapper).finish()
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for TargetChange {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 2",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "addTarget" => _serde::__private::Ok(__Field::__field0),
                                "removeTarget" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"addTarget" => _serde::__private::Ok(__Field::__field0),
                                b"removeTarget" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<TargetChange>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = TargetChange;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum TargetChange",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            super::Target,
                                        >(__variant),
                                        TargetChange::AddTarget,
                                    )
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            i32,
                                        >(__variant),
                                        TargetChange::RemoveTarget,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "addTarget",
                        "removeTarget",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "TargetChange",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<TargetChange>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for TargetChange {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        TargetChange::AddTarget(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "TargetChange",
                                0u32,
                                "addTarget",
                                __field0,
                            )
                        }
                        TargetChange::RemoveTarget(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "TargetChange",
                                1u32,
                                "removeTarget",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
    }
    /// The response for [Firestore.Listen][google.firestore.v1.Firestore.Listen].
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct ListenResponse {
        /// The supported responses.
        #[prost(oneof = "listen_response::ResponseType", tags = "2, 3, 4, 6, 5")]
        pub response_type: ::core::option::Option<listen_response::ResponseType>,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for ListenResponse {
        #[inline]
        fn clone(&self) -> ListenResponse {
            ListenResponse {
                response_type: ::core::clone::Clone::clone(&self.response_type),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for ListenResponse {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for ListenResponse {
        #[inline]
        fn eq(&self, other: &ListenResponse) -> bool {
            self.response_type == other.response_type
        }
    }
    impl ::prost::Message for ListenResponse {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref oneof) = self.response_type {
                oneof.encode(buf)
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ListenResponse";
            match tag {
                2u32 | 3u32 | 4u32 | 6u32 | 5u32 => {
                    let mut value = &mut self.response_type;
                    listen_response::ResponseType::merge(value, tag, wire_type, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "response_type");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0
                + self
                    .response_type
                    .as_ref()
                    .map_or(0, listen_response::ResponseType::encoded_len)
        }
        fn clear(&mut self) {
            self.response_type = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for ListenResponse {
        fn default() -> Self {
            ListenResponse {
                response_type: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for ListenResponse {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ListenResponse");
            let builder = {
                let wrapper = &self.response_type;
                builder.field("response_type", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ListenResponse {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "responseType" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"responseType" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ListenResponse>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ListenResponse;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ListenResponse",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<listen_response::ResponseType>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ListenResponse with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ListenResponse {
                            response_type: __field0,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::core::option::Option<listen_response::ResponseType>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "responseType",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<listen_response::ResponseType>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("responseType")?
                            }
                        };
                        _serde::__private::Ok(ListenResponse {
                            response_type: __field0,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["responseType"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ListenResponse",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ListenResponse>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ListenResponse {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ListenResponse",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "responseType",
                    &self.response_type,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// Nested message and enum types in `ListenResponse`.
    pub mod listen_response {
        /// The supported responses.
        #[serde(rename_all = "camelCase")]
        #[allow(clippy::derive_partial_eq_without_eq)]
        pub enum ResponseType {
            /// Targets have changed.
            #[prost(message, tag = "2")]
            TargetChange(super::TargetChange),
            /// A [Document][google.firestore.v1.Document] has changed.
            #[prost(message, tag = "3")]
            DocumentChange(super::DocumentChange),
            /// A [Document][google.firestore.v1.Document] has been deleted.
            #[prost(message, tag = "4")]
            DocumentDelete(super::DocumentDelete),
            /// A [Document][google.firestore.v1.Document] has been removed from a target
            /// (because it is no longer relevant to that target).
            #[prost(message, tag = "6")]
            DocumentRemove(super::DocumentRemove),
            /// A filter to apply to the set of documents previously returned for the
            /// given target.
            ///
            /// Returned when documents may have been removed from the given target, but
            /// the exact documents are unknown.
            #[prost(message, tag = "5")]
            Filter(super::ExistenceFilter),
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::clone::Clone for ResponseType {
            #[inline]
            fn clone(&self) -> ResponseType {
                match self {
                    ResponseType::TargetChange(__self_0) => {
                        ResponseType::TargetChange(::core::clone::Clone::clone(__self_0))
                    }
                    ResponseType::DocumentChange(__self_0) => {
                        ResponseType::DocumentChange(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    ResponseType::DocumentDelete(__self_0) => {
                        ResponseType::DocumentDelete(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    ResponseType::DocumentRemove(__self_0) => {
                        ResponseType::DocumentRemove(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    ResponseType::Filter(__self_0) => {
                        ResponseType::Filter(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::marker::StructuralPartialEq for ResponseType {}
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::cmp::PartialEq for ResponseType {
            #[inline]
            fn eq(&self, other: &ResponseType) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
                    && match (self, other) {
                        (
                            ResponseType::TargetChange(__self_0),
                            ResponseType::TargetChange(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            ResponseType::DocumentChange(__self_0),
                            ResponseType::DocumentChange(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            ResponseType::DocumentDelete(__self_0),
                            ResponseType::DocumentDelete(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            ResponseType::DocumentRemove(__self_0),
                            ResponseType::DocumentRemove(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            ResponseType::Filter(__self_0),
                            ResponseType::Filter(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        impl ResponseType {
            /// Encodes the message to a buffer.
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    ResponseType::TargetChange(ref value) => {
                        ::prost::encoding::message::encode(2u32, &*value, buf);
                    }
                    ResponseType::DocumentChange(ref value) => {
                        ::prost::encoding::message::encode(3u32, &*value, buf);
                    }
                    ResponseType::DocumentDelete(ref value) => {
                        ::prost::encoding::message::encode(4u32, &*value, buf);
                    }
                    ResponseType::DocumentRemove(ref value) => {
                        ::prost::encoding::message::encode(6u32, &*value, buf);
                    }
                    ResponseType::Filter(ref value) => {
                        ::prost::encoding::message::encode(5u32, &*value, buf);
                    }
                }
            }
            /// Decodes an instance of the message from a buffer, and merges it into self.
            pub fn merge<B>(
                field: &mut ::core::option::Option<ResponseType>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag {
                    2u32 => {
                        match field {
                            ::core::option::Option::Some(
                                ResponseType::TargetChange(ref mut value),
                            ) => {
                                ::prost::encoding::message::merge(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            ResponseType::TargetChange(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    3u32 => {
                        match field {
                            ::core::option::Option::Some(
                                ResponseType::DocumentChange(ref mut value),
                            ) => {
                                ::prost::encoding::message::merge(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            ResponseType::DocumentChange(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    4u32 => {
                        match field {
                            ::core::option::Option::Some(
                                ResponseType::DocumentDelete(ref mut value),
                            ) => {
                                ::prost::encoding::message::merge(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            ResponseType::DocumentDelete(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    6u32 => {
                        match field {
                            ::core::option::Option::Some(
                                ResponseType::DocumentRemove(ref mut value),
                            ) => {
                                ::prost::encoding::message::merge(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            ResponseType::DocumentRemove(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    5u32 => {
                        match field {
                            ::core::option::Option::Some(
                                ResponseType::Filter(ref mut value),
                            ) => {
                                ::prost::encoding::message::merge(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            ResponseType::Filter(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    _ => {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "internal error: entered unreachable code: {0}",
                                format_args!("invalid ResponseType tag: {0}", tag),
                            ),
                        );
                    }
                }
            }
            /// Returns the encoded length of the message without a length delimiter.
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    ResponseType::TargetChange(ref value) => {
                        ::prost::encoding::message::encoded_len(2u32, &*value)
                    }
                    ResponseType::DocumentChange(ref value) => {
                        ::prost::encoding::message::encoded_len(3u32, &*value)
                    }
                    ResponseType::DocumentDelete(ref value) => {
                        ::prost::encoding::message::encoded_len(4u32, &*value)
                    }
                    ResponseType::DocumentRemove(ref value) => {
                        ::prost::encoding::message::encoded_len(6u32, &*value)
                    }
                    ResponseType::Filter(ref value) => {
                        ::prost::encoding::message::encoded_len(5u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for ResponseType {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ResponseType::TargetChange(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TargetChange").field(&wrapper).finish()
                    }
                    ResponseType::DocumentChange(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("DocumentChange").field(&wrapper).finish()
                    }
                    ResponseType::DocumentDelete(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("DocumentDelete").field(&wrapper).finish()
                    }
                    ResponseType::DocumentRemove(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("DocumentRemove").field(&wrapper).finish()
                    }
                    ResponseType::Filter(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("Filter").field(&wrapper).finish()
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ResponseType {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 5",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "targetChange" => _serde::__private::Ok(__Field::__field0),
                                "documentChange" => _serde::__private::Ok(__Field::__field1),
                                "documentDelete" => _serde::__private::Ok(__Field::__field2),
                                "documentRemove" => _serde::__private::Ok(__Field::__field3),
                                "filter" => _serde::__private::Ok(__Field::__field4),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"targetChange" => _serde::__private::Ok(__Field::__field0),
                                b"documentChange" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                b"documentDelete" => {
                                    _serde::__private::Ok(__Field::__field2)
                                }
                                b"documentRemove" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                b"filter" => _serde::__private::Ok(__Field::__field4),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ResponseType>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ResponseType;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum ResponseType",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            super::TargetChange,
                                        >(__variant),
                                        ResponseType::TargetChange,
                                    )
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            super::DocumentChange,
                                        >(__variant),
                                        ResponseType::DocumentChange,
                                    )
                                }
                                (__Field::__field2, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            super::DocumentDelete,
                                        >(__variant),
                                        ResponseType::DocumentDelete,
                                    )
                                }
                                (__Field::__field3, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            super::DocumentRemove,
                                        >(__variant),
                                        ResponseType::DocumentRemove,
                                    )
                                }
                                (__Field::__field4, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            super::ExistenceFilter,
                                        >(__variant),
                                        ResponseType::Filter,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "targetChange",
                        "documentChange",
                        "documentDelete",
                        "documentRemove",
                        "filter",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "ResponseType",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ResponseType>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ResponseType {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        ResponseType::TargetChange(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "ResponseType",
                                0u32,
                                "targetChange",
                                __field0,
                            )
                        }
                        ResponseType::DocumentChange(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "ResponseType",
                                1u32,
                                "documentChange",
                                __field0,
                            )
                        }
                        ResponseType::DocumentDelete(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "ResponseType",
                                2u32,
                                "documentDelete",
                                __field0,
                            )
                        }
                        ResponseType::DocumentRemove(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "ResponseType",
                                3u32,
                                "documentRemove",
                                __field0,
                            )
                        }
                        ResponseType::Filter(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "ResponseType",
                                4u32,
                                "filter",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
    }
    /// A specification of a set of documents to listen to.
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct Target {
        /// The target ID that identifies the target on the stream. Must be a positive
        /// number and non-zero.
        ///
        /// If `target_id` is 0 (or unspecified), the server will assign an ID for this
        /// target and return that in a `TargetChange::ADD` event. Once a target with
        /// `target_id=0` is added, all subsequent targets must also have
        /// `target_id=0`. If an `AddTarget` request with `target_id != 0` is
        /// sent to the server after a target with `target_id=0` is added, the server
        /// will immediately send a response with a `TargetChange::Remove` event.
        ///
        /// Note that if the client sends multiple `AddTarget` requests
        /// without an ID, the order of IDs returned in `TargetChage.target_ids` are
        /// undefined. Therefore, clients should provide a target ID instead of relying
        /// on the server to assign one.
        ///
        /// If `target_id` is non-zero, there must not be an existing active target on
        /// this stream with the same ID.
        #[prost(int32, tag = "5")]
        pub target_id: i32,
        /// If the target should be removed once it is current and consistent.
        #[prost(bool, tag = "6")]
        pub once: bool,
        /// The number of documents that last matched the query at the resume token or
        /// read time.
        ///
        /// This value is only relevant when a `resume_type` is provided. This value
        /// being present and greater than zero signals that the client wants
        /// `ExistenceFilter.unchanged_names` to be included in the response.
        #[prost(message, optional, tag = "12")]
        pub expected_count: ::core::option::Option<super::super::protobuf::Int32Value>,
        /// The type of target to listen to.
        #[prost(oneof = "target::TargetType", tags = "2, 3")]
        pub target_type: ::core::option::Option<target::TargetType>,
        /// When to start listening.
        ///
        /// If specified, only the matching Documents that have been updated AFTER the
        /// `resume_token` or `read_time` will be returned. Otherwise, all matching
        /// Documents are returned before any subsequent changes.
        #[prost(oneof = "target::ResumeType", tags = "4, 11")]
        pub resume_type: ::core::option::Option<target::ResumeType>,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for Target {
        #[inline]
        fn clone(&self) -> Target {
            Target {
                target_id: ::core::clone::Clone::clone(&self.target_id),
                once: ::core::clone::Clone::clone(&self.once),
                expected_count: ::core::clone::Clone::clone(&self.expected_count),
                target_type: ::core::clone::Clone::clone(&self.target_type),
                resume_type: ::core::clone::Clone::clone(&self.resume_type),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for Target {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for Target {
        #[inline]
        fn eq(&self, other: &Target) -> bool {
            self.target_id == other.target_id && self.once == other.once
                && self.expected_count == other.expected_count
                && self.target_type == other.target_type
                && self.resume_type == other.resume_type
        }
    }
    impl ::prost::Message for Target {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref oneof) = self.target_type {
                oneof.encode(buf)
            }
            if let Some(ref oneof) = self.resume_type {
                oneof.encode(buf)
            }
            if self.target_id != 0i32 {
                ::prost::encoding::int32::encode(5u32, &self.target_id, buf);
            }
            if self.once != false {
                ::prost::encoding::bool::encode(6u32, &self.once, buf);
            }
            if let Some(ref msg) = self.expected_count {
                ::prost::encoding::message::encode(12u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "Target";
            match tag {
                2u32 | 3u32 => {
                    let mut value = &mut self.target_type;
                    target::TargetType::merge(value, tag, wire_type, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "target_type");
                            error
                        })
                }
                4u32 | 11u32 => {
                    let mut value = &mut self.resume_type;
                    target::ResumeType::merge(value, tag, wire_type, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "resume_type");
                            error
                        })
                }
                5u32 => {
                    let mut value = &mut self.target_id;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "target_id");
                            error
                        })
                }
                6u32 => {
                    let mut value = &mut self.once;
                    ::prost::encoding::bool::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "once");
                            error
                        })
                }
                12u32 => {
                    let mut value = &mut self.expected_count;
                    ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "expected_count");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self.target_type.as_ref().map_or(0, target::TargetType::encoded_len)
                + self.resume_type.as_ref().map_or(0, target::ResumeType::encoded_len)
                + if self.target_id != 0i32 {
                    ::prost::encoding::int32::encoded_len(5u32, &self.target_id)
                } else {
                    0
                }
                + if self.once != false {
                    ::prost::encoding::bool::encoded_len(6u32, &self.once)
                } else {
                    0
                }
                + self
                    .expected_count
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(12u32, msg))
        }
        fn clear(&mut self) {
            self.target_type = ::core::option::Option::None;
            self.resume_type = ::core::option::Option::None;
            self.target_id = 0i32;
            self.once = false;
            self.expected_count = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for Target {
        fn default() -> Self {
            Target {
                target_type: ::core::default::Default::default(),
                resume_type: ::core::default::Default::default(),
                target_id: 0i32,
                once: false,
                expected_count: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for Target {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("Target");
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.target_id)
                };
                builder.field("target_id", &wrapper)
            };
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.once)
                };
                builder.field("once", &wrapper)
            };
            let builder = {
                let wrapper = &self.expected_count;
                builder.field("expected_count", &wrapper)
            };
            let builder = {
                let wrapper = &self.target_type;
                builder.field("target_type", &wrapper)
            };
            let builder = {
                let wrapper = &self.resume_type;
                builder.field("resume_type", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Target {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "targetId" => _serde::__private::Ok(__Field::__field0),
                            "once" => _serde::__private::Ok(__Field::__field1),
                            "expectedCount" => _serde::__private::Ok(__Field::__field2),
                            "targetType" => _serde::__private::Ok(__Field::__field3),
                            "resumeType" => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"targetId" => _serde::__private::Ok(__Field::__field0),
                            b"once" => _serde::__private::Ok(__Field::__field1),
                            b"expectedCount" => _serde::__private::Ok(__Field::__field2),
                            b"targetType" => _serde::__private::Ok(__Field::__field3),
                            b"resumeType" => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Target>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Target;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Target",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            i32,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Target with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Target with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<super::super::protobuf::Int32Value>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct Target with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<target::TargetType>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct Target with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<target::ResumeType>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct Target with 5 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Target {
                            target_id: __field0,
                            once: __field1,
                            expected_count: __field2,
                            target_type: __field3,
                            resume_type: __field4,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<i32> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            ::core::option::Option<super::super::protobuf::Int32Value>,
                        > = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<
                            ::core::option::Option<target::TargetType>,
                        > = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<
                            ::core::option::Option<target::ResumeType>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "targetId",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i32>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("once"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "expectedCount",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<super::super::protobuf::Int32Value>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "targetType",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<target::TargetType>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "resumeType",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<target::ResumeType>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("targetId")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("once")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("expectedCount")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("targetType")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("resumeType")?
                            }
                        };
                        _serde::__private::Ok(Target {
                            target_id: __field0,
                            once: __field1,
                            expected_count: __field2,
                            target_type: __field3,
                            resume_type: __field4,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "targetId",
                    "once",
                    "expectedCount",
                    "targetType",
                    "resumeType",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Target",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Target>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Target {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "Target",
                    false as usize + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "targetId",
                    &self.target_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "once",
                    &self.once,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "expectedCount",
                    &self.expected_count,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "targetType",
                    &self.target_type,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "resumeType",
                    &self.resume_type,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// Nested message and enum types in `Target`.
    pub mod target {
        /// A target specified by a set of documents names.
        #[serde(rename_all = "camelCase")]
        #[allow(clippy::derive_partial_eq_without_eq)]
        pub struct DocumentsTarget {
            /// The names of the documents to retrieve. In the format:
            /// `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
            /// The request will fail if any of the document is not a child resource of
            /// the given `database`. Duplicate names will be elided.
            #[prost(string, repeated, tag = "2")]
            pub documents: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::clone::Clone for DocumentsTarget {
            #[inline]
            fn clone(&self) -> DocumentsTarget {
                DocumentsTarget {
                    documents: ::core::clone::Clone::clone(&self.documents),
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::marker::StructuralPartialEq for DocumentsTarget {}
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::cmp::PartialEq for DocumentsTarget {
            #[inline]
            fn eq(&self, other: &DocumentsTarget) -> bool {
                self.documents == other.documents
            }
        }
        impl ::prost::Message for DocumentsTarget {
            #[allow(unused_variables)]
            fn encode_raw<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                ::prost::encoding::string::encode_repeated(2u32, &self.documents, buf);
            }
            #[allow(unused_variables)]
            fn merge_field<B>(
                &mut self,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                const STRUCT_NAME: &'static str = "DocumentsTarget";
                match tag {
                    2u32 => {
                        let mut value = &mut self.documents;
                        ::prost::encoding::string::merge_repeated(
                                wire_type,
                                value,
                                buf,
                                ctx,
                            )
                            .map_err(|mut error| {
                                error.push(STRUCT_NAME, "documents");
                                error
                            })
                    }
                    _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0
                    + ::prost::encoding::string::encoded_len_repeated(
                        2u32,
                        &self.documents,
                    )
            }
            fn clear(&mut self) {
                self.documents.clear();
            }
        }
        impl ::core::default::Default for DocumentsTarget {
            fn default() -> Self {
                DocumentsTarget {
                    documents: ::prost::alloc::vec::Vec::new(),
                }
            }
        }
        impl ::core::fmt::Debug for DocumentsTarget {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let mut builder = f.debug_struct("DocumentsTarget");
                let builder = {
                    let wrapper = {
                        struct ScalarWrapper<'a>(
                            &'a ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                        );
                        impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                            fn fmt(
                                &self,
                                f: &mut ::core::fmt::Formatter,
                            ) -> ::core::fmt::Result {
                                let mut vec_builder = f.debug_list();
                                for v in self.0 {
                                    #[allow(non_snake_case)]
                                    fn Inner<T>(v: T) -> T {
                                        v
                                    }
                                    vec_builder.entry(&Inner(v));
                                }
                                vec_builder.finish()
                            }
                        }
                        ScalarWrapper(&self.documents)
                    };
                    builder.field("documents", &wrapper)
                };
                builder.finish()
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DocumentsTarget {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "documents" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"documents" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DocumentsTarget>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DocumentsTarget;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DocumentsTarget",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DocumentsTarget with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DocumentsTarget {
                                documents: __field0,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "documents",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("documents")?
                                }
                            };
                            _serde::__private::Ok(DocumentsTarget {
                                documents: __field0,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["documents"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DocumentsTarget",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DocumentsTarget>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for DocumentsTarget {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "DocumentsTarget",
                        false as usize + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "documents",
                        &self.documents,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        /// A target specified by a query.
        #[serde(rename_all = "camelCase")]
        #[allow(clippy::derive_partial_eq_without_eq)]
        pub struct QueryTarget {
            /// The parent resource name. In the format:
            /// `projects/{project_id}/databases/{database_id}/documents` or
            /// `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
            /// For example:
            /// `projects/my-project/databases/my-database/documents` or
            /// `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`
            #[prost(string, tag = "1")]
            pub parent: ::prost::alloc::string::String,
            /// The query to run.
            #[prost(oneof = "query_target::QueryType", tags = "2")]
            pub query_type: ::core::option::Option<query_target::QueryType>,
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::clone::Clone for QueryTarget {
            #[inline]
            fn clone(&self) -> QueryTarget {
                QueryTarget {
                    parent: ::core::clone::Clone::clone(&self.parent),
                    query_type: ::core::clone::Clone::clone(&self.query_type),
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::marker::StructuralPartialEq for QueryTarget {}
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::cmp::PartialEq for QueryTarget {
            #[inline]
            fn eq(&self, other: &QueryTarget) -> bool {
                self.parent == other.parent && self.query_type == other.query_type
            }
        }
        impl ::prost::Message for QueryTarget {
            #[allow(unused_variables)]
            fn encode_raw<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                if self.parent != "" {
                    ::prost::encoding::string::encode(1u32, &self.parent, buf);
                }
                if let Some(ref oneof) = self.query_type {
                    oneof.encode(buf)
                }
            }
            #[allow(unused_variables)]
            fn merge_field<B>(
                &mut self,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                const STRUCT_NAME: &'static str = "QueryTarget";
                match tag {
                    1u32 => {
                        let mut value = &mut self.parent;
                        ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                            .map_err(|mut error| {
                                error.push(STRUCT_NAME, "parent");
                                error
                            })
                    }
                    2u32 => {
                        let mut value = &mut self.query_type;
                        query_target::QueryType::merge(value, tag, wire_type, buf, ctx)
                            .map_err(|mut error| {
                                error.push(STRUCT_NAME, "query_type");
                                error
                            })
                    }
                    _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0
                    + if self.parent != "" {
                        ::prost::encoding::string::encoded_len(1u32, &self.parent)
                    } else {
                        0
                    }
                    + self
                        .query_type
                        .as_ref()
                        .map_or(0, query_target::QueryType::encoded_len)
            }
            fn clear(&mut self) {
                self.parent.clear();
                self.query_type = ::core::option::Option::None;
            }
        }
        impl ::core::default::Default for QueryTarget {
            fn default() -> Self {
                QueryTarget {
                    parent: ::prost::alloc::string::String::new(),
                    query_type: ::core::default::Default::default(),
                }
            }
        }
        impl ::core::fmt::Debug for QueryTarget {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let mut builder = f.debug_struct("QueryTarget");
                let builder = {
                    let wrapper = {
                        #[allow(non_snake_case)]
                        fn ScalarWrapper<T>(v: T) -> T {
                            v
                        }
                        ScalarWrapper(&self.parent)
                    };
                    builder.field("parent", &wrapper)
                };
                let builder = {
                    let wrapper = &self.query_type;
                    builder.field("query_type", &wrapper)
                };
                builder.finish()
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for QueryTarget {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "parent" => _serde::__private::Ok(__Field::__field0),
                                "queryType" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"parent" => _serde::__private::Ok(__Field::__field0),
                                b"queryType" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<QueryTarget>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = QueryTarget;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct QueryTarget",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                ::prost::alloc::string::String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct QueryTarget with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                ::core::option::Option<query_target::QueryType>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct QueryTarget with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(QueryTarget {
                                parent: __field0,
                                query_type: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                ::prost::alloc::string::String,
                            > = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                ::core::option::Option<query_target::QueryType>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("parent"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ::prost::alloc::string::String,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "queryType",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ::core::option::Option<query_target::QueryType>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("parent")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("queryType")?
                                }
                            };
                            _serde::__private::Ok(QueryTarget {
                                parent: __field0,
                                query_type: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["parent", "queryType"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "QueryTarget",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<QueryTarget>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for QueryTarget {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "QueryTarget",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "parent",
                        &self.parent,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "queryType",
                        &self.query_type,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        /// Nested message and enum types in `QueryTarget`.
        pub mod query_target {
            /// The query to run.
            #[serde(rename_all = "camelCase")]
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub enum QueryType {
                /// A structured query.
                #[prost(message, tag = "2")]
                StructuredQuery(super::super::StructuredQuery),
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for QueryType {
                #[inline]
                fn clone(&self) -> QueryType {
                    match self {
                        QueryType::StructuredQuery(__self_0) => {
                            QueryType::StructuredQuery(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::marker::StructuralPartialEq for QueryType {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for QueryType {
                #[inline]
                fn eq(&self, other: &QueryType) -> bool {
                    match (self, other) {
                        (
                            QueryType::StructuredQuery(__self_0),
                            QueryType::StructuredQuery(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                    }
                }
            }
            impl QueryType {
                /// Encodes the message to a buffer.
                pub fn encode<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    match *self {
                        QueryType::StructuredQuery(ref value) => {
                            ::prost::encoding::message::encode(2u32, &*value, buf);
                        }
                    }
                }
                /// Decodes an instance of the message from a buffer, and merges it into self.
                pub fn merge<B>(
                    field: &mut ::core::option::Option<QueryType>,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    match tag {
                        2u32 => {
                            match field {
                                ::core::option::Option::Some(
                                    QueryType::StructuredQuery(ref mut value),
                                ) => {
                                    ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                }
                                _ => {
                                    let mut owned_value = ::core::default::Default::default();
                                    let value = &mut owned_value;
                                    ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                        .map(|_| {
                                            *field = ::core::option::Option::Some(
                                                QueryType::StructuredQuery(owned_value),
                                            );
                                        })
                                }
                            }
                        }
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "internal error: entered unreachable code: {0}",
                                    format_args!("invalid QueryType tag: {0}", tag),
                                ),
                            );
                        }
                    }
                }
                /// Returns the encoded length of the message without a length delimiter.
                #[inline]
                pub fn encoded_len(&self) -> usize {
                    match *self {
                        QueryType::StructuredQuery(ref value) => {
                            ::prost::encoding::message::encoded_len(2u32, &*value)
                        }
                    }
                }
            }
            impl ::core::fmt::Debug for QueryType {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        QueryType::StructuredQuery(ref value) => {
                            let wrapper = &*value;
                            f.debug_tuple("StructuredQuery").field(&wrapper).finish()
                        }
                    }
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for QueryType {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "variant identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 1",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "structuredQuery" => {
                                        _serde::__private::Ok(__Field::__field0)
                                    }
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"structuredQuery" => {
                                        _serde::__private::Ok(__Field::__field0)
                                    }
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<QueryType>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = QueryType;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "enum QueryType",
                                )
                            }
                            fn visit_enum<__A>(
                                self,
                                __data: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::EnumAccess<'de>,
                            {
                                match _serde::de::EnumAccess::variant(__data)? {
                                    (__Field::__field0, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                super::super::StructuredQuery,
                                            >(__variant),
                                            QueryType::StructuredQuery,
                                        )
                                    }
                                }
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] = &["structuredQuery"];
                        _serde::Deserializer::deserialize_enum(
                            __deserializer,
                            "QueryType",
                            VARIANTS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<QueryType>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for QueryType {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        match *self {
                            QueryType::StructuredQuery(ref __field0) => {
                                _serde::Serializer::serialize_newtype_variant(
                                    __serializer,
                                    "QueryType",
                                    0u32,
                                    "structuredQuery",
                                    __field0,
                                )
                            }
                        }
                    }
                }
            };
        }
        /// The type of target to listen to.
        #[serde(rename_all = "camelCase")]
        #[allow(clippy::derive_partial_eq_without_eq)]
        pub enum TargetType {
            /// A target specified by a query.
            #[prost(message, tag = "2")]
            Query(QueryTarget),
            /// A target specified by a set of document names.
            #[prost(message, tag = "3")]
            Documents(DocumentsTarget),
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::clone::Clone for TargetType {
            #[inline]
            fn clone(&self) -> TargetType {
                match self {
                    TargetType::Query(__self_0) => {
                        TargetType::Query(::core::clone::Clone::clone(__self_0))
                    }
                    TargetType::Documents(__self_0) => {
                        TargetType::Documents(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::marker::StructuralPartialEq for TargetType {}
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::cmp::PartialEq for TargetType {
            #[inline]
            fn eq(&self, other: &TargetType) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
                    && match (self, other) {
                        (TargetType::Query(__self_0), TargetType::Query(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (
                            TargetType::Documents(__self_0),
                            TargetType::Documents(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        impl TargetType {
            /// Encodes the message to a buffer.
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    TargetType::Query(ref value) => {
                        ::prost::encoding::message::encode(2u32, &*value, buf);
                    }
                    TargetType::Documents(ref value) => {
                        ::prost::encoding::message::encode(3u32, &*value, buf);
                    }
                }
            }
            /// Decodes an instance of the message from a buffer, and merges it into self.
            pub fn merge<B>(
                field: &mut ::core::option::Option<TargetType>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag {
                    2u32 => {
                        match field {
                            ::core::option::Option::Some(
                                TargetType::Query(ref mut value),
                            ) => {
                                ::prost::encoding::message::merge(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            TargetType::Query(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    3u32 => {
                        match field {
                            ::core::option::Option::Some(
                                TargetType::Documents(ref mut value),
                            ) => {
                                ::prost::encoding::message::merge(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            TargetType::Documents(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    _ => {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "internal error: entered unreachable code: {0}",
                                format_args!("invalid TargetType tag: {0}", tag),
                            ),
                        );
                    }
                }
            }
            /// Returns the encoded length of the message without a length delimiter.
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    TargetType::Query(ref value) => {
                        ::prost::encoding::message::encoded_len(2u32, &*value)
                    }
                    TargetType::Documents(ref value) => {
                        ::prost::encoding::message::encoded_len(3u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for TargetType {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    TargetType::Query(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("Query").field(&wrapper).finish()
                    }
                    TargetType::Documents(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("Documents").field(&wrapper).finish()
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for TargetType {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 2",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "query" => _serde::__private::Ok(__Field::__field0),
                                "documents" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"query" => _serde::__private::Ok(__Field::__field0),
                                b"documents" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<TargetType>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = TargetType;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum TargetType",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            QueryTarget,
                                        >(__variant),
                                        TargetType::Query,
                                    )
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            DocumentsTarget,
                                        >(__variant),
                                        TargetType::Documents,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &["query", "documents"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "TargetType",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<TargetType>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for TargetType {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        TargetType::Query(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "TargetType",
                                0u32,
                                "query",
                                __field0,
                            )
                        }
                        TargetType::Documents(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "TargetType",
                                1u32,
                                "documents",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
        /// When to start listening.
        ///
        /// If specified, only the matching Documents that have been updated AFTER the
        /// `resume_token` or `read_time` will be returned. Otherwise, all matching
        /// Documents are returned before any subsequent changes.
        #[serde(rename_all = "camelCase")]
        #[allow(clippy::derive_partial_eq_without_eq)]
        pub enum ResumeType {
            /// A resume token from a prior
            /// [TargetChange][google.firestore.v1.TargetChange] for an identical target.
            ///
            /// Using a resume token with a different target is unsupported and may fail.
            #[prost(bytes, tag = "4")]
            ResumeToken(::prost::alloc::vec::Vec<u8>),
            /// Start listening after a specific `read_time`.
            ///
            /// The client must know the state of matching documents at this time.
            #[prost(message, tag = "11")]
            ReadTime(super::super::super::protobuf::Timestamp),
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::clone::Clone for ResumeType {
            #[inline]
            fn clone(&self) -> ResumeType {
                match self {
                    ResumeType::ResumeToken(__self_0) => {
                        ResumeType::ResumeToken(::core::clone::Clone::clone(__self_0))
                    }
                    ResumeType::ReadTime(__self_0) => {
                        ResumeType::ReadTime(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::marker::StructuralPartialEq for ResumeType {}
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::cmp::PartialEq for ResumeType {
            #[inline]
            fn eq(&self, other: &ResumeType) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
                    && match (self, other) {
                        (
                            ResumeType::ResumeToken(__self_0),
                            ResumeType::ResumeToken(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            ResumeType::ReadTime(__self_0),
                            ResumeType::ReadTime(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        impl ResumeType {
            /// Encodes the message to a buffer.
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    ResumeType::ResumeToken(ref value) => {
                        ::prost::encoding::bytes::encode(4u32, &*value, buf);
                    }
                    ResumeType::ReadTime(ref value) => {
                        ::prost::encoding::message::encode(11u32, &*value, buf);
                    }
                }
            }
            /// Decodes an instance of the message from a buffer, and merges it into self.
            pub fn merge<B>(
                field: &mut ::core::option::Option<ResumeType>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag {
                    4u32 => {
                        match field {
                            ::core::option::Option::Some(
                                ResumeType::ResumeToken(ref mut value),
                            ) => {
                                ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            ResumeType::ResumeToken(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    11u32 => {
                        match field {
                            ::core::option::Option::Some(
                                ResumeType::ReadTime(ref mut value),
                            ) => {
                                ::prost::encoding::message::merge(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            ResumeType::ReadTime(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    _ => {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "internal error: entered unreachable code: {0}",
                                format_args!("invalid ResumeType tag: {0}", tag),
                            ),
                        );
                    }
                }
            }
            /// Returns the encoded length of the message without a length delimiter.
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    ResumeType::ResumeToken(ref value) => {
                        ::prost::encoding::bytes::encoded_len(4u32, &*value)
                    }
                    ResumeType::ReadTime(ref value) => {
                        ::prost::encoding::message::encoded_len(11u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for ResumeType {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ResumeType::ResumeToken(ref value) => {
                        let wrapper = {
                            #[allow(non_snake_case)]
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("ResumeToken").field(&wrapper).finish()
                    }
                    ResumeType::ReadTime(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ReadTime").field(&wrapper).finish()
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ResumeType {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 2",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "resumeToken" => _serde::__private::Ok(__Field::__field0),
                                "readTime" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"resumeToken" => _serde::__private::Ok(__Field::__field0),
                                b"readTime" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ResumeType>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ResumeType;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum ResumeType",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            ::prost::alloc::vec::Vec<u8>,
                                        >(__variant),
                                        ResumeType::ResumeToken,
                                    )
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            super::super::super::protobuf::Timestamp,
                                        >(__variant),
                                        ResumeType::ReadTime,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "resumeToken",
                        "readTime",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "ResumeType",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ResumeType>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ResumeType {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        ResumeType::ResumeToken(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "ResumeType",
                                0u32,
                                "resumeToken",
                                __field0,
                            )
                        }
                        ResumeType::ReadTime(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "ResumeType",
                                1u32,
                                "readTime",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
    }
    /// Targets being watched have changed.
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct TargetChange {
        /// The type of change that occurred.
        #[prost(enumeration = "target_change::TargetChangeType", tag = "1")]
        pub target_change_type: i32,
        /// The target IDs of targets that have changed.
        ///
        /// If empty, the change applies to all targets.
        ///
        /// The order of the target IDs is not defined.
        #[prost(int32, repeated, tag = "2")]
        pub target_ids: ::prost::alloc::vec::Vec<i32>,
        /// The error that resulted in this change, if applicable.
        #[prost(message, optional, tag = "3")]
        pub cause: ::core::option::Option<super::super::rpc::Status>,
        /// A token that can be used to resume the stream for the given `target_ids`,
        /// or all targets if `target_ids` is empty.
        ///
        /// Not set on every target change.
        #[prost(bytes = "vec", tag = "4")]
        pub resume_token: ::prost::alloc::vec::Vec<u8>,
        /// The consistent `read_time` for the given `target_ids` (omitted when the
        /// target_ids are not at a consistent snapshot).
        ///
        /// The stream is guaranteed to send a `read_time` with `target_ids` empty
        /// whenever the entire stream reaches a new consistent snapshot. ADD,
        /// CURRENT, and RESET messages are guaranteed to (eventually) result in a
        /// new consistent snapshot (while NO_CHANGE and REMOVE messages are not).
        ///
        /// For a given stream, `read_time` is guaranteed to be monotonically
        /// increasing.
        #[prost(message, optional, tag = "6")]
        pub read_time: ::core::option::Option<super::super::protobuf::Timestamp>,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for TargetChange {
        #[inline]
        fn clone(&self) -> TargetChange {
            TargetChange {
                target_change_type: ::core::clone::Clone::clone(
                    &self.target_change_type,
                ),
                target_ids: ::core::clone::Clone::clone(&self.target_ids),
                cause: ::core::clone::Clone::clone(&self.cause),
                resume_token: ::core::clone::Clone::clone(&self.resume_token),
                read_time: ::core::clone::Clone::clone(&self.read_time),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for TargetChange {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for TargetChange {
        #[inline]
        fn eq(&self, other: &TargetChange) -> bool {
            self.target_change_type == other.target_change_type
                && self.target_ids == other.target_ids && self.cause == other.cause
                && self.resume_token == other.resume_token
                && self.read_time == other.read_time
        }
    }
    impl ::prost::Message for TargetChange {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.target_change_type
                != target_change::TargetChangeType::default() as i32
            {
                ::prost::encoding::int32::encode(1u32, &self.target_change_type, buf);
            }
            ::prost::encoding::int32::encode_packed(2u32, &self.target_ids, buf);
            if let Some(ref msg) = self.cause {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
            if self.resume_token != b"" as &[u8] {
                ::prost::encoding::bytes::encode(4u32, &self.resume_token, buf);
            }
            if let Some(ref msg) = self.read_time {
                ::prost::encoding::message::encode(6u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TargetChange";
            match tag {
                1u32 => {
                    let mut value = &mut self.target_change_type;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "target_change_type");
                            error
                        })
                }
                2u32 => {
                    let mut value = &mut self.target_ids;
                    ::prost::encoding::int32::merge_repeated(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "target_ids");
                            error
                        })
                }
                3u32 => {
                    let mut value = &mut self.cause;
                    ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "cause");
                            error
                        })
                }
                4u32 => {
                    let mut value = &mut self.resume_token;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "resume_token");
                            error
                        })
                }
                6u32 => {
                    let mut value = &mut self.read_time;
                    ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "read_time");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0
                + if self.target_change_type
                    != target_change::TargetChangeType::default() as i32
                {
                    ::prost::encoding::int32::encoded_len(1u32, &self.target_change_type)
                } else {
                    0
                } + ::prost::encoding::int32::encoded_len_packed(2u32, &self.target_ids)
                + self
                    .cause
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(3u32, msg))
                + if self.resume_token != b"" as &[u8] {
                    ::prost::encoding::bytes::encoded_len(4u32, &self.resume_token)
                } else {
                    0
                }
                + self
                    .read_time
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(6u32, msg))
        }
        fn clear(&mut self) {
            self.target_change_type = target_change::TargetChangeType::default() as i32;
            self.target_ids.clear();
            self.cause = ::core::option::Option::None;
            self.resume_token.clear();
            self.read_time = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for TargetChange {
        fn default() -> Self {
            TargetChange {
                target_change_type: target_change::TargetChangeType::default() as i32,
                target_ids: ::prost::alloc::vec::Vec::new(),
                cause: ::core::default::Default::default(),
                resume_token: ::core::default::Default::default(),
                read_time: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for TargetChange {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TargetChange");
            let builder = {
                let wrapper = {
                    struct ScalarWrapper<'a>(&'a i32);
                    impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                        fn fmt(
                            &self,
                            f: &mut ::core::fmt::Formatter,
                        ) -> ::core::fmt::Result {
                            let res: ::core::result::Result<
                                target_change::TargetChangeType,
                                _,
                            > = ::core::convert::TryFrom::try_from(*self.0);
                            match res {
                                Err(_) => ::core::fmt::Debug::fmt(&self.0, f),
                                Ok(en) => ::core::fmt::Debug::fmt(&en, f),
                            }
                        }
                    }
                    ScalarWrapper(&self.target_change_type)
                };
                builder.field("target_change_type", &wrapper)
            };
            let builder = {
                let wrapper = {
                    struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<i32>);
                    impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                        fn fmt(
                            &self,
                            f: &mut ::core::fmt::Formatter,
                        ) -> ::core::fmt::Result {
                            let mut vec_builder = f.debug_list();
                            for v in self.0 {
                                #[allow(non_snake_case)]
                                fn Inner<T>(v: T) -> T {
                                    v
                                }
                                vec_builder.entry(&Inner(v));
                            }
                            vec_builder.finish()
                        }
                    }
                    ScalarWrapper(&self.target_ids)
                };
                builder.field("target_ids", &wrapper)
            };
            let builder = {
                let wrapper = &self.cause;
                builder.field("cause", &wrapper)
            };
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.resume_token)
                };
                builder.field("resume_token", &wrapper)
            };
            let builder = {
                let wrapper = &self.read_time;
                builder.field("read_time", &wrapper)
            };
            builder.finish()
        }
    }
    #[allow(dead_code)]
    impl TargetChange {
        ///Returns the enum value of `target_change_type`, or the default if the field is set to an invalid enum value.
        pub fn target_change_type(&self) -> target_change::TargetChangeType {
            ::core::convert::TryFrom::try_from(self.target_change_type)
                .unwrap_or(target_change::TargetChangeType::default())
        }
        ///Sets `target_change_type` to the provided enum value.
        pub fn set_target_change_type(
            &mut self,
            value: target_change::TargetChangeType,
        ) {
            self.target_change_type = value as i32;
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TargetChange {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "targetChangeType" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            "targetIds" => _serde::__private::Ok(__Field::__field1),
                            "cause" => _serde::__private::Ok(__Field::__field2),
                            "resumeToken" => _serde::__private::Ok(__Field::__field3),
                            "readTime" => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"targetChangeType" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            b"targetIds" => _serde::__private::Ok(__Field::__field1),
                            b"cause" => _serde::__private::Ok(__Field::__field2),
                            b"resumeToken" => _serde::__private::Ok(__Field::__field3),
                            b"readTime" => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TargetChange>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TargetChange;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct TargetChange",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            i32,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct TargetChange with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::vec::Vec<i32>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct TargetChange with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<super::super::rpc::Status>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct TargetChange with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::vec::Vec<u8>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct TargetChange with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<super::super::protobuf::Timestamp>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct TargetChange with 5 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(TargetChange {
                            target_change_type: __field0,
                            target_ids: __field1,
                            cause: __field2,
                            resume_token: __field3,
                            read_time: __field4,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<i32> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            ::prost::alloc::vec::Vec<i32>,
                        > = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            ::core::option::Option<super::super::rpc::Status>,
                        > = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<
                            ::prost::alloc::vec::Vec<u8>,
                        > = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<
                            ::core::option::Option<super::super::protobuf::Timestamp>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "targetChangeType",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i32>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "targetIds",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::vec::Vec<i32>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("cause"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<super::super::rpc::Status>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "resumeToken",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::vec::Vec<u8>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "readTime",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<super::super::protobuf::Timestamp>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("targetChangeType")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("targetIds")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("cause")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("resumeToken")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("readTime")?
                            }
                        };
                        _serde::__private::Ok(TargetChange {
                            target_change_type: __field0,
                            target_ids: __field1,
                            cause: __field2,
                            resume_token: __field3,
                            read_time: __field4,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "targetChangeType",
                    "targetIds",
                    "cause",
                    "resumeToken",
                    "readTime",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TargetChange",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TargetChange>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TargetChange {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "TargetChange",
                    false as usize + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "targetChangeType",
                    &self.target_change_type,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "targetIds",
                    &self.target_ids,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "cause",
                    &self.cause,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "resumeToken",
                    &self.resume_token,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "readTime",
                    &self.read_time,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// Nested message and enum types in `TargetChange`.
    pub mod target_change {
        /// The type of change.
        #[serde(rename_all = "camelCase")]
        #[repr(i32)]
        pub enum TargetChangeType {
            /// No change has occurred. Used only to send an updated `resume_token`.
            NoChange = 0,
            /// The targets have been added.
            Add = 1,
            /// The targets have been removed.
            Remove = 2,
            /// The targets reflect all changes committed before the targets were added
            /// to the stream.
            ///
            /// This will be sent after or with a `read_time` that is greater than or
            /// equal to the time at which the targets were added.
            ///
            /// Listeners can wait for this change if read-after-write semantics
            /// are desired.
            Current = 3,
            /// The targets have been reset, and a new initial state for the targets
            /// will be returned in subsequent changes.
            ///
            /// After the initial state is complete, `CURRENT` will be returned even
            /// if the target was previously indicated to be `CURRENT`.
            Reset = 4,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for TargetChangeType {
            #[inline]
            fn clone(&self) -> TargetChangeType {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for TargetChangeType {}
        #[automatically_derived]
        impl ::core::fmt::Debug for TargetChangeType {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        TargetChangeType::NoChange => "NoChange",
                        TargetChangeType::Add => "Add",
                        TargetChangeType::Remove => "Remove",
                        TargetChangeType::Current => "Current",
                        TargetChangeType::Reset => "Reset",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for TargetChangeType {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for TargetChangeType {
            #[inline]
            fn eq(&self, other: &TargetChangeType) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for TargetChangeType {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for TargetChangeType {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_tag, state)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for TargetChangeType {
            #[inline]
            fn partial_cmp(
                &self,
                other: &TargetChangeType,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for TargetChangeType {
            #[inline]
            fn cmp(&self, other: &TargetChangeType) -> ::core::cmp::Ordering {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag)
            }
        }
        impl TargetChangeType {
            ///Returns `true` if `value` is a variant of `TargetChangeType`.
            pub fn is_valid(value: i32) -> bool {
                match value {
                    0 => true,
                    1 => true,
                    2 => true,
                    3 => true,
                    4 => true,
                    _ => false,
                }
            }
            #[deprecated = "Use the TryFrom<i32> implementation instead"]
            ///Converts an `i32` to a `TargetChangeType`, or `None` if `value` is not a valid variant.
            pub fn from_i32(value: i32) -> ::core::option::Option<TargetChangeType> {
                match value {
                    0 => ::core::option::Option::Some(TargetChangeType::NoChange),
                    1 => ::core::option::Option::Some(TargetChangeType::Add),
                    2 => ::core::option::Option::Some(TargetChangeType::Remove),
                    3 => ::core::option::Option::Some(TargetChangeType::Current),
                    4 => ::core::option::Option::Some(TargetChangeType::Reset),
                    _ => ::core::option::Option::None,
                }
            }
        }
        impl ::core::default::Default for TargetChangeType {
            fn default() -> TargetChangeType {
                TargetChangeType::NoChange
            }
        }
        impl ::core::convert::From<TargetChangeType> for i32 {
            fn from(value: TargetChangeType) -> i32 {
                value as i32
            }
        }
        impl ::core::convert::TryFrom<i32> for TargetChangeType {
            type Error = ::prost::DecodeError;
            fn try_from(
                value: i32,
            ) -> ::core::result::Result<TargetChangeType, ::prost::DecodeError> {
                match value {
                    0 => ::core::result::Result::Ok(TargetChangeType::NoChange),
                    1 => ::core::result::Result::Ok(TargetChangeType::Add),
                    2 => ::core::result::Result::Ok(TargetChangeType::Remove),
                    3 => ::core::result::Result::Ok(TargetChangeType::Current),
                    4 => ::core::result::Result::Ok(TargetChangeType::Reset),
                    _ => {
                        ::core::result::Result::Err(
                            ::prost::DecodeError::new("invalid enumeration value"),
                        )
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for TargetChangeType {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 5",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "noChange" => _serde::__private::Ok(__Field::__field0),
                                "add" => _serde::__private::Ok(__Field::__field1),
                                "remove" => _serde::__private::Ok(__Field::__field2),
                                "current" => _serde::__private::Ok(__Field::__field3),
                                "reset" => _serde::__private::Ok(__Field::__field4),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"noChange" => _serde::__private::Ok(__Field::__field0),
                                b"add" => _serde::__private::Ok(__Field::__field1),
                                b"remove" => _serde::__private::Ok(__Field::__field2),
                                b"current" => _serde::__private::Ok(__Field::__field3),
                                b"reset" => _serde::__private::Ok(__Field::__field4),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<TargetChangeType>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = TargetChangeType;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum TargetChangeType",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(TargetChangeType::NoChange)
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(TargetChangeType::Add)
                                }
                                (__Field::__field2, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(TargetChangeType::Remove)
                                }
                                (__Field::__field3, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(TargetChangeType::Current)
                                }
                                (__Field::__field4, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(TargetChangeType::Reset)
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "noChange",
                        "add",
                        "remove",
                        "current",
                        "reset",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "TargetChangeType",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<TargetChangeType>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for TargetChangeType {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        TargetChangeType::NoChange => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "TargetChangeType",
                                0u32,
                                "noChange",
                            )
                        }
                        TargetChangeType::Add => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "TargetChangeType",
                                1u32,
                                "add",
                            )
                        }
                        TargetChangeType::Remove => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "TargetChangeType",
                                2u32,
                                "remove",
                            )
                        }
                        TargetChangeType::Current => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "TargetChangeType",
                                3u32,
                                "current",
                            )
                        }
                        TargetChangeType::Reset => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "TargetChangeType",
                                4u32,
                                "reset",
                            )
                        }
                    }
                }
            }
        };
        impl TargetChangeType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    TargetChangeType::NoChange => "NO_CHANGE",
                    TargetChangeType::Add => "ADD",
                    TargetChangeType::Remove => "REMOVE",
                    TargetChangeType::Current => "CURRENT",
                    TargetChangeType::Reset => "RESET",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "NO_CHANGE" => Some(Self::NoChange),
                    "ADD" => Some(Self::Add),
                    "REMOVE" => Some(Self::Remove),
                    "CURRENT" => Some(Self::Current),
                    "RESET" => Some(Self::Reset),
                    _ => None,
                }
            }
        }
    }
    /// The request for
    /// [Firestore.ListCollectionIds][google.firestore.v1.Firestore.ListCollectionIds].
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct ListCollectionIdsRequest {
        /// Required. The parent document. In the format:
        /// `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
        /// For example:
        /// `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`
        #[prost(string, tag = "1")]
        pub parent: ::prost::alloc::string::String,
        /// The maximum number of results to return.
        #[prost(int32, tag = "2")]
        pub page_size: i32,
        /// A page token. Must be a value from
        /// [ListCollectionIdsResponse][google.firestore.v1.ListCollectionIdsResponse].
        #[prost(string, tag = "3")]
        pub page_token: ::prost::alloc::string::String,
        /// The consistency mode for this request.
        /// If not set, defaults to strong consistency.
        #[prost(oneof = "list_collection_ids_request::ConsistencySelector", tags = "4")]
        pub consistency_selector: ::core::option::Option<
            list_collection_ids_request::ConsistencySelector,
        >,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for ListCollectionIdsRequest {
        #[inline]
        fn clone(&self) -> ListCollectionIdsRequest {
            ListCollectionIdsRequest {
                parent: ::core::clone::Clone::clone(&self.parent),
                page_size: ::core::clone::Clone::clone(&self.page_size),
                page_token: ::core::clone::Clone::clone(&self.page_token),
                consistency_selector: ::core::clone::Clone::clone(
                    &self.consistency_selector,
                ),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for ListCollectionIdsRequest {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for ListCollectionIdsRequest {
        #[inline]
        fn eq(&self, other: &ListCollectionIdsRequest) -> bool {
            self.parent == other.parent && self.page_size == other.page_size
                && self.page_token == other.page_token
                && self.consistency_selector == other.consistency_selector
        }
    }
    impl ::prost::Message for ListCollectionIdsRequest {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.parent != "" {
                ::prost::encoding::string::encode(1u32, &self.parent, buf);
            }
            if self.page_size != 0i32 {
                ::prost::encoding::int32::encode(2u32, &self.page_size, buf);
            }
            if self.page_token != "" {
                ::prost::encoding::string::encode(3u32, &self.page_token, buf);
            }
            if let Some(ref oneof) = self.consistency_selector {
                oneof.encode(buf)
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ListCollectionIdsRequest";
            match tag {
                1u32 => {
                    let mut value = &mut self.parent;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "parent");
                            error
                        })
                }
                2u32 => {
                    let mut value = &mut self.page_size;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "page_size");
                            error
                        })
                }
                3u32 => {
                    let mut value = &mut self.page_token;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "page_token");
                            error
                        })
                }
                4u32 => {
                    let mut value = &mut self.consistency_selector;
                    list_collection_ids_request::ConsistencySelector::merge(
                            value,
                            tag,
                            wire_type,
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "consistency_selector");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0
                + if self.parent != "" {
                    ::prost::encoding::string::encoded_len(1u32, &self.parent)
                } else {
                    0
                }
                + if self.page_size != 0i32 {
                    ::prost::encoding::int32::encoded_len(2u32, &self.page_size)
                } else {
                    0
                }
                + if self.page_token != "" {
                    ::prost::encoding::string::encoded_len(3u32, &self.page_token)
                } else {
                    0
                }
                + self
                    .consistency_selector
                    .as_ref()
                    .map_or(
                        0,
                        list_collection_ids_request::ConsistencySelector::encoded_len,
                    )
        }
        fn clear(&mut self) {
            self.parent.clear();
            self.page_size = 0i32;
            self.page_token.clear();
            self.consistency_selector = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for ListCollectionIdsRequest {
        fn default() -> Self {
            ListCollectionIdsRequest {
                parent: ::prost::alloc::string::String::new(),
                page_size: 0i32,
                page_token: ::prost::alloc::string::String::new(),
                consistency_selector: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for ListCollectionIdsRequest {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ListCollectionIdsRequest");
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.parent)
                };
                builder.field("parent", &wrapper)
            };
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.page_size)
                };
                builder.field("page_size", &wrapper)
            };
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.page_token)
                };
                builder.field("page_token", &wrapper)
            };
            let builder = {
                let wrapper = &self.consistency_selector;
                builder.field("consistency_selector", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ListCollectionIdsRequest {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "parent" => _serde::__private::Ok(__Field::__field0),
                            "pageSize" => _serde::__private::Ok(__Field::__field1),
                            "pageToken" => _serde::__private::Ok(__Field::__field2),
                            "consistencySelector" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"parent" => _serde::__private::Ok(__Field::__field0),
                            b"pageSize" => _serde::__private::Ok(__Field::__field1),
                            b"pageToken" => _serde::__private::Ok(__Field::__field2),
                            b"consistencySelector" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ListCollectionIdsRequest>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ListCollectionIdsRequest;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ListCollectionIdsRequest",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::string::String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ListCollectionIdsRequest with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            i32,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct ListCollectionIdsRequest with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::string::String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct ListCollectionIdsRequest with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            ::core::option::Option<
                                list_collection_ids_request::ConsistencySelector,
                            >,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct ListCollectionIdsRequest with 4 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ListCollectionIdsRequest {
                            parent: __field0,
                            page_size: __field1,
                            page_token: __field2,
                            consistency_selector: __field3,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::prost::alloc::string::String,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<i32> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            ::prost::alloc::string::String,
                        > = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<
                            ::core::option::Option<
                                list_collection_ids_request::ConsistencySelector,
                            >,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("parent"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::string::String,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "pageSize",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i32>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "pageToken",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::string::String,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "consistencySelector",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::core::option::Option<
                                                list_collection_ids_request::ConsistencySelector,
                                            >,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("parent")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("pageSize")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("pageToken")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("consistencySelector")?
                            }
                        };
                        _serde::__private::Ok(ListCollectionIdsRequest {
                            parent: __field0,
                            page_size: __field1,
                            page_token: __field2,
                            consistency_selector: __field3,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "parent",
                    "pageSize",
                    "pageToken",
                    "consistencySelector",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ListCollectionIdsRequest",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            ListCollectionIdsRequest,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ListCollectionIdsRequest {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ListCollectionIdsRequest",
                    false as usize + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "parent",
                    &self.parent,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "pageSize",
                    &self.page_size,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "pageToken",
                    &self.page_token,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "consistencySelector",
                    &self.consistency_selector,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// Nested message and enum types in `ListCollectionIdsRequest`.
    pub mod list_collection_ids_request {
        /// The consistency mode for this request.
        /// If not set, defaults to strong consistency.
        #[serde(rename_all = "camelCase")]
        #[allow(clippy::derive_partial_eq_without_eq)]
        pub enum ConsistencySelector {
            /// Reads documents as they were at the given time.
            ///
            /// This must be a microsecond precision timestamp within the past one hour,
            /// or if Point-in-Time Recovery is enabled, can additionally be a whole
            /// minute timestamp within the past 7 days.
            #[prost(message, tag = "4")]
            ReadTime(super::super::super::protobuf::Timestamp),
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::clone::Clone for ConsistencySelector {
            #[inline]
            fn clone(&self) -> ConsistencySelector {
                match self {
                    ConsistencySelector::ReadTime(__self_0) => {
                        ConsistencySelector::ReadTime(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::marker::StructuralPartialEq for ConsistencySelector {}
        #[automatically_derived]
        #[allow(clippy::derive_partial_eq_without_eq)]
        impl ::core::cmp::PartialEq for ConsistencySelector {
            #[inline]
            fn eq(&self, other: &ConsistencySelector) -> bool {
                match (self, other) {
                    (
                        ConsistencySelector::ReadTime(__self_0),
                        ConsistencySelector::ReadTime(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                }
            }
        }
        impl ConsistencySelector {
            /// Encodes the message to a buffer.
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    ConsistencySelector::ReadTime(ref value) => {
                        ::prost::encoding::message::encode(4u32, &*value, buf);
                    }
                }
            }
            /// Decodes an instance of the message from a buffer, and merges it into self.
            pub fn merge<B>(
                field: &mut ::core::option::Option<ConsistencySelector>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag {
                    4u32 => {
                        match field {
                            ::core::option::Option::Some(
                                ConsistencySelector::ReadTime(ref mut value),
                            ) => {
                                ::prost::encoding::message::merge(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                            }
                            _ => {
                                let mut owned_value = ::core::default::Default::default();
                                let value = &mut owned_value;
                                ::prost::encoding::message::merge(
                                        wire_type,
                                        value,
                                        buf,
                                        ctx,
                                    )
                                    .map(|_| {
                                        *field = ::core::option::Option::Some(
                                            ConsistencySelector::ReadTime(owned_value),
                                        );
                                    })
                            }
                        }
                    }
                    _ => {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "internal error: entered unreachable code: {0}",
                                format_args!("invalid ConsistencySelector tag: {0}", tag),
                            ),
                        );
                    }
                }
            }
            /// Returns the encoded length of the message without a length delimiter.
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    ConsistencySelector::ReadTime(ref value) => {
                        ::prost::encoding::message::encoded_len(4u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for ConsistencySelector {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ConsistencySelector::ReadTime(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ReadTime").field(&wrapper).finish()
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ConsistencySelector {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 1",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "readTime" => _serde::__private::Ok(__Field::__field0),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"readTime" => _serde::__private::Ok(__Field::__field0),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ConsistencySelector>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ConsistencySelector;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum ConsistencySelector",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            super::super::super::protobuf::Timestamp,
                                        >(__variant),
                                        ConsistencySelector::ReadTime,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &["readTime"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "ConsistencySelector",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                ConsistencySelector,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ConsistencySelector {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        ConsistencySelector::ReadTime(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "ConsistencySelector",
                                0u32,
                                "readTime",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
    }
    /// The response from
    /// [Firestore.ListCollectionIds][google.firestore.v1.Firestore.ListCollectionIds].
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct ListCollectionIdsResponse {
        /// The collection ids.
        #[prost(string, repeated, tag = "1")]
        pub collection_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// A page token that may be used to continue the list.
        #[prost(string, tag = "2")]
        pub next_page_token: ::prost::alloc::string::String,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for ListCollectionIdsResponse {
        #[inline]
        fn clone(&self) -> ListCollectionIdsResponse {
            ListCollectionIdsResponse {
                collection_ids: ::core::clone::Clone::clone(&self.collection_ids),
                next_page_token: ::core::clone::Clone::clone(&self.next_page_token),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for ListCollectionIdsResponse {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for ListCollectionIdsResponse {
        #[inline]
        fn eq(&self, other: &ListCollectionIdsResponse) -> bool {
            self.collection_ids == other.collection_ids
                && self.next_page_token == other.next_page_token
        }
    }
    impl ::prost::Message for ListCollectionIdsResponse {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            ::prost::encoding::string::encode_repeated(1u32, &self.collection_ids, buf);
            if self.next_page_token != "" {
                ::prost::encoding::string::encode(2u32, &self.next_page_token, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ListCollectionIdsResponse";
            match tag {
                1u32 => {
                    let mut value = &mut self.collection_ids;
                    ::prost::encoding::string::merge_repeated(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "collection_ids");
                            error
                        })
                }
                2u32 => {
                    let mut value = &mut self.next_page_token;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "next_page_token");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0
                + ::prost::encoding::string::encoded_len_repeated(
                    1u32,
                    &self.collection_ids,
                )
                + if self.next_page_token != "" {
                    ::prost::encoding::string::encoded_len(2u32, &self.next_page_token)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.collection_ids.clear();
            self.next_page_token.clear();
        }
    }
    impl ::core::default::Default for ListCollectionIdsResponse {
        fn default() -> Self {
            ListCollectionIdsResponse {
                collection_ids: ::prost::alloc::vec::Vec::new(),
                next_page_token: ::prost::alloc::string::String::new(),
            }
        }
    }
    impl ::core::fmt::Debug for ListCollectionIdsResponse {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ListCollectionIdsResponse");
            let builder = {
                let wrapper = {
                    struct ScalarWrapper<'a>(
                        &'a ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                    );
                    impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                        fn fmt(
                            &self,
                            f: &mut ::core::fmt::Formatter,
                        ) -> ::core::fmt::Result {
                            let mut vec_builder = f.debug_list();
                            for v in self.0 {
                                #[allow(non_snake_case)]
                                fn Inner<T>(v: T) -> T {
                                    v
                                }
                                vec_builder.entry(&Inner(v));
                            }
                            vec_builder.finish()
                        }
                    }
                    ScalarWrapper(&self.collection_ids)
                };
                builder.field("collection_ids", &wrapper)
            };
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.next_page_token)
                };
                builder.field("next_page_token", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ListCollectionIdsResponse {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "collectionIds" => _serde::__private::Ok(__Field::__field0),
                            "nextPageToken" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"collectionIds" => _serde::__private::Ok(__Field::__field0),
                            b"nextPageToken" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ListCollectionIdsResponse>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ListCollectionIdsResponse;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ListCollectionIdsResponse",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ListCollectionIdsResponse with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::string::String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct ListCollectionIdsResponse with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ListCollectionIdsResponse {
                            collection_ids: __field0,
                            next_page_token: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            ::prost::alloc::string::String,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "collectionIds",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "nextPageToken",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::string::String,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("collectionIds")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("nextPageToken")?
                            }
                        };
                        _serde::__private::Ok(ListCollectionIdsResponse {
                            collection_ids: __field0,
                            next_page_token: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "collectionIds",
                    "nextPageToken",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ListCollectionIdsResponse",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            ListCollectionIdsResponse,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ListCollectionIdsResponse {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ListCollectionIdsResponse",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "collectionIds",
                    &self.collection_ids,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "nextPageToken",
                    &self.next_page_token,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// The request for
    /// [Firestore.BatchWrite][google.firestore.v1.Firestore.BatchWrite].
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct BatchWriteRequest {
        /// Required. The database name. In the format:
        /// `projects/{project_id}/databases/{database_id}`.
        #[prost(string, tag = "1")]
        pub database: ::prost::alloc::string::String,
        /// The writes to apply.
        ///
        /// Method does not apply writes atomically and does not guarantee ordering.
        /// Each write succeeds or fails independently. You cannot write to the same
        /// document more than once per request.
        #[prost(message, repeated, tag = "2")]
        pub writes: ::prost::alloc::vec::Vec<Write>,
        /// Labels associated with this batch write.
        #[prost(map = "string, string", tag = "3")]
        pub labels: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            ::prost::alloc::string::String,
        >,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for BatchWriteRequest {
        #[inline]
        fn clone(&self) -> BatchWriteRequest {
            BatchWriteRequest {
                database: ::core::clone::Clone::clone(&self.database),
                writes: ::core::clone::Clone::clone(&self.writes),
                labels: ::core::clone::Clone::clone(&self.labels),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for BatchWriteRequest {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for BatchWriteRequest {
        #[inline]
        fn eq(&self, other: &BatchWriteRequest) -> bool {
            self.database == other.database && self.writes == other.writes
                && self.labels == other.labels
        }
    }
    impl ::prost::Message for BatchWriteRequest {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.database != "" {
                ::prost::encoding::string::encode(1u32, &self.database, buf);
            }
            for msg in &self.writes {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            ::prost::encoding::hash_map::encode(
                ::prost::encoding::string::encode,
                ::prost::encoding::string::encoded_len,
                ::prost::encoding::string::encode,
                ::prost::encoding::string::encoded_len,
                3u32,
                &self.labels,
                buf,
            );
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "BatchWriteRequest";
            match tag {
                1u32 => {
                    let mut value = &mut self.database;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "database");
                            error
                        })
                }
                2u32 => {
                    let mut value = &mut self.writes;
                    ::prost::encoding::message::merge_repeated(
                            wire_type,
                            value,
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "writes");
                            error
                        })
                }
                3u32 => {
                    let mut value = &mut self.labels;
                    ::prost::encoding::hash_map::merge(
                            ::prost::encoding::string::merge,
                            ::prost::encoding::string::merge,
                            &mut value,
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "labels");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0
                + if self.database != "" {
                    ::prost::encoding::string::encoded_len(1u32, &self.database)
                } else {
                    0
                } + ::prost::encoding::message::encoded_len_repeated(2u32, &self.writes)
                + ::prost::encoding::hash_map::encoded_len(
                    ::prost::encoding::string::encoded_len,
                    ::prost::encoding::string::encoded_len,
                    3u32,
                    &self.labels,
                )
        }
        fn clear(&mut self) {
            self.database.clear();
            self.writes.clear();
            self.labels.clear();
        }
    }
    impl ::core::default::Default for BatchWriteRequest {
        fn default() -> Self {
            BatchWriteRequest {
                database: ::prost::alloc::string::String::new(),
                writes: ::core::default::Default::default(),
                labels: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for BatchWriteRequest {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("BatchWriteRequest");
            let builder = {
                let wrapper = {
                    #[allow(non_snake_case)]
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.database)
                };
                builder.field("database", &wrapper)
            };
            let builder = {
                let wrapper = &self.writes;
                builder.field("writes", &wrapper)
            };
            let builder = {
                let wrapper = {
                    struct MapWrapper<'a>(
                        &'a ::std::collections::HashMap<
                            ::prost::alloc::string::String,
                            ::prost::alloc::string::String,
                        >,
                    );
                    impl<'a> ::core::fmt::Debug for MapWrapper<'a> {
                        fn fmt(
                            &self,
                            f: &mut ::core::fmt::Formatter,
                        ) -> ::core::fmt::Result {
                            #[allow(non_snake_case)]
                            fn KeyWrapper<T>(v: T) -> T {
                                v
                            }
                            #[allow(non_snake_case)]
                            fn ValueWrapper<T>(v: T) -> T {
                                v
                            }
                            let mut builder = f.debug_map();
                            for (k, v) in self.0 {
                                builder.entry(&KeyWrapper(k), &ValueWrapper(v));
                            }
                            builder.finish()
                        }
                    }
                    MapWrapper(&self.labels)
                };
                builder.field("labels", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for BatchWriteRequest {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "database" => _serde::__private::Ok(__Field::__field0),
                            "writes" => _serde::__private::Ok(__Field::__field1),
                            "labels" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"database" => _serde::__private::Ok(__Field::__field0),
                            b"writes" => _serde::__private::Ok(__Field::__field1),
                            b"labels" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<BatchWriteRequest>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = BatchWriteRequest;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct BatchWriteRequest",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::string::String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct BatchWriteRequest with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::vec::Vec<Write>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct BatchWriteRequest with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            ::std::collections::HashMap<
                                ::prost::alloc::string::String,
                                ::prost::alloc::string::String,
                            >,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct BatchWriteRequest with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(BatchWriteRequest {
                            database: __field0,
                            writes: __field1,
                            labels: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::prost::alloc::string::String,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            ::prost::alloc::vec::Vec<Write>,
                        > = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            ::std::collections::HashMap<
                                ::prost::alloc::string::String,
                                ::prost::alloc::string::String,
                            >,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "database",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::string::String,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("writes"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::vec::Vec<Write>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("labels"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::std::collections::HashMap<
                                                ::prost::alloc::string::String,
                                                ::prost::alloc::string::String,
                                            >,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("database")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("writes")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("labels")?
                            }
                        };
                        _serde::__private::Ok(BatchWriteRequest {
                            database: __field0,
                            writes: __field1,
                            labels: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "database",
                    "writes",
                    "labels",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "BatchWriteRequest",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<BatchWriteRequest>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for BatchWriteRequest {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "BatchWriteRequest",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "database",
                    &self.database,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "writes",
                    &self.writes,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "labels",
                    &self.labels,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// The response from
    /// [Firestore.BatchWrite][google.firestore.v1.Firestore.BatchWrite].
    #[serde(rename_all = "camelCase")]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub struct BatchWriteResponse {
        /// The result of applying the writes.
        ///
        /// This i-th write result corresponds to the i-th write in the
        /// request.
        #[prost(message, repeated, tag = "1")]
        pub write_results: ::prost::alloc::vec::Vec<WriteResult>,
        /// The status of applying the writes.
        ///
        /// This i-th write status corresponds to the i-th write in the
        /// request.
        #[prost(message, repeated, tag = "2")]
        pub status: ::prost::alloc::vec::Vec<super::super::rpc::Status>,
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::clone::Clone for BatchWriteResponse {
        #[inline]
        fn clone(&self) -> BatchWriteResponse {
            BatchWriteResponse {
                write_results: ::core::clone::Clone::clone(&self.write_results),
                status: ::core::clone::Clone::clone(&self.status),
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::marker::StructuralPartialEq for BatchWriteResponse {}
    #[automatically_derived]
    #[allow(clippy::derive_partial_eq_without_eq)]
    impl ::core::cmp::PartialEq for BatchWriteResponse {
        #[inline]
        fn eq(&self, other: &BatchWriteResponse) -> bool {
            self.write_results == other.write_results && self.status == other.status
        }
    }
    impl ::prost::Message for BatchWriteResponse {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            for msg in &self.write_results {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            for msg in &self.status {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "BatchWriteResponse";
            match tag {
                1u32 => {
                    let mut value = &mut self.write_results;
                    ::prost::encoding::message::merge_repeated(
                            wire_type,
                            value,
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "write_results");
                            error
                        })
                }
                2u32 => {
                    let mut value = &mut self.status;
                    ::prost::encoding::message::merge_repeated(
                            wire_type,
                            value,
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "status");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0
                + ::prost::encoding::message::encoded_len_repeated(
                    1u32,
                    &self.write_results,
                ) + ::prost::encoding::message::encoded_len_repeated(2u32, &self.status)
        }
        fn clear(&mut self) {
            self.write_results.clear();
            self.status.clear();
        }
    }
    impl ::core::default::Default for BatchWriteResponse {
        fn default() -> Self {
            BatchWriteResponse {
                write_results: ::core::default::Default::default(),
                status: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for BatchWriteResponse {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("BatchWriteResponse");
            let builder = {
                let wrapper = &self.write_results;
                builder.field("write_results", &wrapper)
            };
            let builder = {
                let wrapper = &self.status;
                builder.field("status", &wrapper)
            };
            builder.finish()
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for BatchWriteResponse {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "writeResults" => _serde::__private::Ok(__Field::__field0),
                            "status" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"writeResults" => _serde::__private::Ok(__Field::__field0),
                            b"status" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<BatchWriteResponse>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = BatchWriteResponse;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct BatchWriteResponse",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::vec::Vec<WriteResult>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct BatchWriteResponse with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            ::prost::alloc::vec::Vec<super::super::rpc::Status>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct BatchWriteResponse with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(BatchWriteResponse {
                            write_results: __field0,
                            status: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ::prost::alloc::vec::Vec<WriteResult>,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            ::prost::alloc::vec::Vec<super::super::rpc::Status>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "writeResults",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::vec::Vec<WriteResult>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("status"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ::prost::alloc::vec::Vec<super::super::rpc::Status>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("writeResults")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("status")?
                            }
                        };
                        _serde::__private::Ok(BatchWriteResponse {
                            write_results: __field0,
                            status: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["writeResults", "status"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "BatchWriteResponse",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<BatchWriteResponse>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for BatchWriteResponse {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "BatchWriteResponse",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "writeResults",
                    &self.write_results,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "status",
                    &self.status,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    /// Generated client implementations.
    pub mod firestore_client {
        #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
        use tonic::codegen::*;
        use tonic::codegen::http::Uri;
        /// The Cloud Firestore service.
        ///
        /// Cloud Firestore is a fast, fully managed, serverless, cloud-native NoSQL
        /// document database that simplifies storing, syncing, and querying data for
        /// your mobile, web, and IoT apps at global scale. Its client libraries provide
        /// live synchronization and offline support, while its security features and
        /// integrations with Firebase and Google Cloud Platform accelerate building
        /// truly serverless apps.
        pub struct FirestoreClient<T> {
            inner: tonic::client::Grpc<T>,
        }
        #[automatically_derived]
        impl<T: ::core::fmt::Debug> ::core::fmt::Debug for FirestoreClient<T> {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "FirestoreClient",
                    "inner",
                    &&self.inner,
                )
            }
        }
        #[automatically_derived]
        impl<T: ::core::clone::Clone> ::core::clone::Clone for FirestoreClient<T> {
            #[inline]
            fn clone(&self) -> FirestoreClient<T> {
                FirestoreClient {
                    inner: ::core::clone::Clone::clone(&self.inner),
                }
            }
        }
        impl FirestoreClient<tonic::transport::Channel> {
            /// Attempt to create a new client by connecting to a given endpoint.
            pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
            where
                D: TryInto<tonic::transport::Endpoint>,
                D::Error: Into<StdError>,
            {
                let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
                Ok(Self::new(conn))
            }
        }
        impl<T> FirestoreClient<T>
        where
            T: tonic::client::GrpcService<tonic::body::BoxBody>,
            T::Error: Into<StdError>,
            T::ResponseBody: Body<Data = Bytes> + Send + 'static,
            <T::ResponseBody as Body>::Error: Into<StdError> + Send,
        {
            pub fn new(inner: T) -> Self {
                let inner = tonic::client::Grpc::new(inner);
                Self { inner }
            }
            pub fn with_origin(inner: T, origin: Uri) -> Self {
                let inner = tonic::client::Grpc::with_origin(inner, origin);
                Self { inner }
            }
            pub fn with_interceptor<F>(
                inner: T,
                interceptor: F,
            ) -> FirestoreClient<InterceptedService<T, F>>
            where
                F: tonic::service::Interceptor,
                T::ResponseBody: Default,
                T: tonic::codegen::Service<
                    http::Request<tonic::body::BoxBody>,
                    Response = http::Response<
                        <T as tonic::client::GrpcService<
                            tonic::body::BoxBody,
                        >>::ResponseBody,
                    >,
                >,
                <T as tonic::codegen::Service<
                    http::Request<tonic::body::BoxBody>,
                >>::Error: Into<StdError> + Send + Sync,
            {
                FirestoreClient::new(InterceptedService::new(inner, interceptor))
            }
            /// Compress requests with the given encoding.
            ///
            /// This requires the server to support it otherwise it might respond with an
            /// error.
            #[must_use]
            pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
                self.inner = self.inner.send_compressed(encoding);
                self
            }
            /// Enable decompressing responses.
            #[must_use]
            pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
                self.inner = self.inner.accept_compressed(encoding);
                self
            }
            /// Limits the maximum size of a decoded message.
            ///
            /// Default: `4MB`
            #[must_use]
            pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
                self.inner = self.inner.max_decoding_message_size(limit);
                self
            }
            /// Limits the maximum size of an encoded message.
            ///
            /// Default: `usize::MAX`
            #[must_use]
            pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
                self.inner = self.inner.max_encoding_message_size(limit);
                self
            }
            /// Gets a single document.
            pub async fn get_document(
                &mut self,
                request: impl tonic::IntoRequest<super::GetDocumentRequest>,
            ) -> std::result::Result<tonic::Response<super::Document>, tonic::Status> {
                self.inner
                    .ready()
                    .await
                    .map_err(|e| {
                        tonic::Status::new(
                            tonic::Code::Unknown,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Service was not ready: {0}", e.into()),
                                );
                                res
                            },
                        )
                    })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static(
                    "/google.firestore.v1.Firestore/GetDocument",
                );
                let mut req = request.into_request();
                req.extensions_mut()
                    .insert(
                        GrpcMethod::new("google.firestore.v1.Firestore", "GetDocument"),
                    );
                self.inner.unary(req, path, codec).await
            }
            /// Lists documents.
            pub async fn list_documents(
                &mut self,
                request: impl tonic::IntoRequest<super::ListDocumentsRequest>,
            ) -> std::result::Result<
                tonic::Response<super::ListDocumentsResponse>,
                tonic::Status,
            > {
                self.inner
                    .ready()
                    .await
                    .map_err(|e| {
                        tonic::Status::new(
                            tonic::Code::Unknown,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Service was not ready: {0}", e.into()),
                                );
                                res
                            },
                        )
                    })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static(
                    "/google.firestore.v1.Firestore/ListDocuments",
                );
                let mut req = request.into_request();
                req.extensions_mut()
                    .insert(
                        GrpcMethod::new("google.firestore.v1.Firestore", "ListDocuments"),
                    );
                self.inner.unary(req, path, codec).await
            }
            /// Updates or inserts a document.
            pub async fn update_document(
                &mut self,
                request: impl tonic::IntoRequest<super::UpdateDocumentRequest>,
            ) -> std::result::Result<tonic::Response<super::Document>, tonic::Status> {
                self.inner
                    .ready()
                    .await
                    .map_err(|e| {
                        tonic::Status::new(
                            tonic::Code::Unknown,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Service was not ready: {0}", e.into()),
                                );
                                res
                            },
                        )
                    })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static(
                    "/google.firestore.v1.Firestore/UpdateDocument",
                );
                let mut req = request.into_request();
                req.extensions_mut()
                    .insert(
                        GrpcMethod::new(
                            "google.firestore.v1.Firestore",
                            "UpdateDocument",
                        ),
                    );
                self.inner.unary(req, path, codec).await
            }
            /// Deletes a document.
            pub async fn delete_document(
                &mut self,
                request: impl tonic::IntoRequest<super::DeleteDocumentRequest>,
            ) -> std::result::Result<
                tonic::Response<super::super::super::protobuf::Empty>,
                tonic::Status,
            > {
                self.inner
                    .ready()
                    .await
                    .map_err(|e| {
                        tonic::Status::new(
                            tonic::Code::Unknown,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Service was not ready: {0}", e.into()),
                                );
                                res
                            },
                        )
                    })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static(
                    "/google.firestore.v1.Firestore/DeleteDocument",
                );
                let mut req = request.into_request();
                req.extensions_mut()
                    .insert(
                        GrpcMethod::new(
                            "google.firestore.v1.Firestore",
                            "DeleteDocument",
                        ),
                    );
                self.inner.unary(req, path, codec).await
            }
            /// Gets multiple documents.
            ///
            /// Documents returned by this method are not guaranteed to be returned in the
            /// same order that they were requested.
            pub async fn batch_get_documents(
                &mut self,
                request: impl tonic::IntoRequest<super::BatchGetDocumentsRequest>,
            ) -> std::result::Result<
                tonic::Response<
                    tonic::codec::Streaming<super::BatchGetDocumentsResponse>,
                >,
                tonic::Status,
            > {
                self.inner
                    .ready()
                    .await
                    .map_err(|e| {
                        tonic::Status::new(
                            tonic::Code::Unknown,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Service was not ready: {0}", e.into()),
                                );
                                res
                            },
                        )
                    })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static(
                    "/google.firestore.v1.Firestore/BatchGetDocuments",
                );
                let mut req = request.into_request();
                req.extensions_mut()
                    .insert(
                        GrpcMethod::new(
                            "google.firestore.v1.Firestore",
                            "BatchGetDocuments",
                        ),
                    );
                self.inner.server_streaming(req, path, codec).await
            }
            /// Starts a new transaction.
            pub async fn begin_transaction(
                &mut self,
                request: impl tonic::IntoRequest<super::BeginTransactionRequest>,
            ) -> std::result::Result<
                tonic::Response<super::BeginTransactionResponse>,
                tonic::Status,
            > {
                self.inner
                    .ready()
                    .await
                    .map_err(|e| {
                        tonic::Status::new(
                            tonic::Code::Unknown,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Service was not ready: {0}", e.into()),
                                );
                                res
                            },
                        )
                    })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static(
                    "/google.firestore.v1.Firestore/BeginTransaction",
                );
                let mut req = request.into_request();
                req.extensions_mut()
                    .insert(
                        GrpcMethod::new(
                            "google.firestore.v1.Firestore",
                            "BeginTransaction",
                        ),
                    );
                self.inner.unary(req, path, codec).await
            }
            /// Commits a transaction, while optionally updating documents.
            pub async fn commit(
                &mut self,
                request: impl tonic::IntoRequest<super::CommitRequest>,
            ) -> std::result::Result<
                tonic::Response<super::CommitResponse>,
                tonic::Status,
            > {
                self.inner
                    .ready()
                    .await
                    .map_err(|e| {
                        tonic::Status::new(
                            tonic::Code::Unknown,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Service was not ready: {0}", e.into()),
                                );
                                res
                            },
                        )
                    })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static(
                    "/google.firestore.v1.Firestore/Commit",
                );
                let mut req = request.into_request();
                req.extensions_mut()
                    .insert(GrpcMethod::new("google.firestore.v1.Firestore", "Commit"));
                self.inner.unary(req, path, codec).await
            }
            /// Rolls back a transaction.
            pub async fn rollback(
                &mut self,
                request: impl tonic::IntoRequest<super::RollbackRequest>,
            ) -> std::result::Result<
                tonic::Response<super::super::super::protobuf::Empty>,
                tonic::Status,
            > {
                self.inner
                    .ready()
                    .await
                    .map_err(|e| {
                        tonic::Status::new(
                            tonic::Code::Unknown,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Service was not ready: {0}", e.into()),
                                );
                                res
                            },
                        )
                    })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static(
                    "/google.firestore.v1.Firestore/Rollback",
                );
                let mut req = request.into_request();
                req.extensions_mut()
                    .insert(
                        GrpcMethod::new("google.firestore.v1.Firestore", "Rollback"),
                    );
                self.inner.unary(req, path, codec).await
            }
            /// Runs a query.
            pub async fn run_query(
                &mut self,
                request: impl tonic::IntoRequest<super::RunQueryRequest>,
            ) -> std::result::Result<
                tonic::Response<tonic::codec::Streaming<super::RunQueryResponse>>,
                tonic::Status,
            > {
                self.inner
                    .ready()
                    .await
                    .map_err(|e| {
                        tonic::Status::new(
                            tonic::Code::Unknown,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Service was not ready: {0}", e.into()),
                                );
                                res
                            },
                        )
                    })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static(
                    "/google.firestore.v1.Firestore/RunQuery",
                );
                let mut req = request.into_request();
                req.extensions_mut()
                    .insert(
                        GrpcMethod::new("google.firestore.v1.Firestore", "RunQuery"),
                    );
                self.inner.server_streaming(req, path, codec).await
            }
            /// Runs an aggregation query.
            ///
            /// Rather than producing [Document][google.firestore.v1.Document] results like
            /// [Firestore.RunQuery][google.firestore.v1.Firestore.RunQuery], this API
            /// allows running an aggregation to produce a series of
            /// [AggregationResult][google.firestore.v1.AggregationResult] server-side.
            ///
            /// High-Level Example:
            ///
            /// ```
            /// -- Return the number of documents in table given a filter.
            /// SELECT COUNT(*) FROM ( SELECT * FROM k where a = true );
            /// ```
            pub async fn run_aggregation_query(
                &mut self,
                request: impl tonic::IntoRequest<super::RunAggregationQueryRequest>,
            ) -> std::result::Result<
                tonic::Response<
                    tonic::codec::Streaming<super::RunAggregationQueryResponse>,
                >,
                tonic::Status,
            > {
                self.inner
                    .ready()
                    .await
                    .map_err(|e| {
                        tonic::Status::new(
                            tonic::Code::Unknown,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Service was not ready: {0}", e.into()),
                                );
                                res
                            },
                        )
                    })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static(
                    "/google.firestore.v1.Firestore/RunAggregationQuery",
                );
                let mut req = request.into_request();
                req.extensions_mut()
                    .insert(
                        GrpcMethod::new(
                            "google.firestore.v1.Firestore",
                            "RunAggregationQuery",
                        ),
                    );
                self.inner.server_streaming(req, path, codec).await
            }
            /// Partitions a query by returning partition cursors that can be used to run
            /// the query in parallel. The returned partition cursors are split points that
            /// can be used by RunQuery as starting/end points for the query results.
            pub async fn partition_query(
                &mut self,
                request: impl tonic::IntoRequest<super::PartitionQueryRequest>,
            ) -> std::result::Result<
                tonic::Response<super::PartitionQueryResponse>,
                tonic::Status,
            > {
                self.inner
                    .ready()
                    .await
                    .map_err(|e| {
                        tonic::Status::new(
                            tonic::Code::Unknown,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Service was not ready: {0}", e.into()),
                                );
                                res
                            },
                        )
                    })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static(
                    "/google.firestore.v1.Firestore/PartitionQuery",
                );
                let mut req = request.into_request();
                req.extensions_mut()
                    .insert(
                        GrpcMethod::new(
                            "google.firestore.v1.Firestore",
                            "PartitionQuery",
                        ),
                    );
                self.inner.unary(req, path, codec).await
            }
            /// Streams batches of document updates and deletes, in order. This method is
            /// only available via gRPC or WebChannel (not REST).
            pub async fn write(
                &mut self,
                request: impl tonic::IntoStreamingRequest<Message = super::WriteRequest>,
            ) -> std::result::Result<
                tonic::Response<tonic::codec::Streaming<super::WriteResponse>>,
                tonic::Status,
            > {
                self.inner
                    .ready()
                    .await
                    .map_err(|e| {
                        tonic::Status::new(
                            tonic::Code::Unknown,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Service was not ready: {0}", e.into()),
                                );
                                res
                            },
                        )
                    })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static(
                    "/google.firestore.v1.Firestore/Write",
                );
                let mut req = request.into_streaming_request();
                req.extensions_mut()
                    .insert(GrpcMethod::new("google.firestore.v1.Firestore", "Write"));
                self.inner.streaming(req, path, codec).await
            }
            /// Listens to changes. This method is only available via gRPC or WebChannel
            /// (not REST).
            pub async fn listen(
                &mut self,
                request: impl tonic::IntoStreamingRequest<Message = super::ListenRequest>,
            ) -> std::result::Result<
                tonic::Response<tonic::codec::Streaming<super::ListenResponse>>,
                tonic::Status,
            > {
                self.inner
                    .ready()
                    .await
                    .map_err(|e| {
                        tonic::Status::new(
                            tonic::Code::Unknown,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Service was not ready: {0}", e.into()),
                                );
                                res
                            },
                        )
                    })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static(
                    "/google.firestore.v1.Firestore/Listen",
                );
                let mut req = request.into_streaming_request();
                req.extensions_mut()
                    .insert(GrpcMethod::new("google.firestore.v1.Firestore", "Listen"));
                self.inner.streaming(req, path, codec).await
            }
            /// Lists all the collection IDs underneath a document.
            pub async fn list_collection_ids(
                &mut self,
                request: impl tonic::IntoRequest<super::ListCollectionIdsRequest>,
            ) -> std::result::Result<
                tonic::Response<super::ListCollectionIdsResponse>,
                tonic::Status,
            > {
                self.inner
                    .ready()
                    .await
                    .map_err(|e| {
                        tonic::Status::new(
                            tonic::Code::Unknown,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Service was not ready: {0}", e.into()),
                                );
                                res
                            },
                        )
                    })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static(
                    "/google.firestore.v1.Firestore/ListCollectionIds",
                );
                let mut req = request.into_request();
                req.extensions_mut()
                    .insert(
                        GrpcMethod::new(
                            "google.firestore.v1.Firestore",
                            "ListCollectionIds",
                        ),
                    );
                self.inner.unary(req, path, codec).await
            }
            /// Applies a batch of write operations.
            ///
            /// The BatchWrite method does not apply the write operations atomically
            /// and can apply them out of order. Method does not allow more than one write
            /// per document. Each write succeeds or fails independently. See the
            /// [BatchWriteResponse][google.firestore.v1.BatchWriteResponse] for the
            /// success status of each write.
            ///
            /// If you require an atomically applied set of writes, use
            /// [Commit][google.firestore.v1.Firestore.Commit] instead.
            pub async fn batch_write(
                &mut self,
                request: impl tonic::IntoRequest<super::BatchWriteRequest>,
            ) -> std::result::Result<
                tonic::Response<super::BatchWriteResponse>,
                tonic::Status,
            > {
                self.inner
                    .ready()
                    .await
                    .map_err(|e| {
                        tonic::Status::new(
                            tonic::Code::Unknown,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Service was not ready: {0}", e.into()),
                                );
                                res
                            },
                        )
                    })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static(
                    "/google.firestore.v1.Firestore/BatchWrite",
                );
                let mut req = request.into_request();
                req.extensions_mut()
                    .insert(
                        GrpcMethod::new("google.firestore.v1.Firestore", "BatchWrite"),
                    );
                self.inner.unary(req, path, codec).await
            }
            /// Creates a new document.
            pub async fn create_document(
                &mut self,
                request: impl tonic::IntoRequest<super::CreateDocumentRequest>,
            ) -> std::result::Result<tonic::Response<super::Document>, tonic::Status> {
                self.inner
                    .ready()
                    .await
                    .map_err(|e| {
                        tonic::Status::new(
                            tonic::Code::Unknown,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Service was not ready: {0}", e.into()),
                                );
                                res
                            },
                        )
                    })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static(
                    "/google.firestore.v1.Firestore/CreateDocument",
                );
                let mut req = request.into_request();
                req.extensions_mut()
                    .insert(
                        GrpcMethod::new(
                            "google.firestore.v1.Firestore",
                            "CreateDocument",
                        ),
                    );
                self.inner.unary(req, path, codec).await
            }
        }
    }
}
