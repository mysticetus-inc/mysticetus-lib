// This file is @generated by prost-build.
/// Configuration for Cloud KMS encryption settings.
#[derive(serde::Deserialize, serde::Serialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EncryptionConfiguration {
    /// Optional. Describes the Cloud KMS encryption key that will be used to
    /// protect destination BigQuery table. The BigQuery Service Account associated
    /// with your project requires access to this encryption key.
    #[prost(message, optional, tag = "1")]
    pub kms_key_name: ::core::option::Option<super::super::super::protobuf::StringValue>,
}
/// Id path of a model.
#[derive(serde::Deserialize, serde::Serialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModelReference {
    /// Required. The ID of the project containing this model.
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Required. The ID of the dataset containing this model.
    #[prost(string, tag = "2")]
    pub dataset_id: ::prost::alloc::string::String,
    /// Required. The ID of the model. The ID must contain only
    /// letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum
    /// length is 1,024 characters.
    #[prost(string, tag = "3")]
    pub model_id: ::prost::alloc::string::String,
}
/// The data type of a variable such as a function argument.
/// Examples include:
///
/// * INT64: `{"typeKind": "INT64"}`
///
/// * ARRAY<STRING>:
///
///      {
///        "typeKind": "ARRAY",
///        "arrayElementType": {"typeKind": "STRING"}
///      }
///
/// * STRUCT<x STRING, y ARRAY<DATE>>:
///
///      {
///        "typeKind": "STRUCT",
///        "structType":
///        {
///          "fields":
///          [
///            {
///              "name": "x",
///              "type": {"typeKind": "STRING"}
///            },
///            {
///              "name": "y",
///              "type":
///              {
///                "typeKind": "ARRAY",
///                "arrayElementType": {"typeKind": "DATE"}
///              }
///            }
///          ]
///        }
///      }
///
/// * RANGE<DATE>:
///
///      {
///        "typeKind": "RANGE",
///        "rangeElementType": {"typeKind": "DATE"}
///      }
#[derive(serde::Deserialize, serde::Serialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StandardSqlDataType {
    /// Required. The top level type of this field.
    /// Can be any GoogleSQL data type (e.g., "INT64", "DATE", "ARRAY").
    #[prost(enumeration = "standard_sql_data_type::TypeKind", tag = "1")]
    pub type_kind: i32,
    /// For complex types, the sub type information.
    #[prost(oneof = "standard_sql_data_type::SubType", tags = "2, 3, 4")]
    pub sub_type: ::core::option::Option<standard_sql_data_type::SubType>,
}
/// Nested message and enum types in `StandardSqlDataType`.
pub mod standard_sql_data_type {
    /// The kind of the datatype.
    #[derive(serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum TypeKind {
        /// Invalid type.
        Unspecified = 0,
        /// Encoded as a string in decimal format.
        Int64 = 2,
        /// Encoded as a boolean "false" or "true".
        Bool = 5,
        /// Encoded as a number, or string "NaN", "Infinity" or "-Infinity".
        Float64 = 7,
        /// Encoded as a string value.
        String = 8,
        /// Encoded as a base64 string per RFC 4648, section 4.
        Bytes = 9,
        /// Encoded as an RFC 3339 timestamp with mandatory "Z" time zone string:
        /// 1985-04-12T23:20:50.52Z
        Timestamp = 19,
        /// Encoded as RFC 3339 full-date format string: 1985-04-12
        Date = 10,
        /// Encoded as RFC 3339 partial-time format string: 23:20:50.52
        Time = 20,
        /// Encoded as RFC 3339 full-date "T" partial-time: 1985-04-12T23:20:50.52
        Datetime = 21,
        /// Encoded as fully qualified 3 part: 0-5 15 2:30:45.6
        Interval = 26,
        /// Encoded as WKT
        Geography = 22,
        /// Encoded as a decimal string.
        Numeric = 23,
        /// Encoded as a decimal string.
        Bignumeric = 24,
        /// Encoded as a string.
        Json = 25,
        /// Encoded as a list with types matching Type.array_type.
        Array = 16,
        /// Encoded as a list with fields of type Type.struct_type\[i\]. List is used
        /// because a JSON object cannot have duplicate field names.
        Struct = 17,
        /// Encoded as a pair with types matching range_element_type. Pairs must
        /// begin with "[", end with ")", and be separated by ", ".
        Range = 29,
    }
    impl TypeKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_KIND_UNSPECIFIED",
                Self::Int64 => "INT64",
                Self::Bool => "BOOL",
                Self::Float64 => "FLOAT64",
                Self::String => "STRING",
                Self::Bytes => "BYTES",
                Self::Timestamp => "TIMESTAMP",
                Self::Date => "DATE",
                Self::Time => "TIME",
                Self::Datetime => "DATETIME",
                Self::Interval => "INTERVAL",
                Self::Geography => "GEOGRAPHY",
                Self::Numeric => "NUMERIC",
                Self::Bignumeric => "BIGNUMERIC",
                Self::Json => "JSON",
                Self::Array => "ARRAY",
                Self::Struct => "STRUCT",
                Self::Range => "RANGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_KIND_UNSPECIFIED" => Some(Self::Unspecified),
                "INT64" => Some(Self::Int64),
                "BOOL" => Some(Self::Bool),
                "FLOAT64" => Some(Self::Float64),
                "STRING" => Some(Self::String),
                "BYTES" => Some(Self::Bytes),
                "TIMESTAMP" => Some(Self::Timestamp),
                "DATE" => Some(Self::Date),
                "TIME" => Some(Self::Time),
                "DATETIME" => Some(Self::Datetime),
                "INTERVAL" => Some(Self::Interval),
                "GEOGRAPHY" => Some(Self::Geography),
                "NUMERIC" => Some(Self::Numeric),
                "BIGNUMERIC" => Some(Self::Bignumeric),
                "JSON" => Some(Self::Json),
                "ARRAY" => Some(Self::Array),
                "STRUCT" => Some(Self::Struct),
                "RANGE" => Some(Self::Range),
                _ => None,
            }
        }
    }
    /// For complex types, the sub type information.
    #[derive(serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SubType {
        /// The type of the array's elements, if type_kind = "ARRAY".
        #[prost(message, tag = "2")]
        ArrayElementType(::prost::alloc::boxed::Box<super::StandardSqlDataType>),
        /// The fields of this struct, in order, if type_kind = "STRUCT".
        #[prost(message, tag = "3")]
        StructType(super::StandardSqlStructType),
        /// The type of the range's elements, if type_kind = "RANGE".
        #[prost(message, tag = "4")]
        RangeElementType(::prost::alloc::boxed::Box<super::StandardSqlDataType>),
    }
}
/// A field or a column.
#[derive(serde::Deserialize, serde::Serialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StandardSqlField {
    /// Optional. The name of this field. Can be absent for struct fields.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The type of this parameter. Absent if not explicitly
    /// specified (e.g., CREATE FUNCTION statement can omit the return type;
    /// in this case the output parameter does not have this "type" field).
    #[prost(message, optional, tag = "2")]
    pub r#type: ::core::option::Option<StandardSqlDataType>,
}
/// The representation of a SQL STRUCT type.
#[derive(serde::Deserialize, serde::Serialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StandardSqlStructType {
    /// Fields within the struct.
    #[prost(message, repeated, tag = "1")]
    pub fields: ::prost::alloc::vec::Vec<StandardSqlField>,
}
/// A table type
#[derive(serde::Deserialize, serde::Serialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StandardSqlTableType {
    /// The columns in this table type
    #[prost(message, repeated, tag = "1")]
    pub columns: ::prost::alloc::vec::Vec<StandardSqlField>,
}
#[derive(serde::Deserialize, serde::Serialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableReference {
    /// Required. The ID of the project containing this table.
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Required. The ID of the dataset containing this table.
    #[prost(string, tag = "2")]
    pub dataset_id: ::prost::alloc::string::String,
    /// Required. The ID of the table. The ID can contain Unicode characters in
    /// category L (letter), M (mark), N (number), Pc (connector, including
    /// underscore), Pd (dash), and Zs (space). For more information, see [General
    /// Category](<https://wikipedia.org/wiki/Unicode_character_property#General_Category>).
    /// The maximum length is 1,024 characters.  Certain operations allow suffixing
    /// of the table ID with a partition decorator, such as
    /// `sample_table$20190123`.
    #[prost(string, tag = "3")]
    pub table_id: ::prost::alloc::string::String,
}
/// Remote Model Info
#[derive(serde::Deserialize, serde::Serialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoteModelInfo {
    /// Output only. Fully qualified name of the user-provided connection object of
    /// the remote model. Format:
    /// ```"projects/{project_id}/locations/{location_id}/connections/{connection_id}"```
    #[prost(string, tag = "3")]
    pub connection: ::prost::alloc::string::String,
    /// Output only. Max number of rows in each batch sent to the remote service.
    /// If unset, the number of rows in each batch is set dynamically.
    #[prost(int64, tag = "4")]
    pub max_batching_rows: i64,
    /// Output only. The model version for LLM.
    #[prost(string, tag = "5")]
    pub remote_model_version: ::prost::alloc::string::String,
    /// Output only. The name of the speech recognizer to use for speech
    /// recognition. The expected format is
    /// `projects/{project}/locations/{location}/recognizers/{recognizer}`.
    /// Customers can specify this field at model creation. If not specified, a
    /// default recognizer `projects/{model
    /// project}/locations/global/recognizers/_` will be used. See more details at
    /// [recognizers](<https://cloud.google.com/speech-to-text/v2/docs/reference/rest/v2/projects.locations.recognizers>)
    #[prost(string, tag = "7")]
    pub speech_recognizer: ::prost::alloc::string::String,
    /// Remote services are services outside of BigQuery used by remote models for
    /// predictions. A remote service is backed by either an arbitrary endpoint or
    /// a selected remote service type, but not both.
    #[prost(oneof = "remote_model_info::RemoteService", tags = "1, 2")]
    pub remote_service: ::core::option::Option<remote_model_info::RemoteService>,
}
/// Nested message and enum types in `RemoteModelInfo`.
pub mod remote_model_info {
    /// Supported service type for remote model.
    #[derive(serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum RemoteServiceType {
        /// Unspecified remote service type.
        Unspecified = 0,
        /// V3 Cloud AI Translation API. See more details at \[Cloud Translation API\]
        /// (<https://cloud.google.com/translate/docs/reference/rest>).
        CloudAiTranslateV3 = 1,
        /// V1 Cloud AI Vision API See more details at \[Cloud Vision API\]
        /// (<https://cloud.google.com/vision/docs/reference/rest>).
        CloudAiVisionV1 = 2,
        /// V1 Cloud AI Natural Language API. See more details at [REST Resource:
        /// documents](<https://cloud.google.com/natural-language/docs/reference/rest/v1/documents>).
        CloudAiNaturalLanguageV1 = 3,
        /// V2 Speech-to-Text API. See more details at [Google Cloud Speech-to-Text
        /// V2 API](<https://cloud.google.com/speech-to-text/v2/docs>)
        CloudAiSpeechToTextV2 = 7,
    }
    impl RemoteServiceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "REMOTE_SERVICE_TYPE_UNSPECIFIED",
                Self::CloudAiTranslateV3 => "CLOUD_AI_TRANSLATE_V3",
                Self::CloudAiVisionV1 => "CLOUD_AI_VISION_V1",
                Self::CloudAiNaturalLanguageV1 => "CLOUD_AI_NATURAL_LANGUAGE_V1",
                Self::CloudAiSpeechToTextV2 => "CLOUD_AI_SPEECH_TO_TEXT_V2",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REMOTE_SERVICE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "CLOUD_AI_TRANSLATE_V3" => Some(Self::CloudAiTranslateV3),
                "CLOUD_AI_VISION_V1" => Some(Self::CloudAiVisionV1),
                "CLOUD_AI_NATURAL_LANGUAGE_V1" => Some(Self::CloudAiNaturalLanguageV1),
                "CLOUD_AI_SPEECH_TO_TEXT_V2" => Some(Self::CloudAiSpeechToTextV2),
                _ => None,
            }
        }
    }
    /// Remote services are services outside of BigQuery used by remote models for
    /// predictions. A remote service is backed by either an arbitrary endpoint or
    /// a selected remote service type, but not both.
    #[derive(serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum RemoteService {
        /// Output only. The endpoint for remote model.
        #[prost(string, tag = "1")]
        Endpoint(::prost::alloc::string::String),
        /// Output only. The remote service type for remote model.
        #[prost(enumeration = "RemoteServiceType", tag = "2")]
        RemoteServiceType(i32),
    }
}
/// Information about a single transform column.
#[derive(serde::Deserialize, serde::Serialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransformColumn {
    /// Output only. Name of the column.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Data type of the column after the transform.
    #[prost(message, optional, tag = "2")]
    pub r#type: ::core::option::Option<StandardSqlDataType>,
    /// Output only. The SQL expression used in the column transform.
    #[prost(string, tag = "3")]
    pub transform_sql: ::prost::alloc::string::String,
}
#[derive(serde::Deserialize, serde::Serialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Model {
    /// Output only. A hash of this resource.
    #[prost(string, tag = "1")]
    pub etag: ::prost::alloc::string::String,
    /// Required. Unique identifier for this model.
    #[prost(message, optional, tag = "2")]
    pub model_reference: ::core::option::Option<ModelReference>,
    /// Output only. The time when this model was created, in millisecs since the
    /// epoch.
    #[prost(int64, tag = "5")]
    pub creation_time: i64,
    /// Output only. The time when this model was last modified, in millisecs since
    /// the epoch.
    #[prost(int64, tag = "6")]
    pub last_modified_time: i64,
    /// Optional. A user-friendly description of this model.
    #[prost(string, tag = "12")]
    pub description: ::prost::alloc::string::String,
    /// Optional. A descriptive name for this model.
    #[prost(string, tag = "14")]
    pub friendly_name: ::prost::alloc::string::String,
    /// The labels associated with this model. You can use these to organize
    /// and group your models. Label keys and values can be no longer
    /// than 63 characters, can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// Label values are optional. Label keys must start with a letter and each
    /// label in the list must have a different key.
    #[prost(map = "string, string", tag = "15")]
    pub labels:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// Optional. The time when this model expires, in milliseconds since the
    /// epoch. If not present, the model will persist indefinitely. Expired models
    /// will be deleted and their storage reclaimed.  The defaultTableExpirationMs
    /// property of the encapsulating dataset can be used to set a default
    /// expirationTime on newly created models.
    #[prost(int64, tag = "16")]
    pub expiration_time: i64,
    /// Output only. The geographic location where the model resides. This value
    /// is inherited from the dataset.
    #[prost(string, tag = "13")]
    pub location: ::prost::alloc::string::String,
    /// Custom encryption configuration (e.g., Cloud KMS keys). This shows the
    /// encryption configuration of the model data while stored in BigQuery
    /// storage. This field can be used with PatchModel to update encryption key
    /// for an already encrypted model.
    #[prost(message, optional, tag = "17")]
    pub encryption_configuration: ::core::option::Option<EncryptionConfiguration>,
    /// Output only. Type of the model resource.
    #[prost(enumeration = "model::ModelType", tag = "7")]
    pub model_type: i32,
    /// Information for all training runs in increasing order of start_time.
    #[prost(message, repeated, tag = "9")]
    pub training_runs: ::prost::alloc::vec::Vec<model::TrainingRun>,
    /// Output only. Input feature columns for the model inference. If the model is
    /// trained with TRANSFORM clause, these are the input of the TRANSFORM clause.
    #[prost(message, repeated, tag = "10")]
    pub feature_columns: ::prost::alloc::vec::Vec<StandardSqlField>,
    /// Output only. Label columns that were used to train this model.
    /// The output of the model will have a "predicted_" prefix to these columns.
    #[prost(message, repeated, tag = "11")]
    pub label_columns: ::prost::alloc::vec::Vec<StandardSqlField>,
    /// Output only. This field will be populated if a TRANSFORM clause was used to
    /// train a model. TRANSFORM clause (if used) takes feature_columns as input
    /// and outputs transform_columns. transform_columns then are used to train the
    /// model.
    #[prost(message, repeated, tag = "26")]
    pub transform_columns: ::prost::alloc::vec::Vec<TransformColumn>,
    /// Output only. All hyperparameter search spaces in this model.
    #[prost(message, optional, tag = "18")]
    pub hparam_search_spaces: ::core::option::Option<model::HparamSearchSpaces>,
    /// Output only. The default trial_id to use in TVFs when the trial_id is not
    /// passed in. For single-objective [hyperparameter
    /// tuning](<https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-hp-tuning-overview>)
    /// models, this is the best trial ID. For multi-objective [hyperparameter
    /// tuning](<https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-hp-tuning-overview>)
    /// models, this is the smallest trial ID among all Pareto optimal trials.
    #[prost(int64, tag = "21")]
    pub default_trial_id: i64,
    /// Output only. Trials of a [hyperparameter
    /// tuning](<https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-hp-tuning-overview>)
    /// model sorted by trial_id.
    #[prost(message, repeated, tag = "20")]
    pub hparam_trials: ::prost::alloc::vec::Vec<model::HparamTuningTrial>,
    /// Output only. For single-objective [hyperparameter
    /// tuning](<https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-hp-tuning-overview>)
    /// models, it only contains the best trial. For multi-objective
    /// [hyperparameter
    /// tuning](<https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-hp-tuning-overview>)
    /// models, it contains all Pareto optimal trials sorted by trial_id.
    #[prost(int64, repeated, packed = "false", tag = "22")]
    pub optimal_trial_ids: ::prost::alloc::vec::Vec<i64>,
    /// Output only. Remote model info
    #[prost(message, optional, tag = "25")]
    pub remote_model_info: ::core::option::Option<RemoteModelInfo>,
}
/// Nested message and enum types in `Model`.
pub mod model {
    /// Enums for seasonal period.
    #[derive(serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SeasonalPeriod {}
    /// Nested message and enum types in `SeasonalPeriod`.
    pub mod seasonal_period {
        /// Seasonal period type.
        #[derive(serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum SeasonalPeriodType {
            /// Unspecified seasonal period.
            Unspecified = 0,
            /// No seasonality
            NoSeasonality = 1,
            /// Daily period, 24 hours.
            Daily = 2,
            /// Weekly period, 7 days.
            Weekly = 3,
            /// Monthly period, 30 days or irregular.
            Monthly = 4,
            /// Quarterly period, 90 days or irregular.
            Quarterly = 5,
            /// Yearly period, 365 days or irregular.
            Yearly = 6,
        }
        impl SeasonalPeriodType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "SEASONAL_PERIOD_TYPE_UNSPECIFIED",
                    Self::NoSeasonality => "NO_SEASONALITY",
                    Self::Daily => "DAILY",
                    Self::Weekly => "WEEKLY",
                    Self::Monthly => "MONTHLY",
                    Self::Quarterly => "QUARTERLY",
                    Self::Yearly => "YEARLY",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SEASONAL_PERIOD_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "NO_SEASONALITY" => Some(Self::NoSeasonality),
                    "DAILY" => Some(Self::Daily),
                    "WEEKLY" => Some(Self::Weekly),
                    "MONTHLY" => Some(Self::Monthly),
                    "QUARTERLY" => Some(Self::Quarterly),
                    "YEARLY" => Some(Self::Yearly),
                    _ => None,
                }
            }
        }
    }
    /// Enums for kmeans model type.
    #[derive(serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct KmeansEnums {}
    /// Nested message and enum types in `KmeansEnums`.
    pub mod kmeans_enums {
        /// Indicates the method used to initialize the centroids for KMeans
        /// clustering algorithm.
        #[derive(serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum KmeansInitializationMethod {
            /// Unspecified initialization method.
            Unspecified = 0,
            /// Initializes the centroids randomly.
            Random = 1,
            /// Initializes the centroids using data specified in
            /// kmeans_initialization_column.
            Custom = 2,
            /// Initializes with kmeans++.
            KmeansPlusPlus = 3,
        }
        impl KmeansInitializationMethod {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "KMEANS_INITIALIZATION_METHOD_UNSPECIFIED",
                    Self::Random => "RANDOM",
                    Self::Custom => "CUSTOM",
                    Self::KmeansPlusPlus => "KMEANS_PLUS_PLUS",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "KMEANS_INITIALIZATION_METHOD_UNSPECIFIED" => Some(Self::Unspecified),
                    "RANDOM" => Some(Self::Random),
                    "CUSTOM" => Some(Self::Custom),
                    "KMEANS_PLUS_PLUS" => Some(Self::KmeansPlusPlus),
                    _ => None,
                }
            }
        }
    }
    /// Enums for XGBoost model type.
    #[derive(serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct BoostedTreeOptionEnums {}
    /// Nested message and enum types in `BoostedTreeOptionEnums`.
    pub mod boosted_tree_option_enums {
        /// Booster types supported. Refer to booster parameter in XGBoost.
        #[derive(serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum BoosterType {
            /// Unspecified booster type.
            Unspecified = 0,
            /// Gbtree booster.
            Gbtree = 1,
            /// Dart booster.
            Dart = 2,
        }
        impl BoosterType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "BOOSTER_TYPE_UNSPECIFIED",
                    Self::Gbtree => "GBTREE",
                    Self::Dart => "DART",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "BOOSTER_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "GBTREE" => Some(Self::Gbtree),
                    "DART" => Some(Self::Dart),
                    _ => None,
                }
            }
        }
        /// Type of normalization algorithm for boosted tree models using dart
        /// booster. Refer to normalize_type in XGBoost.
        #[derive(serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum DartNormalizeType {
            /// Unspecified dart normalize type.
            Unspecified = 0,
            /// New trees have the same weight of each of dropped trees.
            Tree = 1,
            /// New trees have the same weight of sum of dropped trees.
            Forest = 2,
        }
        impl DartNormalizeType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "DART_NORMALIZE_TYPE_UNSPECIFIED",
                    Self::Tree => "TREE",
                    Self::Forest => "FOREST",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "DART_NORMALIZE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "TREE" => Some(Self::Tree),
                    "FOREST" => Some(Self::Forest),
                    _ => None,
                }
            }
        }
        /// Tree construction algorithm used in boosted tree models.
        /// Refer to tree_method in XGBoost.
        #[derive(serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum TreeMethod {
            /// Unspecified tree method.
            Unspecified = 0,
            /// Use heuristic to choose the fastest method.
            Auto = 1,
            /// Exact greedy algorithm.
            Exact = 2,
            /// Approximate greedy algorithm using quantile sketch and gradient
            /// histogram.
            Approx = 3,
            /// Fast histogram optimized approximate greedy algorithm.
            Hist = 4,
        }
        impl TreeMethod {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "TREE_METHOD_UNSPECIFIED",
                    Self::Auto => "AUTO",
                    Self::Exact => "EXACT",
                    Self::Approx => "APPROX",
                    Self::Hist => "HIST",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "TREE_METHOD_UNSPECIFIED" => Some(Self::Unspecified),
                    "AUTO" => Some(Self::Auto),
                    "EXACT" => Some(Self::Exact),
                    "APPROX" => Some(Self::Approx),
                    "HIST" => Some(Self::Hist),
                    _ => None,
                }
            }
        }
    }
    /// Enums for hyperparameter tuning.
    #[derive(serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct HparamTuningEnums {}
    /// Nested message and enum types in `HparamTuningEnums`.
    pub mod hparam_tuning_enums {
        /// Available evaluation metrics used as hyperparameter tuning objectives.
        #[derive(serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum HparamTuningObjective {
            /// Unspecified evaluation metric.
            Unspecified = 0,
            /// Mean absolute error.
            /// mean_absolute_error = AVG(ABS(label - predicted))
            MeanAbsoluteError = 1,
            /// Mean squared error.
            /// mean_squared_error = AVG(POW(label - predicted, 2))
            MeanSquaredError = 2,
            /// Mean squared log error.
            /// mean_squared_log_error = AVG(POW(LN(1 + label) - LN(1 + predicted), 2))
            MeanSquaredLogError = 3,
            /// Mean absolute error.
            /// median_absolute_error = APPROX_QUANTILES(absolute_error, 2)\[OFFSET(1)\]
            MedianAbsoluteError = 4,
            /// R^2 score. This corresponds to r2_score in ML.EVALUATE.
            /// r_squared = 1 - SUM(squared_error)/(COUNT(label)*VAR_POP(label))
            RSquared = 5,
            /// Explained variance.
            /// explained_variance = 1 - VAR_POP(label_error)/VAR_POP(label)
            ExplainedVariance = 6,
            /// Precision is the fraction of actual positive predictions that had
            /// positive actual labels. For multiclass this is a macro-averaged metric
            /// treating each class as a binary classifier.
            Precision = 7,
            /// Recall is the fraction of actual positive labels that were given a
            /// positive prediction. For multiclass this is a macro-averaged metric.
            Recall = 8,
            /// Accuracy is the fraction of predictions given the correct label. For
            /// multiclass this is a globally micro-averaged metric.
            Accuracy = 9,
            /// The F1 score is an average of recall and precision. For multiclass this
            /// is a macro-averaged metric.
            F1Score = 10,
            /// Logarithmic Loss. For multiclass this is a macro-averaged metric.
            LogLoss = 11,
            /// Area Under an ROC Curve. For multiclass this is a macro-averaged
            /// metric.
            RocAuc = 12,
            /// Davies-Bouldin Index.
            DaviesBouldinIndex = 13,
            /// Mean Average Precision.
            MeanAveragePrecision = 14,
            /// Normalized Discounted Cumulative Gain.
            NormalizedDiscountedCumulativeGain = 15,
            /// Average Rank.
            AverageRank = 16,
        }
        impl HparamTuningObjective {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "HPARAM_TUNING_OBJECTIVE_UNSPECIFIED",
                    Self::MeanAbsoluteError => "MEAN_ABSOLUTE_ERROR",
                    Self::MeanSquaredError => "MEAN_SQUARED_ERROR",
                    Self::MeanSquaredLogError => "MEAN_SQUARED_LOG_ERROR",
                    Self::MedianAbsoluteError => "MEDIAN_ABSOLUTE_ERROR",
                    Self::RSquared => "R_SQUARED",
                    Self::ExplainedVariance => "EXPLAINED_VARIANCE",
                    Self::Precision => "PRECISION",
                    Self::Recall => "RECALL",
                    Self::Accuracy => "ACCURACY",
                    Self::F1Score => "F1_SCORE",
                    Self::LogLoss => "LOG_LOSS",
                    Self::RocAuc => "ROC_AUC",
                    Self::DaviesBouldinIndex => "DAVIES_BOULDIN_INDEX",
                    Self::MeanAveragePrecision => "MEAN_AVERAGE_PRECISION",
                    Self::NormalizedDiscountedCumulativeGain => {
                        "NORMALIZED_DISCOUNTED_CUMULATIVE_GAIN"
                    }
                    Self::AverageRank => "AVERAGE_RANK",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "HPARAM_TUNING_OBJECTIVE_UNSPECIFIED" => Some(Self::Unspecified),
                    "MEAN_ABSOLUTE_ERROR" => Some(Self::MeanAbsoluteError),
                    "MEAN_SQUARED_ERROR" => Some(Self::MeanSquaredError),
                    "MEAN_SQUARED_LOG_ERROR" => Some(Self::MeanSquaredLogError),
                    "MEDIAN_ABSOLUTE_ERROR" => Some(Self::MedianAbsoluteError),
                    "R_SQUARED" => Some(Self::RSquared),
                    "EXPLAINED_VARIANCE" => Some(Self::ExplainedVariance),
                    "PRECISION" => Some(Self::Precision),
                    "RECALL" => Some(Self::Recall),
                    "ACCURACY" => Some(Self::Accuracy),
                    "F1_SCORE" => Some(Self::F1Score),
                    "LOG_LOSS" => Some(Self::LogLoss),
                    "ROC_AUC" => Some(Self::RocAuc),
                    "DAVIES_BOULDIN_INDEX" => Some(Self::DaviesBouldinIndex),
                    "MEAN_AVERAGE_PRECISION" => Some(Self::MeanAveragePrecision),
                    "NORMALIZED_DISCOUNTED_CUMULATIVE_GAIN" => {
                        Some(Self::NormalizedDiscountedCumulativeGain)
                    }
                    "AVERAGE_RANK" => Some(Self::AverageRank),
                    _ => None,
                }
            }
        }
    }
    /// Evaluation metrics for regression and explicit feedback type matrix
    /// factorization models.
    #[derive(serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct RegressionMetrics {
        /// Mean absolute error.
        #[prost(message, optional, tag = "1")]
        pub mean_absolute_error:
            ::core::option::Option<super::super::super::super::protobuf::DoubleValue>,
        /// Mean squared error.
        #[prost(message, optional, tag = "2")]
        pub mean_squared_error:
            ::core::option::Option<super::super::super::super::protobuf::DoubleValue>,
        /// Mean squared log error.
        #[prost(message, optional, tag = "3")]
        pub mean_squared_log_error:
            ::core::option::Option<super::super::super::super::protobuf::DoubleValue>,
        /// Median absolute error.
        #[prost(message, optional, tag = "4")]
        pub median_absolute_error:
            ::core::option::Option<super::super::super::super::protobuf::DoubleValue>,
        /// R^2 score. This corresponds to r2_score in ML.EVALUATE.
        #[prost(message, optional, tag = "5")]
        pub r_squared: ::core::option::Option<super::super::super::super::protobuf::DoubleValue>,
    }
    /// Aggregate metrics for classification/classifier models. For multi-class
    /// models, the metrics are either macro-averaged or micro-averaged. When
    /// macro-averaged, the metrics are calculated for each label and then an
    /// unweighted average is taken of those values. When micro-averaged, the
    /// metric is calculated globally by counting the total number of correctly
    /// predicted rows.
    #[derive(serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct AggregateClassificationMetrics {
        /// Precision is the fraction of actual positive predictions that had
        /// positive actual labels. For multiclass this is a macro-averaged
        /// metric treating each class as a binary classifier.
        #[prost(message, optional, tag = "1")]
        pub precision: ::core::option::Option<super::super::super::super::protobuf::DoubleValue>,
        /// Recall is the fraction of actual positive labels that were given a
        /// positive prediction. For multiclass this is a macro-averaged metric.
        #[prost(message, optional, tag = "2")]
        pub recall: ::core::option::Option<super::super::super::super::protobuf::DoubleValue>,
        /// Accuracy is the fraction of predictions given the correct label. For
        /// multiclass this is a micro-averaged metric.
        #[prost(message, optional, tag = "3")]
        pub accuracy: ::core::option::Option<super::super::super::super::protobuf::DoubleValue>,
        /// Threshold at which the metrics are computed. For binary
        /// classification models this is the positive class threshold.
        /// For multi-class classification models this is the confidence
        /// threshold.
        #[prost(message, optional, tag = "4")]
        pub threshold: ::core::option::Option<super::super::super::super::protobuf::DoubleValue>,
        /// The F1 score is an average of recall and precision. For multiclass
        /// this is a macro-averaged metric.
        #[prost(message, optional, tag = "5")]
        pub f1_score: ::core::option::Option<super::super::super::super::protobuf::DoubleValue>,
        /// Logarithmic Loss. For multiclass this is a macro-averaged metric.
        #[prost(message, optional, tag = "6")]
        pub log_loss: ::core::option::Option<super::super::super::super::protobuf::DoubleValue>,
        /// Area Under a ROC Curve. For multiclass this is a macro-averaged
        /// metric.
        #[prost(message, optional, tag = "7")]
        pub roc_auc: ::core::option::Option<super::super::super::super::protobuf::DoubleValue>,
    }
    /// Evaluation metrics for binary classification/classifier models.
    #[derive(serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BinaryClassificationMetrics {
        /// Aggregate classification metrics.
        #[prost(message, optional, tag = "1")]
        pub aggregate_classification_metrics:
            ::core::option::Option<AggregateClassificationMetrics>,
        /// Binary confusion matrix at multiple thresholds.
        #[prost(message, repeated, tag = "2")]
        pub binary_confusion_matrix_list:
            ::prost::alloc::vec::Vec<binary_classification_metrics::BinaryConfusionMatrix>,
        /// Label representing the positive class.
        #[prost(string, tag = "3")]
        pub positive_label: ::prost::alloc::string::String,
        /// Label representing the negative class.
        #[prost(string, tag = "4")]
        pub negative_label: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `BinaryClassificationMetrics`.
    pub mod binary_classification_metrics {
        /// Confusion matrix for binary classification models.
        #[derive(serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct BinaryConfusionMatrix {
            /// Threshold value used when computing each of the following metric.
            #[prost(message, optional, tag = "1")]
            pub positive_class_threshold:
                ::core::option::Option<super::super::super::super::super::protobuf::DoubleValue>,
            /// Number of true samples predicted as true.
            #[prost(message, optional, tag = "2")]
            pub true_positives:
                ::core::option::Option<super::super::super::super::super::protobuf::Int64Value>,
            /// Number of false samples predicted as true.
            #[prost(message, optional, tag = "3")]
            pub false_positives:
                ::core::option::Option<super::super::super::super::super::protobuf::Int64Value>,
            /// Number of true samples predicted as false.
            #[prost(message, optional, tag = "4")]
            pub true_negatives:
                ::core::option::Option<super::super::super::super::super::protobuf::Int64Value>,
            /// Number of false samples predicted as false.
            #[prost(message, optional, tag = "5")]
            pub false_negatives:
                ::core::option::Option<super::super::super::super::super::protobuf::Int64Value>,
            /// The fraction of actual positive predictions that had positive actual
            /// labels.
            #[prost(message, optional, tag = "6")]
            pub precision:
                ::core::option::Option<super::super::super::super::super::protobuf::DoubleValue>,
            /// The fraction of actual positive labels that were given a positive
            /// prediction.
            #[prost(message, optional, tag = "7")]
            pub recall:
                ::core::option::Option<super::super::super::super::super::protobuf::DoubleValue>,
            /// The equally weighted average of recall and precision.
            #[prost(message, optional, tag = "8")]
            pub f1_score:
                ::core::option::Option<super::super::super::super::super::protobuf::DoubleValue>,
            /// The fraction of predictions given the correct label.
            #[prost(message, optional, tag = "9")]
            pub accuracy:
                ::core::option::Option<super::super::super::super::super::protobuf::DoubleValue>,
        }
    }
    /// Evaluation metrics for multi-class classification/classifier models.
    #[derive(serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MultiClassClassificationMetrics {
        /// Aggregate classification metrics.
        #[prost(message, optional, tag = "1")]
        pub aggregate_classification_metrics:
            ::core::option::Option<AggregateClassificationMetrics>,
        /// Confusion matrix at different thresholds.
        #[prost(message, repeated, tag = "2")]
        pub confusion_matrix_list:
            ::prost::alloc::vec::Vec<multi_class_classification_metrics::ConfusionMatrix>,
    }
    /// Nested message and enum types in `MultiClassClassificationMetrics`.
    pub mod multi_class_classification_metrics {
        /// Confusion matrix for multi-class classification models.
        #[derive(serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ConfusionMatrix {
            /// Confidence threshold used when computing the entries of the
            /// confusion matrix.
            #[prost(message, optional, tag = "1")]
            pub confidence_threshold:
                ::core::option::Option<super::super::super::super::super::protobuf::DoubleValue>,
            /// One row per actual label.
            #[prost(message, repeated, tag = "2")]
            pub rows: ::prost::alloc::vec::Vec<confusion_matrix::Row>,
        }
        /// Nested message and enum types in `ConfusionMatrix`.
        pub mod confusion_matrix {
            /// A single entry in the confusion matrix.
            #[derive(serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Entry {
                /// The predicted label. For confidence_threshold > 0, we will
                /// also add an entry indicating the number of items under the
                /// confidence threshold.
                #[prost(string, tag = "1")]
                pub predicted_label: ::prost::alloc::string::String,
                /// Number of items being predicted as this label.
                #[prost(message, optional, tag = "2")]
                pub item_count: ::core::option::Option<
                    super::super::super::super::super::super::protobuf::Int64Value,
                >,
            }
            /// A single row in the confusion matrix.
            #[derive(serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Row {
                /// The original label of this row.
                #[prost(string, tag = "1")]
                pub actual_label: ::prost::alloc::string::String,
                /// Info describing predicted label distribution.
                #[prost(message, repeated, tag = "2")]
                pub entries: ::prost::alloc::vec::Vec<Entry>,
            }
        }
    }
    /// Evaluation metrics for clustering models.
    #[derive(serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ClusteringMetrics {
        /// Davies-Bouldin index.
        #[prost(message, optional, tag = "1")]
        pub davies_bouldin_index:
            ::core::option::Option<super::super::super::super::protobuf::DoubleValue>,
        /// Mean of squared distances between each sample to its cluster centroid.
        #[prost(message, optional, tag = "2")]
        pub mean_squared_distance:
            ::core::option::Option<super::super::super::super::protobuf::DoubleValue>,
        /// Information for all clusters.
        #[prost(message, repeated, tag = "3")]
        pub clusters: ::prost::alloc::vec::Vec<clustering_metrics::Cluster>,
    }
    /// Nested message and enum types in `ClusteringMetrics`.
    pub mod clustering_metrics {
        /// Message containing the information about one cluster.
        #[derive(serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Cluster {
            /// Centroid id.
            #[prost(int64, tag = "1")]
            pub centroid_id: i64,
            /// Values of highly variant features for this cluster.
            #[prost(message, repeated, tag = "2")]
            pub feature_values: ::prost::alloc::vec::Vec<cluster::FeatureValue>,
            /// Count of training data rows that were assigned to this cluster.
            #[prost(message, optional, tag = "3")]
            pub count:
                ::core::option::Option<super::super::super::super::super::protobuf::Int64Value>,
        }
        /// Nested message and enum types in `Cluster`.
        pub mod cluster {
            /// Representative value of a single feature within the cluster.
            #[derive(serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct FeatureValue {
                /// The feature column name.
                #[prost(string, tag = "1")]
                pub feature_column: ::prost::alloc::string::String,
                /// Value.
                #[prost(oneof = "feature_value::Value", tags = "2, 3")]
                pub value: ::core::option::Option<feature_value::Value>,
            }
            /// Nested message and enum types in `FeatureValue`.
            pub mod feature_value {
                /// Representative value of a categorical feature.
                #[derive(serde::Deserialize, serde::Serialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct CategoricalValue {
                    /// Counts of all categories for the categorical feature. If there are
                    /// more than ten categories, we return top ten (by count) and return
                    /// one more CategoryCount with category "_OTHER_" and count as
                    /// aggregate counts of remaining categories.
                    #[prost(message, repeated, tag = "1")]
                    pub category_counts: ::prost::alloc::vec::Vec<categorical_value::CategoryCount>,
                }
                /// Nested message and enum types in `CategoricalValue`.
                pub mod categorical_value {
                    /// Represents the count of a single category within the cluster.
                    #[derive(serde::Deserialize, serde::Serialize)]
                    #[serde(rename_all = "camelCase")]
                    #[derive(Clone, PartialEq, ::prost::Message)]
                    pub struct CategoryCount {
                        /// The name of category.
                        #[prost(string, tag = "1")]
                        pub category: ::prost::alloc::string::String,
                        /// The count of training samples matching the category within the
                        /// cluster.
                        #[prost(message, optional, tag = "2")]
                        pub count: ::core::option::Option<
                            super::super::super::super::super::super::super::super::protobuf::Int64Value,
                        >,
                    }
                }
                /// Value.
                #[derive(serde::Deserialize, serde::Serialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, ::prost::Oneof)]
                pub enum Value {
                    /// The numerical feature value. This is the centroid value for this
                    /// feature.
                    #[prost(message, tag = "2")]
                    NumericalValue(
                        super::super::super::super::super::super::super::protobuf::DoubleValue,
                    ),
                    /// The categorical feature value.
                    #[prost(message, tag = "3")]
                    CategoricalValue(CategoricalValue),
                }
            }
        }
    }
    /// Evaluation metrics used by weighted-ALS models specified by
    /// feedback_type=implicit.
    #[derive(serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct RankingMetrics {
        /// Calculates a precision per user for all the items by ranking them and
        /// then averages all the precisions across all the users.
        #[prost(message, optional, tag = "1")]
        pub mean_average_precision:
            ::core::option::Option<super::super::super::super::protobuf::DoubleValue>,
        /// Similar to the mean squared error computed in regression and explicit
        /// recommendation models except instead of computing the rating directly,
        /// the output from evaluate is computed against a preference which is 1 or 0
        /// depending on if the rating exists or not.
        #[prost(message, optional, tag = "2")]
        pub mean_squared_error:
            ::core::option::Option<super::super::super::super::protobuf::DoubleValue>,
        /// A metric to determine the goodness of a ranking calculated from the
        /// predicted confidence by comparing it to an ideal rank measured by the
        /// original ratings.
        #[prost(message, optional, tag = "3")]
        pub normalized_discounted_cumulative_gain:
            ::core::option::Option<super::super::super::super::protobuf::DoubleValue>,
        /// Determines the goodness of a ranking by computing the percentile rank
        /// from the predicted confidence and dividing it by the original rank.
        #[prost(message, optional, tag = "4")]
        pub average_rank: ::core::option::Option<super::super::super::super::protobuf::DoubleValue>,
    }
    /// Model evaluation metrics for ARIMA forecasting models.
    #[derive(serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ArimaForecastingMetrics {
        /// Repeated as there can be many metric sets (one for each model) in
        /// auto-arima and the large-scale case.
        #[prost(message, repeated, tag = "6")]
        pub arima_single_model_forecasting_metrics:
            ::prost::alloc::vec::Vec<arima_forecasting_metrics::ArimaSingleModelForecastingMetrics>,
    }
    /// Nested message and enum types in `ArimaForecastingMetrics`.
    pub mod arima_forecasting_metrics {
        /// Model evaluation metrics for a single ARIMA forecasting model.
        #[derive(serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ArimaSingleModelForecastingMetrics {
            /// Non-seasonal order.
            #[prost(message, optional, tag = "1")]
            pub non_seasonal_order: ::core::option::Option<super::ArimaOrder>,
            /// Arima fitting metrics.
            #[prost(message, optional, tag = "2")]
            pub arima_fitting_metrics: ::core::option::Option<super::ArimaFittingMetrics>,
            /// Is arima model fitted with drift or not. It is always false when d
            /// is not 1.
            #[prost(message, optional, tag = "3")]
            pub has_drift:
                ::core::option::Option<super::super::super::super::super::protobuf::BoolValue>,
            /// The time_series_id value for this time series. It will be one of
            /// the unique values from the time_series_id_column specified during
            /// ARIMA model training. Only present when time_series_id_column
            /// training option was used.
            #[prost(string, tag = "4")]
            pub time_series_id: ::prost::alloc::string::String,
            /// The tuple of time_series_ids identifying this time series. It will
            /// be one of the unique tuples of values present in the
            /// time_series_id_columns specified during ARIMA model training. Only
            /// present when time_series_id_columns training option was used and
            /// the order of values here are same as the order of
            /// time_series_id_columns.
            #[prost(string, repeated, tag = "9")]
            pub time_series_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            /// Seasonal periods. Repeated because multiple periods are supported
            /// for one time series.
            #[prost(
                enumeration = "super::seasonal_period::SeasonalPeriodType",
                repeated,
                tag = "5"
            )]
            pub seasonal_periods: ::prost::alloc::vec::Vec<i32>,
            /// If true, holiday_effect is a part of time series decomposition result.
            #[prost(message, optional, tag = "6")]
            pub has_holiday_effect:
                ::core::option::Option<super::super::super::super::super::protobuf::BoolValue>,
            /// If true, spikes_and_dips is a part of time series decomposition result.
            #[prost(message, optional, tag = "7")]
            pub has_spikes_and_dips:
                ::core::option::Option<super::super::super::super::super::protobuf::BoolValue>,
            /// If true, step_changes is a part of time series decomposition result.
            #[prost(message, optional, tag = "8")]
            pub has_step_changes:
                ::core::option::Option<super::super::super::super::super::protobuf::BoolValue>,
        }
    }
    /// Model evaluation metrics for dimensionality reduction models.
    #[derive(serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DimensionalityReductionMetrics {
        /// Total percentage of variance explained by the selected principal
        /// components.
        #[prost(message, optional, tag = "1")]
        pub total_explained_variance_ratio:
            ::core::option::Option<super::super::super::super::protobuf::DoubleValue>,
    }
    /// Evaluation metrics of a model. These are either computed on all training
    /// data or just the eval data based on whether eval data was used during
    /// training. These are not present for imported models.
    #[derive(serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EvaluationMetrics {
        /// Metrics.
        #[prost(oneof = "evaluation_metrics::Metrics", tags = "1, 2, 3, 4, 5, 6, 7")]
        pub metrics: ::core::option::Option<evaluation_metrics::Metrics>,
    }
    /// Nested message and enum types in `EvaluationMetrics`.
    pub mod evaluation_metrics {
        /// Metrics.
        #[derive(serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Metrics {
            /// Populated for regression models and explicit feedback type matrix
            /// factorization models.
            #[prost(message, tag = "1")]
            RegressionMetrics(super::RegressionMetrics),
            /// Populated for binary classification/classifier models.
            #[prost(message, tag = "2")]
            BinaryClassificationMetrics(super::BinaryClassificationMetrics),
            /// Populated for multi-class classification/classifier models.
            #[prost(message, tag = "3")]
            MultiClassClassificationMetrics(super::MultiClassClassificationMetrics),
            /// Populated for clustering models.
            #[prost(message, tag = "4")]
            ClusteringMetrics(super::ClusteringMetrics),
            /// Populated for implicit feedback type matrix factorization models.
            #[prost(message, tag = "5")]
            RankingMetrics(super::RankingMetrics),
            /// Populated for ARIMA models.
            #[prost(message, tag = "6")]
            ArimaForecastingMetrics(super::ArimaForecastingMetrics),
            /// Evaluation metrics when the model is a dimensionality reduction model,
            /// which currently includes PCA.
            #[prost(message, tag = "7")]
            DimensionalityReductionMetrics(super::DimensionalityReductionMetrics),
        }
    }
    /// Data split result. This contains references to the training and evaluation
    /// data tables that were used to train the model.
    #[derive(serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DataSplitResult {
        /// Table reference of the training data after split.
        #[prost(message, optional, tag = "1")]
        pub training_table: ::core::option::Option<super::TableReference>,
        /// Table reference of the evaluation data after split.
        #[prost(message, optional, tag = "2")]
        pub evaluation_table: ::core::option::Option<super::TableReference>,
        /// Table reference of the test data after split.
        #[prost(message, optional, tag = "3")]
        pub test_table: ::core::option::Option<super::TableReference>,
    }
    /// Arima order, can be used for both non-seasonal and seasonal parts.
    #[derive(serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ArimaOrder {
        /// Order of the autoregressive part.
        #[prost(message, optional, tag = "1")]
        pub p: ::core::option::Option<super::super::super::super::protobuf::Int64Value>,
        /// Order of the differencing part.
        #[prost(message, optional, tag = "2")]
        pub d: ::core::option::Option<super::super::super::super::protobuf::Int64Value>,
        /// Order of the moving-average part.
        #[prost(message, optional, tag = "3")]
        pub q: ::core::option::Option<super::super::super::super::protobuf::Int64Value>,
    }
    /// ARIMA model fitting metrics.
    #[derive(serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ArimaFittingMetrics {
        /// Log-likelihood.
        #[prost(message, optional, tag = "1")]
        pub log_likelihood:
            ::core::option::Option<super::super::super::super::protobuf::DoubleValue>,
        /// AIC.
        #[prost(message, optional, tag = "2")]
        pub aic: ::core::option::Option<super::super::super::super::protobuf::DoubleValue>,
        /// Variance.
        #[prost(message, optional, tag = "3")]
        pub variance: ::core::option::Option<super::super::super::super::protobuf::DoubleValue>,
    }
    /// Global explanations containing the top most important features
    /// after training.
    #[derive(serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GlobalExplanation {
        /// A list of the top global explanations. Sorted by absolute value of
        /// attribution in descending order.
        #[prost(message, repeated, tag = "1")]
        pub explanations: ::prost::alloc::vec::Vec<global_explanation::Explanation>,
        /// Class label for this set of global explanations. Will be empty/null for
        /// binary logistic and linear regression models. Sorted alphabetically in
        /// descending order.
        #[prost(string, tag = "2")]
        pub class_label: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `GlobalExplanation`.
    pub mod global_explanation {
        /// Explanation for a single feature.
        #[derive(serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Explanation {
            /// The full feature name. For non-numerical features, will be formatted
            /// like `<column_name>.<encoded_feature_name>`. Overall size of feature
            /// name will always be truncated to first 120 characters.
            #[prost(string, tag = "1")]
            pub feature_name: ::prost::alloc::string::String,
            /// Attribution of feature.
            #[prost(message, optional, tag = "2")]
            pub attribution:
                ::core::option::Option<super::super::super::super::super::protobuf::DoubleValue>,
        }
    }
    /// Encoding methods for categorical features.
    #[derive(serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct CategoryEncodingMethod {}
    /// Nested message and enum types in `CategoryEncodingMethod`.
    pub mod category_encoding_method {
        /// Supported encoding methods for categorical features.
        #[derive(serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum EncodingMethod {
            /// Unspecified encoding method.
            Unspecified = 0,
            /// Applies one-hot encoding.
            OneHotEncoding = 1,
            /// Applies label encoding.
            LabelEncoding = 2,
            /// Applies dummy encoding.
            DummyEncoding = 3,
        }
        impl EncodingMethod {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "ENCODING_METHOD_UNSPECIFIED",
                    Self::OneHotEncoding => "ONE_HOT_ENCODING",
                    Self::LabelEncoding => "LABEL_ENCODING",
                    Self::DummyEncoding => "DUMMY_ENCODING",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "ENCODING_METHOD_UNSPECIFIED" => Some(Self::Unspecified),
                    "ONE_HOT_ENCODING" => Some(Self::OneHotEncoding),
                    "LABEL_ENCODING" => Some(Self::LabelEncoding),
                    "DUMMY_ENCODING" => Some(Self::DummyEncoding),
                    _ => None,
                }
            }
        }
    }
    /// PCA solver options.
    #[derive(serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct PcaSolverOptionEnums {}
    /// Nested message and enum types in `PcaSolverOptionEnums`.
    pub mod pca_solver_option_enums {
        /// Enums for supported PCA solvers.
        #[derive(serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum PcaSolver {
            /// Default value.
            Unspecified = 0,
            /// Full eigen-decoposition.
            Full = 1,
            /// Randomized SVD.
            Randomized = 2,
            /// Auto.
            Auto = 3,
        }
        impl PcaSolver {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "UNSPECIFIED",
                    Self::Full => "FULL",
                    Self::Randomized => "RANDOMIZED",
                    Self::Auto => "AUTO",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNSPECIFIED" => Some(Self::Unspecified),
                    "FULL" => Some(Self::Full),
                    "RANDOMIZED" => Some(Self::Randomized),
                    "AUTO" => Some(Self::Auto),
                    _ => None,
                }
            }
        }
    }
    /// Model registry options.
    #[derive(serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ModelRegistryOptionEnums {}
    /// Nested message and enum types in `ModelRegistryOptionEnums`.
    pub mod model_registry_option_enums {
        /// Enums for supported model registries.
        #[derive(serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum ModelRegistry {
            /// Default value.
            Unspecified = 0,
            /// Vertex AI.
            VertexAi = 1,
        }
        impl ModelRegistry {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "MODEL_REGISTRY_UNSPECIFIED",
                    Self::VertexAi => "VERTEX_AI",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "MODEL_REGISTRY_UNSPECIFIED" => Some(Self::Unspecified),
                    "VERTEX_AI" => Some(Self::VertexAi),
                    _ => None,
                }
            }
        }
    }
    /// Information about a single training query run for the model.
    #[derive(serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TrainingRun {
        /// Output only. Options that were used for this training run, includes
        /// user specified and default options that were used.
        #[prost(message, optional, tag = "1")]
        pub training_options: ::core::option::Option<training_run::TrainingOptions>,
        /// Output only. The start time of this training run.
        #[prost(message, optional, tag = "8")]
        pub start_time: ::core::option::Option<super::super::super::super::protobuf::Timestamp>,
        /// Output only. Output of each iteration run, results.size() <=
        /// max_iterations.
        #[prost(message, repeated, tag = "6")]
        pub results: ::prost::alloc::vec::Vec<training_run::IterationResult>,
        /// Output only. The evaluation metrics over training/eval data that were
        /// computed at the end of training.
        #[prost(message, optional, tag = "7")]
        pub evaluation_metrics: ::core::option::Option<EvaluationMetrics>,
        /// Output only. Data split result of the training run. Only set when the
        /// input data is actually split.
        #[prost(message, optional, tag = "9")]
        pub data_split_result: ::core::option::Option<DataSplitResult>,
        /// Output only. Global explanation contains the explanation of top features
        /// on the model level. Applies to both regression and classification models.
        #[prost(message, optional, tag = "11")]
        pub model_level_global_explanation: ::core::option::Option<GlobalExplanation>,
        /// Output only. Global explanation contains the explanation of top features
        /// on the class level. Applies to classification models only.
        #[prost(message, repeated, tag = "12")]
        pub class_level_global_explanations: ::prost::alloc::vec::Vec<GlobalExplanation>,
        /// The model id in the [Vertex AI Model
        /// Registry](<https://cloud.google.com/vertex-ai/docs/model-registry/introduction>)
        /// for this training run.
        #[prost(string, tag = "14")]
        pub vertex_ai_model_id: ::prost::alloc::string::String,
        /// Output only. The model version in the [Vertex AI Model
        /// Registry](<https://cloud.google.com/vertex-ai/docs/model-registry/introduction>)
        /// for this training run.
        #[prost(string, tag = "15")]
        pub vertex_ai_model_version: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `TrainingRun`.
    pub mod training_run {
        /// Options used in model training.
        #[derive(serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct TrainingOptions {
            /// The maximum number of iterations in training. Used only for iterative
            /// training algorithms.
            #[prost(int64, tag = "1")]
            pub max_iterations: i64,
            /// Type of loss function used during training run.
            #[prost(enumeration = "super::LossType", tag = "2")]
            pub loss_type: i32,
            /// Learning rate in training. Used only for iterative training algorithms.
            #[prost(double, tag = "3")]
            pub learn_rate: f64,
            /// L1 regularization coefficient.
            #[prost(message, optional, tag = "4")]
            pub l1_regularization:
                ::core::option::Option<super::super::super::super::super::protobuf::DoubleValue>,
            /// L2 regularization coefficient.
            #[prost(message, optional, tag = "5")]
            pub l2_regularization:
                ::core::option::Option<super::super::super::super::super::protobuf::DoubleValue>,
            /// When early_stop is true, stops training when accuracy improvement is
            /// less than 'min_relative_progress'. Used only for iterative training
            /// algorithms.
            #[prost(message, optional, tag = "6")]
            pub min_relative_progress:
                ::core::option::Option<super::super::super::super::super::protobuf::DoubleValue>,
            /// Whether to train a model from the last checkpoint.
            #[prost(message, optional, tag = "7")]
            pub warm_start:
                ::core::option::Option<super::super::super::super::super::protobuf::BoolValue>,
            /// Whether to stop early when the loss doesn't improve significantly
            /// any more (compared to min_relative_progress). Used only for iterative
            /// training algorithms.
            #[prost(message, optional, tag = "8")]
            pub early_stop:
                ::core::option::Option<super::super::super::super::super::protobuf::BoolValue>,
            /// Name of input label columns in training data.
            #[prost(string, repeated, tag = "9")]
            pub input_label_columns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            /// The data split type for training and evaluation, e.g. RANDOM.
            #[prost(enumeration = "super::DataSplitMethod", tag = "10")]
            pub data_split_method: i32,
            /// The fraction of evaluation data over the whole input data. The rest
            /// of data will be used as training data. The format should be double.
            /// Accurate to two decimal places.
            /// Default value is 0.2.
            #[prost(double, tag = "11")]
            pub data_split_eval_fraction: f64,
            /// The column to split data with. This column won't be used as a
            /// feature.
            /// 1. When data_split_method is CUSTOM, the corresponding column should
            /// be boolean. The rows with true value tag are eval data, and the false
            /// are training data.
            /// 2. When data_split_method is SEQ, the first DATA_SPLIT_EVAL_FRACTION
            /// rows (from smallest to largest) in the corresponding column are used
            /// as training data, and the rest are eval data. It respects the order
            /// in Orderable data types:
            /// <https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#data_type_properties>
            #[prost(string, tag = "12")]
            pub data_split_column: ::prost::alloc::string::String,
            /// The strategy to determine learn rate for the current iteration.
            #[prost(enumeration = "super::LearnRateStrategy", tag = "13")]
            pub learn_rate_strategy: i32,
            /// Specifies the initial learning rate for the line search learn rate
            /// strategy.
            #[prost(double, tag = "16")]
            pub initial_learn_rate: f64,
            /// Weights associated with each label class, for rebalancing the
            /// training data. Only applicable for classification models.
            #[prost(map = "string, double", tag = "17")]
            pub label_class_weights:
                ::std::collections::HashMap<::prost::alloc::string::String, f64>,
            /// User column specified for matrix factorization models.
            #[prost(string, tag = "18")]
            pub user_column: ::prost::alloc::string::String,
            /// Item column specified for matrix factorization models.
            #[prost(string, tag = "19")]
            pub item_column: ::prost::alloc::string::String,
            /// Distance type for clustering models.
            #[prost(enumeration = "super::DistanceType", tag = "20")]
            pub distance_type: i32,
            /// Number of clusters for clustering models.
            #[prost(int64, tag = "21")]
            pub num_clusters: i64,
            /// Google Cloud Storage URI from which the model was imported. Only
            /// applicable for imported models.
            #[prost(string, tag = "22")]
            pub model_uri: ::prost::alloc::string::String,
            /// Optimization strategy for training linear regression models.
            #[prost(enumeration = "super::OptimizationStrategy", tag = "23")]
            pub optimization_strategy: i32,
            /// Hidden units for dnn models.
            #[prost(int64, repeated, tag = "24")]
            pub hidden_units: ::prost::alloc::vec::Vec<i64>,
            /// Batch size for dnn models.
            #[prost(int64, tag = "25")]
            pub batch_size: i64,
            /// Dropout probability for dnn models.
            #[prost(message, optional, tag = "26")]
            pub dropout:
                ::core::option::Option<super::super::super::super::super::protobuf::DoubleValue>,
            /// Maximum depth of a tree for boosted tree models.
            #[prost(int64, tag = "27")]
            pub max_tree_depth: i64,
            /// Subsample fraction of the training data to grow tree to prevent
            /// overfitting for boosted tree models.
            #[prost(double, tag = "28")]
            pub subsample: f64,
            /// Minimum split loss for boosted tree models.
            #[prost(message, optional, tag = "29")]
            pub min_split_loss:
                ::core::option::Option<super::super::super::super::super::protobuf::DoubleValue>,
            /// Booster type for boosted tree models.
            #[prost(
                enumeration = "super::boosted_tree_option_enums::BoosterType",
                tag = "60"
            )]
            pub booster_type: i32,
            /// Number of parallel trees constructed during each iteration for boosted
            /// tree models.
            #[prost(message, optional, tag = "61")]
            pub num_parallel_tree:
                ::core::option::Option<super::super::super::super::super::protobuf::Int64Value>,
            /// Type of normalization algorithm for boosted tree models using
            /// dart booster.
            #[prost(
                enumeration = "super::boosted_tree_option_enums::DartNormalizeType",
                tag = "62"
            )]
            pub dart_normalize_type: i32,
            /// Tree construction algorithm for boosted tree models.
            #[prost(
                enumeration = "super::boosted_tree_option_enums::TreeMethod",
                tag = "63"
            )]
            pub tree_method: i32,
            /// Minimum sum of instance weight needed in a child for boosted tree
            /// models.
            #[prost(message, optional, tag = "64")]
            pub min_tree_child_weight:
                ::core::option::Option<super::super::super::super::super::protobuf::Int64Value>,
            /// Subsample ratio of columns when constructing each tree for boosted tree
            /// models.
            #[prost(message, optional, tag = "65")]
            pub colsample_bytree:
                ::core::option::Option<super::super::super::super::super::protobuf::DoubleValue>,
            /// Subsample ratio of columns for each level for boosted tree models.
            #[prost(message, optional, tag = "66")]
            pub colsample_bylevel:
                ::core::option::Option<super::super::super::super::super::protobuf::DoubleValue>,
            /// Subsample ratio of columns for each node(split) for boosted tree
            /// models.
            #[prost(message, optional, tag = "67")]
            pub colsample_bynode:
                ::core::option::Option<super::super::super::super::super::protobuf::DoubleValue>,
            /// Num factors specified for matrix factorization models.
            #[prost(int64, tag = "30")]
            pub num_factors: i64,
            /// Feedback type that specifies which algorithm to run for matrix
            /// factorization.
            #[prost(enumeration = "super::FeedbackType", tag = "31")]
            pub feedback_type: i32,
            /// Hyperparameter for matrix factoration when implicit feedback type is
            /// specified.
            #[prost(message, optional, tag = "32")]
            pub wals_alpha:
                ::core::option::Option<super::super::super::super::super::protobuf::DoubleValue>,
            /// The method used to initialize the centroids for kmeans algorithm.
            #[prost(
                enumeration = "super::kmeans_enums::KmeansInitializationMethod",
                tag = "33"
            )]
            pub kmeans_initialization_method: i32,
            /// The column used to provide the initial centroids for kmeans algorithm
            /// when kmeans_initialization_method is CUSTOM.
            #[prost(string, tag = "34")]
            pub kmeans_initialization_column: ::prost::alloc::string::String,
            /// Column to be designated as time series timestamp for ARIMA model.
            #[prost(string, tag = "35")]
            pub time_series_timestamp_column: ::prost::alloc::string::String,
            /// Column to be designated as time series data for ARIMA model.
            #[prost(string, tag = "36")]
            pub time_series_data_column: ::prost::alloc::string::String,
            /// Whether to enable auto ARIMA or not.
            #[prost(message, optional, tag = "37")]
            pub auto_arima:
                ::core::option::Option<super::super::super::super::super::protobuf::BoolValue>,
            /// A specification of the non-seasonal part of the ARIMA model: the three
            /// components (p, d, q) are the AR order, the degree of differencing, and
            /// the MA order.
            #[prost(message, optional, tag = "38")]
            pub non_seasonal_order: ::core::option::Option<super::ArimaOrder>,
            /// The data frequency of a time series.
            #[prost(enumeration = "super::DataFrequency", tag = "39")]
            pub data_frequency: i32,
            /// Whether or not p-value test should be computed for this model. Only
            /// available for linear and logistic regression models.
            #[prost(message, optional, tag = "40")]
            pub calculate_p_values:
                ::core::option::Option<super::super::super::super::super::protobuf::BoolValue>,
            /// Include drift when fitting an ARIMA model.
            #[prost(message, optional, tag = "41")]
            pub include_drift:
                ::core::option::Option<super::super::super::super::super::protobuf::BoolValue>,
            /// The geographical region based on which the holidays are considered in
            /// time series modeling. If a valid value is specified, then holiday
            /// effects modeling is enabled.
            #[prost(enumeration = "super::HolidayRegion", tag = "42")]
            pub holiday_region: i32,
            /// A list of geographical regions that are used for time series modeling.
            #[prost(enumeration = "super::HolidayRegion", repeated, tag = "71")]
            pub holiday_regions: ::prost::alloc::vec::Vec<i32>,
            /// The time series id column that was used during ARIMA model training.
            #[prost(string, tag = "43")]
            pub time_series_id_column: ::prost::alloc::string::String,
            /// The time series id columns that were used during ARIMA model training.
            #[prost(string, repeated, tag = "51")]
            pub time_series_id_columns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            /// The forecast limit lower bound that was used during ARIMA model
            /// training with limits. To see more details of the algorithm:
            /// <https://otexts.com/fpp2/limits.html>
            #[prost(double, tag = "99")]
            pub forecast_limit_lower_bound: f64,
            /// The forecast limit upper bound that was used during ARIMA model
            /// training with limits.
            #[prost(double, tag = "100")]
            pub forecast_limit_upper_bound: f64,
            /// The number of periods ahead that need to be forecasted.
            #[prost(int64, tag = "44")]
            pub horizon: i64,
            /// The max value of the sum of non-seasonal p and q.
            #[prost(int64, tag = "46")]
            pub auto_arima_max_order: i64,
            /// The min value of the sum of non-seasonal p and q.
            #[prost(int64, tag = "83")]
            pub auto_arima_min_order: i64,
            /// Number of trials to run this hyperparameter tuning job.
            #[prost(int64, tag = "47")]
            pub num_trials: i64,
            /// Maximum number of trials to run in parallel.
            #[prost(int64, tag = "48")]
            pub max_parallel_trials: i64,
            /// The target evaluation metrics to optimize the hyperparameters for.
            #[prost(
                enumeration = "super::hparam_tuning_enums::HparamTuningObjective",
                repeated,
                tag = "54"
            )]
            pub hparam_tuning_objectives: ::prost::alloc::vec::Vec<i32>,
            /// If true, perform decompose time series and save the results.
            #[prost(message, optional, tag = "50")]
            pub decompose_time_series:
                ::core::option::Option<super::super::super::super::super::protobuf::BoolValue>,
            /// If true, clean spikes and dips in the input time series.
            #[prost(message, optional, tag = "52")]
            pub clean_spikes_and_dips:
                ::core::option::Option<super::super::super::super::super::protobuf::BoolValue>,
            /// If true, detect step changes and make data adjustment in the input time
            /// series.
            #[prost(message, optional, tag = "53")]
            pub adjust_step_changes:
                ::core::option::Option<super::super::super::super::super::protobuf::BoolValue>,
            /// If true, enable global explanation during training.
            #[prost(message, optional, tag = "55")]
            pub enable_global_explain:
                ::core::option::Option<super::super::super::super::super::protobuf::BoolValue>,
            /// Number of paths for the sampled Shapley explain method.
            #[prost(int64, tag = "56")]
            pub sampled_shapley_num_paths: i64,
            /// Number of integral steps for the integrated gradients explain method.
            #[prost(int64, tag = "57")]
            pub integrated_gradients_num_steps: i64,
            /// Categorical feature encoding method.
            #[prost(
                enumeration = "super::category_encoding_method::EncodingMethod",
                tag = "58"
            )]
            pub category_encoding_method: i32,
            /// Based on the selected TF version, the corresponding docker image is
            /// used to train external models.
            #[prost(string, tag = "70")]
            pub tf_version: ::prost::alloc::string::String,
            /// Enums for color space, used for processing images in Object Table.
            /// See more details at
            /// <https://www.tensorflow.org/io/tutorials/colorspace.>
            #[prost(enumeration = "super::ColorSpace", tag = "72")]
            pub color_space: i32,
            /// Name of the instance weight column for training data.
            /// This column isn't be used as a feature.
            #[prost(string, tag = "73")]
            pub instance_weight_column: ::prost::alloc::string::String,
            /// Smoothing window size for the trend component. When a positive value is
            /// specified, a center moving average smoothing is applied on the history
            /// trend. When the smoothing window is out of the boundary at the
            /// beginning or the end of the trend, the first element or the last
            /// element is padded to fill the smoothing window before the average is
            /// applied.
            #[prost(int64, tag = "74")]
            pub trend_smoothing_window_size: i64,
            /// The fraction of the interpolated length of the time series that's used
            /// to model the time series trend component. All of the time points of the
            /// time series are used to model the non-trend component. This training
            /// option accelerates modeling training without sacrificing much
            /// forecasting accuracy. You can use this option with
            /// `minTimeSeriesLength` but not with `maxTimeSeriesLength`.
            #[prost(double, tag = "75")]
            pub time_series_length_fraction: f64,
            /// The minimum number of time points in a time series that are used in
            /// modeling the trend component of the time series. If you use this option
            /// you must also set the `timeSeriesLengthFraction` option. This training
            /// option ensures that enough time points are available when you use
            /// `timeSeriesLengthFraction` in trend modeling. This is particularly
            /// important when forecasting multiple time series in a single query using
            /// `timeSeriesIdColumn`. If the total number of time points is less than
            /// the `minTimeSeriesLength` value, then the query uses all available time
            /// points.
            #[prost(int64, tag = "76")]
            pub min_time_series_length: i64,
            /// The maximum number of time points in a time series that can be used in
            /// modeling the trend component of the time series. Don't use this option
            /// with the `timeSeriesLengthFraction` or `minTimeSeriesLength` options.
            #[prost(int64, tag = "77")]
            pub max_time_series_length: i64,
            /// User-selected XGBoost versions for training of XGBoost models.
            #[prost(string, tag = "78")]
            pub xgboost_version: ::prost::alloc::string::String,
            /// Whether to use approximate feature contribution method in XGBoost model
            /// explanation for global explain.
            #[prost(message, optional, tag = "84")]
            pub approx_global_feature_contrib:
                ::core::option::Option<super::super::super::super::super::protobuf::BoolValue>,
            /// Whether the model should include intercept during model training.
            #[prost(message, optional, tag = "85")]
            pub fit_intercept:
                ::core::option::Option<super::super::super::super::super::protobuf::BoolValue>,
            /// Number of principal components to keep in the PCA model. Must be <= the
            /// number of features.
            #[prost(int64, tag = "86")]
            pub num_principal_components: i64,
            /// The minimum ratio of cumulative explained variance that needs to be
            /// given by the PCA model.
            #[prost(double, tag = "87")]
            pub pca_explained_variance_ratio: f64,
            /// If true, scale the feature values by dividing the feature standard
            /// deviation. Currently only apply to PCA.
            #[prost(message, optional, tag = "88")]
            pub scale_features:
                ::core::option::Option<super::super::super::super::super::protobuf::BoolValue>,
            /// The solver for PCA.
            #[prost(enumeration = "super::pca_solver_option_enums::PcaSolver", tag = "89")]
            pub pca_solver: i32,
            /// Whether to calculate class weights automatically based on the
            /// popularity of each label.
            #[prost(message, optional, tag = "90")]
            pub auto_class_weights:
                ::core::option::Option<super::super::super::super::super::protobuf::BoolValue>,
            /// Activation function of the neural nets.
            #[prost(string, tag = "91")]
            pub activation_fn: ::prost::alloc::string::String,
            /// Optimizer used for training the neural nets.
            #[prost(string, tag = "92")]
            pub optimizer: ::prost::alloc::string::String,
            /// Budget in hours for AutoML training.
            #[prost(double, tag = "93")]
            pub budget_hours: f64,
            /// Whether to standardize numerical features. Default to true.
            #[prost(message, optional, tag = "94")]
            pub standardize_features:
                ::core::option::Option<super::super::super::super::super::protobuf::BoolValue>,
            /// L1 regularization coefficient to activations.
            #[prost(double, tag = "95")]
            pub l1_reg_activation: f64,
            /// The model registry.
            #[prost(
                enumeration = "super::model_registry_option_enums::ModelRegistry",
                tag = "96"
            )]
            pub model_registry: i32,
            /// The version aliases to apply in Vertex AI model registry. Always
            /// overwrite if the version aliases exists in a existing model.
            #[prost(string, repeated, tag = "97")]
            pub vertex_ai_model_version_aliases:
                ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            /// Optional. Names of the columns to slice on. Applies to contribution
            /// analysis models.
            #[prost(string, repeated, tag = "104")]
            pub dimension_id_columns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            /// The contribution metric. Applies to contribution analysis models.
            /// Allowed formats supported are for summable and summable ratio
            /// contribution metrics. These include expressions such as `SUM(x)` or
            /// `SUM(x)/SUM(y)`, where x and y are column names from the base table.
            #[prost(string, optional, tag = "105")]
            pub contribution_metric: ::core::option::Option<::prost::alloc::string::String>,
            /// Name of the column used to determine the rows corresponding to control
            /// and test. Applies to contribution analysis models.
            #[prost(string, optional, tag = "106")]
            pub is_test_column: ::core::option::Option<::prost::alloc::string::String>,
            /// The apriori support minimum. Applies to contribution analysis models.
            #[prost(double, optional, tag = "107")]
            pub min_apriori_support: ::core::option::Option<f64>,
        }
        /// Information about a single iteration of the training run.
        #[derive(serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct IterationResult {
            /// Index of the iteration, 0 based.
            #[prost(message, optional, tag = "1")]
            pub index:
                ::core::option::Option<super::super::super::super::super::protobuf::Int32Value>,
            /// Time taken to run the iteration in milliseconds.
            #[prost(message, optional, tag = "4")]
            pub duration_ms:
                ::core::option::Option<super::super::super::super::super::protobuf::Int64Value>,
            /// Loss computed on the training data at the end of iteration.
            #[prost(message, optional, tag = "5")]
            pub training_loss:
                ::core::option::Option<super::super::super::super::super::protobuf::DoubleValue>,
            /// Loss computed on the eval data at the end of iteration.
            #[prost(message, optional, tag = "6")]
            pub eval_loss:
                ::core::option::Option<super::super::super::super::super::protobuf::DoubleValue>,
            /// Learn rate used for this iteration.
            #[prost(double, tag = "7")]
            pub learn_rate: f64,
            /// Information about top clusters for clustering models.
            #[prost(message, repeated, tag = "8")]
            pub cluster_infos: ::prost::alloc::vec::Vec<iteration_result::ClusterInfo>,
            /// Arima result.
            #[prost(message, optional, tag = "9")]
            pub arima_result: ::core::option::Option<iteration_result::ArimaResult>,
            /// The information of the principal components.
            #[prost(message, repeated, tag = "10")]
            pub principal_component_infos:
                ::prost::alloc::vec::Vec<iteration_result::PrincipalComponentInfo>,
        }
        /// Nested message and enum types in `IterationResult`.
        pub mod iteration_result {
            /// Information about a single cluster for clustering model.
            #[derive(serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, Copy, PartialEq, ::prost::Message)]
            pub struct ClusterInfo {
                /// Centroid id.
                #[prost(int64, tag = "1")]
                pub centroid_id: i64,
                /// Cluster radius, the average distance from centroid
                /// to each point assigned to the cluster.
                #[prost(message, optional, tag = "2")]
                pub cluster_radius: ::core::option::Option<
                    super::super::super::super::super::super::protobuf::DoubleValue,
                >,
                /// Cluster size, the total number of points assigned to the cluster.
                #[prost(message, optional, tag = "3")]
                pub cluster_size: ::core::option::Option<
                    super::super::super::super::super::super::protobuf::Int64Value,
                >,
            }
            /// (Auto-)arima fitting result. Wrap everything in ArimaResult for easier
            /// refactoring if we want to use model-specific iteration results.
            #[derive(serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct ArimaResult {
                /// This message is repeated because there are multiple arima models
                /// fitted in auto-arima. For non-auto-arima model, its size is one.
                #[prost(message, repeated, tag = "1")]
                pub arima_model_info: ::prost::alloc::vec::Vec<arima_result::ArimaModelInfo>,
                /// Seasonal periods. Repeated because multiple periods are supported for
                /// one time series.
                #[prost(
                    enumeration = "super::super::seasonal_period::SeasonalPeriodType",
                    repeated,
                    tag = "2"
                )]
                pub seasonal_periods: ::prost::alloc::vec::Vec<i32>,
            }
            /// Nested message and enum types in `ArimaResult`.
            pub mod arima_result {
                /// Arima coefficients.
                #[derive(serde::Deserialize, serde::Serialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct ArimaCoefficients {
                    /// Auto-regressive coefficients, an array of double.
                    #[prost(double, repeated, tag = "1")]
                    pub auto_regressive_coefficients: ::prost::alloc::vec::Vec<f64>,
                    /// Moving-average coefficients, an array of double.
                    #[prost(double, repeated, tag = "2")]
                    pub moving_average_coefficients: ::prost::alloc::vec::Vec<f64>,
                    /// Intercept coefficient, just a double not an array.
                    #[prost(message, optional, tag = "3")]
                    pub intercept_coefficient: ::core::option::Option<
                        super::super::super::super::super::super::super::protobuf::DoubleValue,
                    >,
                }
                /// Arima model information.
                #[derive(serde::Deserialize, serde::Serialize)]
                #[serde(rename_all = "camelCase")]
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct ArimaModelInfo {
                    /// Non-seasonal order.
                    #[prost(message, optional, tag = "1")]
                    pub non_seasonal_order: ::core::option::Option<super::super::super::ArimaOrder>,
                    /// Arima coefficients.
                    #[prost(message, optional, tag = "2")]
                    pub arima_coefficients: ::core::option::Option<ArimaCoefficients>,
                    /// Arima fitting metrics.
                    #[prost(message, optional, tag = "3")]
                    pub arima_fitting_metrics:
                        ::core::option::Option<super::super::super::ArimaFittingMetrics>,
                    /// Whether Arima model fitted with drift or not. It is always false
                    /// when d is not 1.
                    #[prost(message, optional, tag = "4")]
                    pub has_drift: ::core::option::Option<
                        super::super::super::super::super::super::super::protobuf::BoolValue,
                    >,
                    /// The time_series_id value for this time series. It will be one of
                    /// the unique values from the time_series_id_column specified during
                    /// ARIMA model training. Only present when time_series_id_column
                    /// training option was used.
                    #[prost(string, tag = "5")]
                    pub time_series_id: ::prost::alloc::string::String,
                    /// The tuple of time_series_ids identifying this time series. It will
                    /// be one of the unique tuples of values present in the
                    /// time_series_id_columns specified during ARIMA model training. Only
                    /// present when time_series_id_columns training option was used and
                    /// the order of values here are same as the order of
                    /// time_series_id_columns.
                    #[prost(string, repeated, tag = "10")]
                    pub time_series_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                    /// Seasonal periods. Repeated because multiple periods are supported
                    /// for one time series.
                    #[prost(
                        enumeration = "super::super::super::seasonal_period::SeasonalPeriodType",
                        repeated,
                        tag = "6"
                    )]
                    pub seasonal_periods: ::prost::alloc::vec::Vec<i32>,
                    /// If true, holiday_effect is a part of time series decomposition
                    /// result.
                    #[prost(message, optional, tag = "7")]
                    pub has_holiday_effect: ::core::option::Option<
                        super::super::super::super::super::super::super::protobuf::BoolValue,
                    >,
                    /// If true, spikes_and_dips is a part of time series decomposition
                    /// result.
                    #[prost(message, optional, tag = "8")]
                    pub has_spikes_and_dips: ::core::option::Option<
                        super::super::super::super::super::super::super::protobuf::BoolValue,
                    >,
                    /// If true, step_changes is a part of time series decomposition
                    /// result.
                    #[prost(message, optional, tag = "9")]
                    pub has_step_changes: ::core::option::Option<
                        super::super::super::super::super::super::super::protobuf::BoolValue,
                    >,
                }
            }
            /// Principal component infos, used only for eigen decomposition based
            /// models, e.g., PCA. Ordered by explained_variance in the descending
            /// order.
            #[derive(serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[derive(Clone, Copy, PartialEq, ::prost::Message)]
            pub struct PrincipalComponentInfo {
                /// Id of the principal component.
                #[prost(message, optional, tag = "1")]
                pub principal_component_id: ::core::option::Option<
                    super::super::super::super::super::super::protobuf::Int64Value,
                >,
                /// Explained variance by this principal component, which is simply the
                /// eigenvalue.
                #[prost(message, optional, tag = "2")]
                pub explained_variance: ::core::option::Option<
                    super::super::super::super::super::super::protobuf::DoubleValue,
                >,
                /// Explained_variance over the total explained variance.
                #[prost(message, optional, tag = "3")]
                pub explained_variance_ratio: ::core::option::Option<
                    super::super::super::super::super::super::protobuf::DoubleValue,
                >,
                /// The explained_variance is pre-ordered in the descending order to
                /// compute the cumulative explained variance ratio.
                #[prost(message, optional, tag = "4")]
                pub cumulative_explained_variance_ratio: ::core::option::Option<
                    super::super::super::super::super::super::protobuf::DoubleValue,
                >,
            }
        }
    }
    /// Search space for a double hyperparameter.
    #[derive(serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DoubleHparamSearchSpace {
        /// Search space.
        #[prost(oneof = "double_hparam_search_space::SearchSpace", tags = "1, 2")]
        pub search_space: ::core::option::Option<double_hparam_search_space::SearchSpace>,
    }
    /// Nested message and enum types in `DoubleHparamSearchSpace`.
    pub mod double_hparam_search_space {
        /// Range of a double hyperparameter.
        #[derive(serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct DoubleRange {
            /// Min value of the double parameter.
            #[prost(message, optional, tag = "1")]
            pub min:
                ::core::option::Option<super::super::super::super::super::protobuf::DoubleValue>,
            /// Max value of the double parameter.
            #[prost(message, optional, tag = "2")]
            pub max:
                ::core::option::Option<super::super::super::super::super::protobuf::DoubleValue>,
        }
        /// Discrete candidates of a double hyperparameter.
        #[derive(serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct DoubleCandidates {
            /// Candidates for the double parameter in increasing order.
            #[prost(message, repeated, tag = "1")]
            pub candidates:
                ::prost::alloc::vec::Vec<super::super::super::super::super::protobuf::DoubleValue>,
        }
        /// Search space.
        #[derive(serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum SearchSpace {
            /// Range of the double hyperparameter.
            #[prost(message, tag = "1")]
            Range(DoubleRange),
            /// Candidates of the double hyperparameter.
            #[prost(message, tag = "2")]
            Candidates(DoubleCandidates),
        }
    }
    /// Search space for an int hyperparameter.
    #[derive(serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IntHparamSearchSpace {
        /// Search space.
        #[prost(oneof = "int_hparam_search_space::SearchSpace", tags = "1, 2")]
        pub search_space: ::core::option::Option<int_hparam_search_space::SearchSpace>,
    }
    /// Nested message and enum types in `IntHparamSearchSpace`.
    pub mod int_hparam_search_space {
        /// Range of an int hyperparameter.
        #[derive(serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct IntRange {
            /// Min value of the int parameter.
            #[prost(message, optional, tag = "1")]
            pub min:
                ::core::option::Option<super::super::super::super::super::protobuf::Int64Value>,
            /// Max value of the int parameter.
            #[prost(message, optional, tag = "2")]
            pub max:
                ::core::option::Option<super::super::super::super::super::protobuf::Int64Value>,
        }
        /// Discrete candidates of an int hyperparameter.
        #[derive(serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct IntCandidates {
            /// Candidates for the int parameter in increasing order.
            #[prost(message, repeated, tag = "1")]
            pub candidates:
                ::prost::alloc::vec::Vec<super::super::super::super::super::protobuf::Int64Value>,
        }
        /// Search space.
        #[derive(serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum SearchSpace {
            /// Range of the int hyperparameter.
            #[prost(message, tag = "1")]
            Range(IntRange),
            /// Candidates of the int hyperparameter.
            #[prost(message, tag = "2")]
            Candidates(IntCandidates),
        }
    }
    /// Search space for string and enum.
    #[derive(serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StringHparamSearchSpace {
        /// Canididates for the string or enum parameter in lower case.
        #[prost(string, repeated, tag = "1")]
        pub candidates: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    /// Search space for int array.
    #[derive(serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IntArrayHparamSearchSpace {
        /// Candidates for the int array parameter.
        #[prost(message, repeated, tag = "1")]
        pub candidates: ::prost::alloc::vec::Vec<int_array_hparam_search_space::IntArray>,
    }
    /// Nested message and enum types in `IntArrayHparamSearchSpace`.
    pub mod int_array_hparam_search_space {
        /// An array of int.
        #[derive(serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct IntArray {
            /// Elements in the int array.
            #[prost(int64, repeated, tag = "1")]
            pub elements: ::prost::alloc::vec::Vec<i64>,
        }
    }
    /// Hyperparameter search spaces.
    /// These should be a subset of training_options.
    #[derive(serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct HparamSearchSpaces {
        /// Learning rate of training jobs.
        #[prost(message, optional, tag = "2")]
        pub learn_rate: ::core::option::Option<DoubleHparamSearchSpace>,
        /// L1 regularization coefficient.
        #[prost(message, optional, tag = "3")]
        pub l1_reg: ::core::option::Option<DoubleHparamSearchSpace>,
        /// L2 regularization coefficient.
        #[prost(message, optional, tag = "4")]
        pub l2_reg: ::core::option::Option<DoubleHparamSearchSpace>,
        /// Number of clusters for k-means.
        #[prost(message, optional, tag = "26")]
        pub num_clusters: ::core::option::Option<IntHparamSearchSpace>,
        /// Number of latent factors to train on.
        #[prost(message, optional, tag = "31")]
        pub num_factors: ::core::option::Option<IntHparamSearchSpace>,
        /// Hidden units for neural network models.
        #[prost(message, optional, tag = "34")]
        pub hidden_units: ::core::option::Option<IntArrayHparamSearchSpace>,
        /// Mini batch sample size.
        #[prost(message, optional, tag = "37")]
        pub batch_size: ::core::option::Option<IntHparamSearchSpace>,
        /// Dropout probability for dnn model training and boosted tree models
        /// using dart booster.
        #[prost(message, optional, tag = "38")]
        pub dropout: ::core::option::Option<DoubleHparamSearchSpace>,
        /// Maximum depth of a tree for boosted tree models.
        #[prost(message, optional, tag = "41")]
        pub max_tree_depth: ::core::option::Option<IntHparamSearchSpace>,
        /// Subsample the training data to grow tree to prevent overfitting for
        /// boosted tree models.
        #[prost(message, optional, tag = "42")]
        pub subsample: ::core::option::Option<DoubleHparamSearchSpace>,
        /// Minimum split loss for boosted tree models.
        #[prost(message, optional, tag = "43")]
        pub min_split_loss: ::core::option::Option<DoubleHparamSearchSpace>,
        /// Hyperparameter for matrix factoration when implicit feedback type is
        /// specified.
        #[prost(message, optional, tag = "49")]
        pub wals_alpha: ::core::option::Option<DoubleHparamSearchSpace>,
        /// Booster type for boosted tree models.
        #[prost(message, optional, tag = "56")]
        pub booster_type: ::core::option::Option<StringHparamSearchSpace>,
        /// Number of parallel trees for boosted tree models.
        #[prost(message, optional, tag = "57")]
        pub num_parallel_tree: ::core::option::Option<IntHparamSearchSpace>,
        /// Dart normalization type for boosted tree models.
        #[prost(message, optional, tag = "58")]
        pub dart_normalize_type: ::core::option::Option<StringHparamSearchSpace>,
        /// Tree construction algorithm for boosted tree models.
        #[prost(message, optional, tag = "59")]
        pub tree_method: ::core::option::Option<StringHparamSearchSpace>,
        /// Minimum sum of instance weight needed in a child for boosted tree models.
        #[prost(message, optional, tag = "60")]
        pub min_tree_child_weight: ::core::option::Option<IntHparamSearchSpace>,
        /// Subsample ratio of columns when constructing each tree for boosted tree
        /// models.
        #[prost(message, optional, tag = "61")]
        pub colsample_bytree: ::core::option::Option<DoubleHparamSearchSpace>,
        /// Subsample ratio of columns for each level for boosted tree models.
        #[prost(message, optional, tag = "62")]
        pub colsample_bylevel: ::core::option::Option<DoubleHparamSearchSpace>,
        /// Subsample ratio of columns for each node(split) for boosted tree models.
        #[prost(message, optional, tag = "63")]
        pub colsample_bynode: ::core::option::Option<DoubleHparamSearchSpace>,
        /// Activation functions of neural network models.
        #[prost(message, optional, tag = "67")]
        pub activation_fn: ::core::option::Option<StringHparamSearchSpace>,
        /// Optimizer of TF models.
        #[prost(message, optional, tag = "68")]
        pub optimizer: ::core::option::Option<StringHparamSearchSpace>,
    }
    /// Training info of a trial in [hyperparameter
    /// tuning](<https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-syntax-hp-tuning-overview>)
    /// models.
    #[derive(serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct HparamTuningTrial {
        /// 1-based index of the trial.
        #[prost(int64, tag = "1")]
        pub trial_id: i64,
        /// Starting time of the trial.
        #[prost(int64, tag = "2")]
        pub start_time_ms: i64,
        /// Ending time of the trial.
        #[prost(int64, tag = "3")]
        pub end_time_ms: i64,
        /// The hyperprameters selected for this trial.
        #[prost(message, optional, tag = "4")]
        pub hparams: ::core::option::Option<training_run::TrainingOptions>,
        /// Evaluation metrics of this trial calculated on the test data.
        /// Empty in Job API.
        #[prost(message, optional, tag = "5")]
        pub evaluation_metrics: ::core::option::Option<EvaluationMetrics>,
        /// The status of the trial.
        #[prost(enumeration = "hparam_tuning_trial::TrialStatus", tag = "6")]
        pub status: i32,
        /// Error message for FAILED and INFEASIBLE trial.
        #[prost(string, tag = "7")]
        pub error_message: ::prost::alloc::string::String,
        /// Loss computed on the training data at the end of trial.
        #[prost(message, optional, tag = "8")]
        pub training_loss:
            ::core::option::Option<super::super::super::super::protobuf::DoubleValue>,
        /// Loss computed on the eval data at the end of trial.
        #[prost(message, optional, tag = "9")]
        pub eval_loss: ::core::option::Option<super::super::super::super::protobuf::DoubleValue>,
        /// Hyperparameter tuning evaluation metrics of this trial calculated on the
        /// eval data. Unlike evaluation_metrics, only the fields corresponding to
        /// the hparam_tuning_objectives are set.
        #[prost(message, optional, tag = "10")]
        pub hparam_tuning_evaluation_metrics: ::core::option::Option<EvaluationMetrics>,
    }
    /// Nested message and enum types in `HparamTuningTrial`.
    pub mod hparam_tuning_trial {
        /// Current status of the trial.
        #[derive(serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum TrialStatus {
            /// Default value.
            Unspecified = 0,
            /// Scheduled but not started.
            NotStarted = 1,
            /// Running state.
            Running = 2,
            /// The trial succeeded.
            Succeeded = 3,
            /// The trial failed.
            Failed = 4,
            /// The trial is infeasible due to the invalid params.
            Infeasible = 5,
            /// Trial stopped early because it's not promising.
            StoppedEarly = 6,
        }
        impl TrialStatus {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "TRIAL_STATUS_UNSPECIFIED",
                    Self::NotStarted => "NOT_STARTED",
                    Self::Running => "RUNNING",
                    Self::Succeeded => "SUCCEEDED",
                    Self::Failed => "FAILED",
                    Self::Infeasible => "INFEASIBLE",
                    Self::StoppedEarly => "STOPPED_EARLY",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "TRIAL_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                    "NOT_STARTED" => Some(Self::NotStarted),
                    "RUNNING" => Some(Self::Running),
                    "SUCCEEDED" => Some(Self::Succeeded),
                    "FAILED" => Some(Self::Failed),
                    "INFEASIBLE" => Some(Self::Infeasible),
                    "STOPPED_EARLY" => Some(Self::StoppedEarly),
                    _ => None,
                }
            }
        }
    }
    /// Indicates the type of the Model.
    #[derive(serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ModelType {
        /// Default value.
        Unspecified = 0,
        /// Linear regression model.
        LinearRegression = 1,
        /// Logistic regression based classification model.
        LogisticRegression = 2,
        /// K-means clustering model.
        Kmeans = 3,
        /// Matrix factorization model.
        MatrixFactorization = 4,
        /// DNN classifier model.
        DnnClassifier = 5,
        /// An imported TensorFlow model.
        Tensorflow = 6,
        /// DNN regressor model.
        DnnRegressor = 7,
        /// An imported XGBoost model.
        Xgboost = 8,
        /// Boosted tree regressor model.
        BoostedTreeRegressor = 9,
        /// Boosted tree classifier model.
        BoostedTreeClassifier = 10,
        /// ARIMA model.
        Arima = 11,
        /// AutoML Tables regression model.
        AutomlRegressor = 12,
        /// AutoML Tables classification model.
        AutomlClassifier = 13,
        /// Prinpical Component Analysis model.
        Pca = 14,
        /// Wide-and-deep classifier model.
        DnnLinearCombinedClassifier = 16,
        /// Wide-and-deep regressor model.
        DnnLinearCombinedRegressor = 17,
        /// Autoencoder model.
        Autoencoder = 18,
        /// New name for the ARIMA model.
        ArimaPlus = 19,
        /// ARIMA with external regressors.
        ArimaPlusXreg = 23,
        /// Random forest regressor model.
        RandomForestRegressor = 24,
        /// Random forest classifier model.
        RandomForestClassifier = 25,
        /// An imported TensorFlow Lite model.
        TensorflowLite = 26,
        /// An imported ONNX model.
        Onnx = 28,
        /// Model to capture the columns and logic in the TRANSFORM clause along with
        /// statistics useful for ML analytic functions.
        TransformOnly = 29,
        /// The contribution analysis model.
        ContributionAnalysis = 37,
    }
    impl ModelType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MODEL_TYPE_UNSPECIFIED",
                Self::LinearRegression => "LINEAR_REGRESSION",
                Self::LogisticRegression => "LOGISTIC_REGRESSION",
                Self::Kmeans => "KMEANS",
                Self::MatrixFactorization => "MATRIX_FACTORIZATION",
                Self::DnnClassifier => "DNN_CLASSIFIER",
                Self::Tensorflow => "TENSORFLOW",
                Self::DnnRegressor => "DNN_REGRESSOR",
                Self::Xgboost => "XGBOOST",
                Self::BoostedTreeRegressor => "BOOSTED_TREE_REGRESSOR",
                Self::BoostedTreeClassifier => "BOOSTED_TREE_CLASSIFIER",
                Self::Arima => "ARIMA",
                Self::AutomlRegressor => "AUTOML_REGRESSOR",
                Self::AutomlClassifier => "AUTOML_CLASSIFIER",
                Self::Pca => "PCA",
                Self::DnnLinearCombinedClassifier => "DNN_LINEAR_COMBINED_CLASSIFIER",
                Self::DnnLinearCombinedRegressor => "DNN_LINEAR_COMBINED_REGRESSOR",
                Self::Autoencoder => "AUTOENCODER",
                Self::ArimaPlus => "ARIMA_PLUS",
                Self::ArimaPlusXreg => "ARIMA_PLUS_XREG",
                Self::RandomForestRegressor => "RANDOM_FOREST_REGRESSOR",
                Self::RandomForestClassifier => "RANDOM_FOREST_CLASSIFIER",
                Self::TensorflowLite => "TENSORFLOW_LITE",
                Self::Onnx => "ONNX",
                Self::TransformOnly => "TRANSFORM_ONLY",
                Self::ContributionAnalysis => "CONTRIBUTION_ANALYSIS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MODEL_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "LINEAR_REGRESSION" => Some(Self::LinearRegression),
                "LOGISTIC_REGRESSION" => Some(Self::LogisticRegression),
                "KMEANS" => Some(Self::Kmeans),
                "MATRIX_FACTORIZATION" => Some(Self::MatrixFactorization),
                "DNN_CLASSIFIER" => Some(Self::DnnClassifier),
                "TENSORFLOW" => Some(Self::Tensorflow),
                "DNN_REGRESSOR" => Some(Self::DnnRegressor),
                "XGBOOST" => Some(Self::Xgboost),
                "BOOSTED_TREE_REGRESSOR" => Some(Self::BoostedTreeRegressor),
                "BOOSTED_TREE_CLASSIFIER" => Some(Self::BoostedTreeClassifier),
                "ARIMA" => Some(Self::Arima),
                "AUTOML_REGRESSOR" => Some(Self::AutomlRegressor),
                "AUTOML_CLASSIFIER" => Some(Self::AutomlClassifier),
                "PCA" => Some(Self::Pca),
                "DNN_LINEAR_COMBINED_CLASSIFIER" => Some(Self::DnnLinearCombinedClassifier),
                "DNN_LINEAR_COMBINED_REGRESSOR" => Some(Self::DnnLinearCombinedRegressor),
                "AUTOENCODER" => Some(Self::Autoencoder),
                "ARIMA_PLUS" => Some(Self::ArimaPlus),
                "ARIMA_PLUS_XREG" => Some(Self::ArimaPlusXreg),
                "RANDOM_FOREST_REGRESSOR" => Some(Self::RandomForestRegressor),
                "RANDOM_FOREST_CLASSIFIER" => Some(Self::RandomForestClassifier),
                "TENSORFLOW_LITE" => Some(Self::TensorflowLite),
                "ONNX" => Some(Self::Onnx),
                "TRANSFORM_ONLY" => Some(Self::TransformOnly),
                "CONTRIBUTION_ANALYSIS" => Some(Self::ContributionAnalysis),
                _ => None,
            }
        }
    }
    /// Loss metric to evaluate model training performance.
    #[derive(serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum LossType {
        /// Default value.
        Unspecified = 0,
        /// Mean squared loss, used for linear regression.
        MeanSquaredLoss = 1,
        /// Mean log loss, used for logistic regression.
        MeanLogLoss = 2,
    }
    impl LossType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "LOSS_TYPE_UNSPECIFIED",
                Self::MeanSquaredLoss => "MEAN_SQUARED_LOSS",
                Self::MeanLogLoss => "MEAN_LOG_LOSS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LOSS_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "MEAN_SQUARED_LOSS" => Some(Self::MeanSquaredLoss),
                "MEAN_LOG_LOSS" => Some(Self::MeanLogLoss),
                _ => None,
            }
        }
    }
    /// Distance metric used to compute the distance between two points.
    #[derive(serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum DistanceType {
        /// Default value.
        Unspecified = 0,
        /// Eculidean distance.
        Euclidean = 1,
        /// Cosine distance.
        Cosine = 2,
    }
    impl DistanceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "DISTANCE_TYPE_UNSPECIFIED",
                Self::Euclidean => "EUCLIDEAN",
                Self::Cosine => "COSINE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DISTANCE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "EUCLIDEAN" => Some(Self::Euclidean),
                "COSINE" => Some(Self::Cosine),
                _ => None,
            }
        }
    }
    /// Indicates the method to split input data into multiple tables.
    #[derive(serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum DataSplitMethod {
        /// Default value.
        Unspecified = 0,
        /// Splits data randomly.
        Random = 1,
        /// Splits data with the user provided tags.
        Custom = 2,
        /// Splits data sequentially.
        Sequential = 3,
        /// Data split will be skipped.
        NoSplit = 4,
        /// Splits data automatically: Uses NO_SPLIT if the data size is small.
        /// Otherwise uses RANDOM.
        AutoSplit = 5,
    }
    impl DataSplitMethod {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "DATA_SPLIT_METHOD_UNSPECIFIED",
                Self::Random => "RANDOM",
                Self::Custom => "CUSTOM",
                Self::Sequential => "SEQUENTIAL",
                Self::NoSplit => "NO_SPLIT",
                Self::AutoSplit => "AUTO_SPLIT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DATA_SPLIT_METHOD_UNSPECIFIED" => Some(Self::Unspecified),
                "RANDOM" => Some(Self::Random),
                "CUSTOM" => Some(Self::Custom),
                "SEQUENTIAL" => Some(Self::Sequential),
                "NO_SPLIT" => Some(Self::NoSplit),
                "AUTO_SPLIT" => Some(Self::AutoSplit),
                _ => None,
            }
        }
    }
    /// Type of supported data frequency for time series forecasting models.
    #[derive(serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum DataFrequency {
        /// Default value.
        Unspecified = 0,
        /// Automatically inferred from timestamps.
        AutoFrequency = 1,
        /// Yearly data.
        Yearly = 2,
        /// Quarterly data.
        Quarterly = 3,
        /// Monthly data.
        Monthly = 4,
        /// Weekly data.
        Weekly = 5,
        /// Daily data.
        Daily = 6,
        /// Hourly data.
        Hourly = 7,
        /// Per-minute data.
        PerMinute = 8,
    }
    impl DataFrequency {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "DATA_FREQUENCY_UNSPECIFIED",
                Self::AutoFrequency => "AUTO_FREQUENCY",
                Self::Yearly => "YEARLY",
                Self::Quarterly => "QUARTERLY",
                Self::Monthly => "MONTHLY",
                Self::Weekly => "WEEKLY",
                Self::Daily => "DAILY",
                Self::Hourly => "HOURLY",
                Self::PerMinute => "PER_MINUTE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DATA_FREQUENCY_UNSPECIFIED" => Some(Self::Unspecified),
                "AUTO_FREQUENCY" => Some(Self::AutoFrequency),
                "YEARLY" => Some(Self::Yearly),
                "QUARTERLY" => Some(Self::Quarterly),
                "MONTHLY" => Some(Self::Monthly),
                "WEEKLY" => Some(Self::Weekly),
                "DAILY" => Some(Self::Daily),
                "HOURLY" => Some(Self::Hourly),
                "PER_MINUTE" => Some(Self::PerMinute),
                _ => None,
            }
        }
    }
    /// Type of supported holiday regions for time series forecasting models.
    #[derive(serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum HolidayRegion {
        /// Holiday region unspecified.
        Unspecified = 0,
        /// Global.
        Global = 1,
        /// North America.
        Na = 2,
        /// Japan and Asia Pacific: Korea, Greater China, India, Australia, and New
        /// Zealand.
        Japac = 3,
        /// Europe, the Middle East and Africa.
        Emea = 4,
        /// Latin America and the Caribbean.
        Lac = 5,
        /// United Arab Emirates
        Ae = 6,
        /// Argentina
        Ar = 7,
        /// Austria
        At = 8,
        /// Australia
        Au = 9,
        /// Belgium
        Be = 10,
        /// Brazil
        Br = 11,
        /// Canada
        Ca = 12,
        /// Switzerland
        Ch = 13,
        /// Chile
        Cl = 14,
        /// China
        Cn = 15,
        /// Colombia
        Co = 16,
        /// Czechoslovakia
        Cs = 17,
        /// Czech Republic
        Cz = 18,
        /// Germany
        De = 19,
        /// Denmark
        Dk = 20,
        /// Algeria
        Dz = 21,
        /// Ecuador
        Ec = 22,
        /// Estonia
        Ee = 23,
        /// Egypt
        Eg = 24,
        /// Spain
        Es = 25,
        /// Finland
        Fi = 26,
        /// France
        Fr = 27,
        /// Great Britain (United Kingdom)
        Gb = 28,
        /// Greece
        Gr = 29,
        /// Hong Kong
        Hk = 30,
        /// Hungary
        Hu = 31,
        /// Indonesia
        Id = 32,
        /// Ireland
        Ie = 33,
        /// Israel
        Il = 34,
        /// India
        In = 35,
        /// Iran
        Ir = 36,
        /// Italy
        It = 37,
        /// Japan
        Jp = 38,
        /// Korea (South)
        Kr = 39,
        /// Latvia
        Lv = 40,
        /// Morocco
        Ma = 41,
        /// Mexico
        Mx = 42,
        /// Malaysia
        My = 43,
        /// Nigeria
        Ng = 44,
        /// Netherlands
        Nl = 45,
        /// Norway
        No = 46,
        /// New Zealand
        Nz = 47,
        /// Peru
        Pe = 48,
        /// Philippines
        Ph = 49,
        /// Pakistan
        Pk = 50,
        /// Poland
        Pl = 51,
        /// Portugal
        Pt = 52,
        /// Romania
        Ro = 53,
        /// Serbia
        Rs = 54,
        /// Russian Federation
        Ru = 55,
        /// Saudi Arabia
        Sa = 56,
        /// Sweden
        Se = 57,
        /// Singapore
        Sg = 58,
        /// Slovenia
        Si = 59,
        /// Slovakia
        Sk = 60,
        /// Thailand
        Th = 61,
        /// Turkey
        Tr = 62,
        /// Taiwan
        Tw = 63,
        /// Ukraine
        Ua = 64,
        /// United States
        Us = 65,
        /// Venezuela
        Ve = 66,
        /// Vietnam
        Vn = 67,
        /// South Africa
        Za = 68,
    }
    impl HolidayRegion {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "HOLIDAY_REGION_UNSPECIFIED",
                Self::Global => "GLOBAL",
                Self::Na => "NA",
                Self::Japac => "JAPAC",
                Self::Emea => "EMEA",
                Self::Lac => "LAC",
                Self::Ae => "AE",
                Self::Ar => "AR",
                Self::At => "AT",
                Self::Au => "AU",
                Self::Be => "BE",
                Self::Br => "BR",
                Self::Ca => "CA",
                Self::Ch => "CH",
                Self::Cl => "CL",
                Self::Cn => "CN",
                Self::Co => "CO",
                Self::Cs => "CS",
                Self::Cz => "CZ",
                Self::De => "DE",
                Self::Dk => "DK",
                Self::Dz => "DZ",
                Self::Ec => "EC",
                Self::Ee => "EE",
                Self::Eg => "EG",
                Self::Es => "ES",
                Self::Fi => "FI",
                Self::Fr => "FR",
                Self::Gb => "GB",
                Self::Gr => "GR",
                Self::Hk => "HK",
                Self::Hu => "HU",
                Self::Id => "ID",
                Self::Ie => "IE",
                Self::Il => "IL",
                Self::In => "IN",
                Self::Ir => "IR",
                Self::It => "IT",
                Self::Jp => "JP",
                Self::Kr => "KR",
                Self::Lv => "LV",
                Self::Ma => "MA",
                Self::Mx => "MX",
                Self::My => "MY",
                Self::Ng => "NG",
                Self::Nl => "NL",
                Self::No => "NO",
                Self::Nz => "NZ",
                Self::Pe => "PE",
                Self::Ph => "PH",
                Self::Pk => "PK",
                Self::Pl => "PL",
                Self::Pt => "PT",
                Self::Ro => "RO",
                Self::Rs => "RS",
                Self::Ru => "RU",
                Self::Sa => "SA",
                Self::Se => "SE",
                Self::Sg => "SG",
                Self::Si => "SI",
                Self::Sk => "SK",
                Self::Th => "TH",
                Self::Tr => "TR",
                Self::Tw => "TW",
                Self::Ua => "UA",
                Self::Us => "US",
                Self::Ve => "VE",
                Self::Vn => "VN",
                Self::Za => "ZA",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "HOLIDAY_REGION_UNSPECIFIED" => Some(Self::Unspecified),
                "GLOBAL" => Some(Self::Global),
                "NA" => Some(Self::Na),
                "JAPAC" => Some(Self::Japac),
                "EMEA" => Some(Self::Emea),
                "LAC" => Some(Self::Lac),
                "AE" => Some(Self::Ae),
                "AR" => Some(Self::Ar),
                "AT" => Some(Self::At),
                "AU" => Some(Self::Au),
                "BE" => Some(Self::Be),
                "BR" => Some(Self::Br),
                "CA" => Some(Self::Ca),
                "CH" => Some(Self::Ch),
                "CL" => Some(Self::Cl),
                "CN" => Some(Self::Cn),
                "CO" => Some(Self::Co),
                "CS" => Some(Self::Cs),
                "CZ" => Some(Self::Cz),
                "DE" => Some(Self::De),
                "DK" => Some(Self::Dk),
                "DZ" => Some(Self::Dz),
                "EC" => Some(Self::Ec),
                "EE" => Some(Self::Ee),
                "EG" => Some(Self::Eg),
                "ES" => Some(Self::Es),
                "FI" => Some(Self::Fi),
                "FR" => Some(Self::Fr),
                "GB" => Some(Self::Gb),
                "GR" => Some(Self::Gr),
                "HK" => Some(Self::Hk),
                "HU" => Some(Self::Hu),
                "ID" => Some(Self::Id),
                "IE" => Some(Self::Ie),
                "IL" => Some(Self::Il),
                "IN" => Some(Self::In),
                "IR" => Some(Self::Ir),
                "IT" => Some(Self::It),
                "JP" => Some(Self::Jp),
                "KR" => Some(Self::Kr),
                "LV" => Some(Self::Lv),
                "MA" => Some(Self::Ma),
                "MX" => Some(Self::Mx),
                "MY" => Some(Self::My),
                "NG" => Some(Self::Ng),
                "NL" => Some(Self::Nl),
                "NO" => Some(Self::No),
                "NZ" => Some(Self::Nz),
                "PE" => Some(Self::Pe),
                "PH" => Some(Self::Ph),
                "PK" => Some(Self::Pk),
                "PL" => Some(Self::Pl),
                "PT" => Some(Self::Pt),
                "RO" => Some(Self::Ro),
                "RS" => Some(Self::Rs),
                "RU" => Some(Self::Ru),
                "SA" => Some(Self::Sa),
                "SE" => Some(Self::Se),
                "SG" => Some(Self::Sg),
                "SI" => Some(Self::Si),
                "SK" => Some(Self::Sk),
                "TH" => Some(Self::Th),
                "TR" => Some(Self::Tr),
                "TW" => Some(Self::Tw),
                "UA" => Some(Self::Ua),
                "US" => Some(Self::Us),
                "VE" => Some(Self::Ve),
                "VN" => Some(Self::Vn),
                "ZA" => Some(Self::Za),
                _ => None,
            }
        }
    }
    /// Enums for color space, used for processing images in Object Table.
    /// See more details at
    /// <https://www.tensorflow.org/io/tutorials/colorspace.>
    #[derive(serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ColorSpace {
        /// Unspecified color space
        Unspecified = 0,
        /// RGB
        Rgb = 1,
        /// HSV
        Hsv = 2,
        /// YIQ
        Yiq = 3,
        /// YUV
        Yuv = 4,
        /// GRAYSCALE
        Grayscale = 5,
    }
    impl ColorSpace {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "COLOR_SPACE_UNSPECIFIED",
                Self::Rgb => "RGB",
                Self::Hsv => "HSV",
                Self::Yiq => "YIQ",
                Self::Yuv => "YUV",
                Self::Grayscale => "GRAYSCALE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COLOR_SPACE_UNSPECIFIED" => Some(Self::Unspecified),
                "RGB" => Some(Self::Rgb),
                "HSV" => Some(Self::Hsv),
                "YIQ" => Some(Self::Yiq),
                "YUV" => Some(Self::Yuv),
                "GRAYSCALE" => Some(Self::Grayscale),
                _ => None,
            }
        }
    }
    /// Indicates the learning rate optimization strategy to use.
    #[derive(serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum LearnRateStrategy {
        /// Default value.
        Unspecified = 0,
        /// Use line search to determine learning rate.
        LineSearch = 1,
        /// Use a constant learning rate.
        Constant = 2,
    }
    impl LearnRateStrategy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "LEARN_RATE_STRATEGY_UNSPECIFIED",
                Self::LineSearch => "LINE_SEARCH",
                Self::Constant => "CONSTANT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LEARN_RATE_STRATEGY_UNSPECIFIED" => Some(Self::Unspecified),
                "LINE_SEARCH" => Some(Self::LineSearch),
                "CONSTANT" => Some(Self::Constant),
                _ => None,
            }
        }
    }
    /// Indicates the optimization strategy used for training.
    #[derive(serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum OptimizationStrategy {
        /// Default value.
        Unspecified = 0,
        /// Uses an iterative batch gradient descent algorithm.
        BatchGradientDescent = 1,
        /// Uses a normal equation to solve linear regression problem.
        NormalEquation = 2,
    }
    impl OptimizationStrategy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "OPTIMIZATION_STRATEGY_UNSPECIFIED",
                Self::BatchGradientDescent => "BATCH_GRADIENT_DESCENT",
                Self::NormalEquation => "NORMAL_EQUATION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OPTIMIZATION_STRATEGY_UNSPECIFIED" => Some(Self::Unspecified),
                "BATCH_GRADIENT_DESCENT" => Some(Self::BatchGradientDescent),
                "NORMAL_EQUATION" => Some(Self::NormalEquation),
                _ => None,
            }
        }
    }
    /// Indicates the training algorithm to use for matrix factorization models.
    #[derive(serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum FeedbackType {
        /// Default value.
        Unspecified = 0,
        /// Use weighted-als for implicit feedback problems.
        Implicit = 1,
        /// Use nonweighted-als for explicit feedback problems.
        Explicit = 2,
    }
    impl FeedbackType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "FEEDBACK_TYPE_UNSPECIFIED",
                Self::Implicit => "IMPLICIT",
                Self::Explicit => "EXPLICIT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FEEDBACK_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "IMPLICIT" => Some(Self::Implicit),
                "EXPLICIT" => Some(Self::Explicit),
                _ => None,
            }
        }
    }
}
/// Request format for getting information about a BigQuery ML model.
#[derive(serde::Deserialize, serde::Serialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetModelRequest {
    /// Required. Project ID of the requested model.
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Required. Dataset ID of the requested model.
    #[prost(string, tag = "2")]
    pub dataset_id: ::prost::alloc::string::String,
    /// Required. Model ID of the requested model.
    #[prost(string, tag = "3")]
    pub model_id: ::prost::alloc::string::String,
}
#[derive(serde::Deserialize, serde::Serialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchModelRequest {
    /// Required. Project ID of the model to patch.
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Required. Dataset ID of the model to patch.
    #[prost(string, tag = "2")]
    pub dataset_id: ::prost::alloc::string::String,
    /// Required. Model ID of the model to patch.
    #[prost(string, tag = "3")]
    pub model_id: ::prost::alloc::string::String,
    /// Required. Patched model.
    /// Follows RFC5789 patch semantics. Missing fields are not updated.
    /// To clear a field, explicitly set to default value.
    #[prost(message, optional, tag = "4")]
    pub model: ::core::option::Option<Model>,
}
/// Request format for deleting BigQuery ML models.
#[derive(serde::Deserialize, serde::Serialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteModelRequest {
    /// Required. Project ID of the model to delete.
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Required. Dataset ID of the model to delete.
    #[prost(string, tag = "2")]
    pub dataset_id: ::prost::alloc::string::String,
    /// Required. Model ID of the model to delete.
    #[prost(string, tag = "3")]
    pub model_id: ::prost::alloc::string::String,
}
/// Request format for listing BigQuery ML models.
#[derive(serde::Deserialize, serde::Serialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListModelsRequest {
    /// Required. Project ID of the models to list.
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Required. Dataset ID of the models to list.
    #[prost(string, tag = "2")]
    pub dataset_id: ::prost::alloc::string::String,
    /// The maximum number of results to return in a single response page.
    /// Leverage the page tokens to iterate through the entire collection.
    #[prost(message, optional, tag = "3")]
    pub max_results: ::core::option::Option<super::super::super::protobuf::UInt32Value>,
    /// Page token, returned by a previous call to request the next page of
    /// results
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response format for a single page when listing BigQuery ML models.
#[derive(serde::Deserialize, serde::Serialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListModelsResponse {
    /// Models in the requested dataset. Only the following fields are populated:
    /// model_reference, model_type, creation_time, last_modified_time and
    /// labels.
    #[prost(message, repeated, tag = "1")]
    pub models: ::prost::alloc::vec::Vec<Model>,
    /// A token to request the next page of results.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod model_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// Model Service for BigQuery ML
    #[derive(Debug, Clone)]
    pub struct ModelServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ModelServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ModelServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ModelServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                    http::Request<tonic::body::Body>,
                    Response = http::Response<
                        <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                    >,
                >,
            <T as tonic::codegen::Service<http::Request<tonic::body::Body>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ModelServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Gets the specified model resource by model ID.
        pub async fn get_model(
            &mut self,
            request: impl tonic::IntoRequest<super::GetModelRequest>,
        ) -> std::result::Result<tonic::Response<super::Model>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.bigquery.v2.ModelService/GetModel",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.bigquery.v2.ModelService",
                "GetModel",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Lists all models in the specified dataset. Requires the READER dataset
        /// role. After retrieving the list of models, you can get information about a
        /// particular model by calling the models.get method.
        pub async fn list_models(
            &mut self,
            request: impl tonic::IntoRequest<super::ListModelsRequest>,
        ) -> std::result::Result<tonic::Response<super::ListModelsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.bigquery.v2.ModelService/ListModels",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.bigquery.v2.ModelService",
                "ListModels",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Patch specific fields in the specified model.
        pub async fn patch_model(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchModelRequest>,
        ) -> std::result::Result<tonic::Response<super::Model>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.bigquery.v2.ModelService/PatchModel",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.bigquery.v2.ModelService",
                "PatchModel",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the model specified by modelId from the dataset.
        pub async fn delete_model(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteModelRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::protobuf::Empty>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.bigquery.v2.ModelService/DeleteModel",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "google.cloud.bigquery.v2.ModelService",
                "DeleteModel",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
