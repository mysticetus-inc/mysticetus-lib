#![feature(buf_read_has_data_left)]
use std::collections::{BTreeMap, BTreeSet};
use std::fs::{self, File};
use std::io::{BufRead, BufReader, BufWriter, Read, Write};
use std::path::Path;

use anyhow::anyhow;
use flate2::bufread::GzDecoder;
use parse_zoneinfo::line::{Line, LineParser};
use parse_zoneinfo::table::{Table, TableBuilder};
use parse_zoneinfo::transitions::{FixedTimespan, FixedTimespanSet};

const TZ_FILE_POINTER: &str = "tz-data-file";
const RERUN_ENV_FLAG: &str = "REGEN_TIMEZONES";

const DST_FILEPATH: &str = "src/generated.rs";

const VERSION_FILE: &str = "version";

const DATA_FILES: &[&str] = &[
    "africa",
    "antarctica",
    "asia",
    "australiasia",
    "backward",
    // "backzone",
    "etcetera",
    "europe",
    "northamerica",
    "southamerica",
];

fn main() -> anyhow::Result<()> {
    println!("cargo:rerun-if-changed={}", TZ_FILE_POINTER);
    println!("cargo:rerun-if-env-changed={}", RERUN_ENV_FLAG);

    let tz_archive_path = fs::read_to_string(TZ_FILE_POINTER)?;
    let tz_archive_file = File::open(&tz_archive_path)?;
    let mut tz_archive = tar::Archive::new(GzDecoder::new(BufReader::new(tz_archive_file)));

    let mut version = None;

    let mut tables = BTreeMap::new();

    let mut line_buf = String::new();

    let line_parser = LineParser::new();

    for result in tz_archive.entries()? {
        let mut entry = result?;

        let path = entry.path()?;

        if version.is_none() && path == Path::new(VERSION_FILE) {
            read_version_file(&mut entry, &mut version, &mut line_buf)?;
            continue;
        }

        if let Some(data_file) = is_data_file(&path) {
            let mut table_builder = TableBuilder::new();
            read_data_file(&line_parser, &mut entry, &mut table_builder, &mut line_buf)?;
            tables.insert(data_file, table_builder.build());
        }
    }

    let dst_file = File::create(DST_FILEPATH)?;
    let mut dst_file = BufWriter::new(dst_file);

    writeln!(
        dst_file,
        "//! Generated by the 'timestamp-tz' build script\n"
    )?;

    if let Some(version) = version.as_deref() {
        writeln!(
            dst_file,
            "/// The time zone database version this file was generated from."
        )?;
        writeln!(
            dst_file,
            "pub const TZ_DB_VERSION: &str = \"{}\";\n",
            version
        )?;
    }

    // write_links(&tables, &mut dst_file, &mut line_buf)?;

    /*
    writeln!(dst_file, "const RULEINFO_KEYS: &[&str] = &[")?;
    let set = table.rulesets.keys().collect::<BTreeSet<_>>();

    for item in set {
        writeln!(dst_file, "\t\"{item}\",")?;
    }
    writeln!(dst_file, "];\n")?;

    writeln!(dst_file, "const ZONEINFO_KEYS: &[&str] = &[")?;

    for key in table.zonesets.keys().collect::<BTreeSet<_>>() {
        writeln!(dst_file, "\t\"{key}\",")?;
    }
    writeln!(dst_file, "];\n")?;
    */
    use parse_zoneinfo::transitions::TableTransitions;
    /*
    let test = table.timespans("America/Los_Angeles").unwrap();

    writeln!(
        dst_file,
        "const LA_INFO: &[crate::Span<'static, Option<i64>>] = &["
    )?;

    write_span(&mut dst_file, None, &test.first)?;

    for (start, span) in test.rest.iter() {
        write_span(&mut dst_file, Some(*start), span)?;
    }

    writeln!(dst_file, "];\n")?;
    */

    let mut map = BTreeMap::new();

    for (name, table) in tables.iter() {
        for zone_name in table.zonesets.keys() {
            println!("{name}: {zone_name}");
            if let Some(span) = table.timespans(zone_name) {
                write_abbr_mapping(&mut map, zone_name, span);
            }
        }
    }

    let mut map_builder = phf_codegen::OrderedMap::new();

    for (abbr, set) in map {
        let value = format!("&{}", SetAsList(set));
        map_builder.entry(abbr, &value);
    }

    writeln!(
        dst_file,
        "pub static ABBR_LINKS: phf::Map<&'static str, &'static [&'static str]> = {};\n",
        map_builder.build()
    )?;

    Ok(())
}

struct SetAsList(BTreeSet<String>);

impl std::fmt::Display for SetAsList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_list().entries(self.0.iter().map(Quoted)).finish()
    }
}

struct Quoted<T>(T);

impl<T: std::fmt::Display> std::fmt::Debug for Quoted<T> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "\"{}\"", self.0)
    }
}

#[allow(unused)]
fn write_span<W: Write>(
    writer: &mut W,
    start: Option<i64>,
    span: &FixedTimespan,
) -> anyhow::Result<()> {
    writeln!(writer, "\tcrate::Span {{")?;
    writeln!(writer, "\t\tname: \"{}\",", span.name)?;
    writeln!(writer, "\t\tutc_offset: {},", span.utc_offset)?;
    writeln!(writer, "\t\tdst_offset: {},", span.dst_offset)?;

    match start {
        Some(start) => writeln!(writer, "\t\tstarts: Some({start}),")?,
        None => writeln!(writer, "\t\tstarts: None,")?,
    }

    writeln!(writer, "\t}},")?;

    Ok(())
}

fn write_abbr_mapping(
    map: &mut BTreeMap<String, BTreeSet<String>>,
    value: &str,
    ts_set: FixedTimespanSet,
) {
    fn insert_name(map: &mut BTreeMap<String, BTreeSet<String>>, value: &str, span: FixedTimespan) {
        map.entry(span.name).or_default().insert(value.to_owned());
    }

    insert_name(map, value, ts_set.first);
    for (_, rem) in ts_set.rest {
        insert_name(map, value, rem);
    }
}

fn should_omit(ch: char) -> bool {
    ch.is_ascii_whitespace() || ch.is_ascii_control()
}

fn is_data_file(path: &Path) -> Option<&'static str> {
    DATA_FILES
        .binary_search_by(|target| Path::new(target).cmp(path))
        .ok()
        .map(|idx| DATA_FILES[idx])
}

fn read_version_file<R: Read>(
    entry: &mut tar::Entry<'_, R>,
    dst: &mut Option<String>,
    buf: &mut String,
) -> anyhow::Result<()> {
    buf.clear();
    entry.read_to_string(buf)?;

    if let Some(last_char_idx) = buf.rfind(|ch: char| !should_omit(ch)) {
        buf.truncate(last_char_idx + 1);
    }

    *dst = Some(buf.split_off(0));
    Ok(())
}

fn add_line(table_builder: &mut TableBuilder, line: Line<'_>) -> anyhow::Result<()> {
    fn conv_err(err: parse_zoneinfo::table::Error<'_>) -> anyhow::Error {
        anyhow::format_err!("{}", err)
    }

    match line {
        Line::Space => (),
        Line::Zone(zone) => table_builder.add_zone_line(zone).map_err(conv_err)?,
        Line::Continuation(cont) => table_builder
            .add_continuation_line(cont)
            .map_err(conv_err)?,
        Line::Rule(rule) => table_builder.add_rule_line(rule).map_err(conv_err)?,
        Line::Link(link) => {
            let _ = table_builder.add_link_line(link);
        }
    }

    Ok(())
}

fn read_data_file<R: Read>(
    line_parser: &LineParser,
    entry: &mut tar::Entry<'_, R>,
    table_builder: &mut TableBuilder,
    buf: &mut String,
) -> anyhow::Result<()> {
    let mut reader = BufReader::new(entry);

    while reader.has_data_left()? {
        buf.clear();
        reader.read_line(buf)?;

        if let Some(comment_start) = buf.find('#') {
            buf.truncate(comment_start);
        }

        if let Some(trailing_start) = buf.rfind(|ch: char| !should_omit(ch)) {
            buf.truncate(trailing_start + 1);
        }

        if !buf.is_empty() {
            match line_parser.parse_str(&buf) {
                Ok(line) => {
                    if let Err(err) = add_line(table_builder, line) {
                        return Err(anyhow!("{err}: {buf}"));
                    }
                }
                Err(err) => return Err(anyhow!("{err:?}: {buf}")),
            }
        }
    }

    Ok(())
}

#[allow(unused)]
fn write_links<W: Write>(table: &Table, dst: &mut W, buf: &mut String) -> anyhow::Result<()> {
    let mut map_builder = phf_codegen::OrderedMap::new();

    buf.clear();
    buf.push_str("\"");
    for (link, link_to) in table.links.iter() {
        buf.truncate(1);
        buf.push_str(link_to);
        buf.push_str("\"");

        map_builder.entry(link, buf);
    }

    writeln!(
        dst,
        "pub static LINKS: phf::Map<&'static str, &'static str> = {};\n",
        map_builder.build()
    )?;

    Ok(())
}
